global proc polyWiz()
{

}

//LAYOUT
//==============================================================================
//POLY WIZ MAIN LAYOUT
//----------------------------
global proc polyWizLayout(string $parent)
{
	
	polyWizMenuBarLayout();
	
	conformScaleLayout($parent);
	
	//wizQuickTransformsLayout($parent);
	
	polyPlanesLayout($parent);
	
	polyDivisionsInputLayout($parent);
	
	polyTurbulenceLayout($parent);
	
	recreateMeshLayout($parent);
	
	splitMeshByCubicAreaLayout($parent);
	
	polyEdgeToCurveLayout($parent);
	
	wizRepeatOffsetCurveLayout($parent);
	
	slicingLayout($parent);
		
	projectCurvesLayout($parent);
	
	wizPolyPiecesLayout($parent);
	
	terrainTileBlanketLayout($parent);
	
	vueTerrainTileProcessingLayout($parent);
	
	convertPolyVertexColorsToTextureLayout($parent);

}

global proc polyDivisionsInputLayout( string $parent )
{
	string $layout = `frameLayout
		-l "Divisions"	
		-ann ""
		-bv true
		//-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent
		polyWizPolyDivisions_frameLayout
		`;	

	
	/*
	string $bc = ("string $m[] = smartSelectObjectsOfType(`ls -sl`, \"mesh\");"+"\n"
	+"");
	
	
	textFieldButtonGrp
		-l "Mesh"
		-cal 1 "left"
		-bl "Select"
		-bc 
*/
/*
	string $ac = ("string $m[] = smartSelectObjectsOfType(`ls -sl`, \"mesh\");"+"\n"
	+"for ($i=0;$i<`size $m`;$i++){"+"\n"
	+"	meshInputDivisionsControl(\"polyWizPolyDivisions_frameLayout\", $m[$i]);"+"\n"
	+"}"+"\n");
	
	*/
	
	string $ac = (
	"meshInputDivisionsControl(\"polyWizPolyDivisions_frameLayout\");"+"\n"
	);
	
	menuBarLayout ;
		menu -l "Add";
			menuItem -l "Add Controls For Selected Mesh" -c $ac;
	
}

global proc meshInputDivisionsControl( string $parent )
{
	string $sel[] = `ls -sl`;
	$obj = $sel[0];
	
	string $layout = `frameLayout
		-l ($obj + " Division Controls")
		-ann ""
		-bv true
		//-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent
		("polyWiz_" + $obj + "InputDivisions_frameLayout")
		`;	
	
	string $history[] = `listHistory $obj`;	
	string $inputs[];
	string $smoothFace[] = `ls -type polySmoothFace $history`;
	string $subDiv[] = `ls -type polySubdFace $history`;
	if (`size $smoothFace` == 0 && `size $subDiv` == 0){
		return ;
	}
	//string $nurbsTess[] = `ls -type nurbsTesselate $history`;
	appendStringArray($inputs, $smoothFace, `size $smoothFace`);
	appendStringArray($inputs, $subDiv, `size $subDiv`);
	
	for ($i=0;$i<`size $smoothFace`;$i++){
		
		wizHeaderText(("-c " + $smoothFace[$i]));
		string $divl = `intSliderGrp
			-l "Divisions"
			-f true
			-cal 1 "left"
		
			-min 0
			-max 4
			("polyWiz_" + $obj + "_" + $smoothFace[$i] + "Divisions_intSliderGrp")
			`;
			
		connectControl $divl ($smoothFace[$i] + ".divisions");
			
		catchQuiet(`attrControlGrp -l "Node State" -a ($smoothFace[$i] + ".nodeState") ("polyWiz_" + $obj + "_" + $smoothFace[$i] + "NodeState_attrControl")`);
		
		wizSeparator(); 
	
		
			
	}
	
	for ($i=0;$i<`size $subDiv`;$i++){
		
		wizHeaderText(("-c " + $subDiv[$i]));
		string $divUisg = `intSliderGrp
			-l "Divisions U"
			-f true
			-cal 1 "left"
			
			-min 0
			-max 8
			("polyWiz_" + $obj + "_" + $subDiv[$i] + "DivisionsU_intSliderGrp")
			`;
			
		connectControl $divUisg ($subDiv[$i] + ".divisionsU");
		
		string $divVisg = `intSliderGrp
			-l "Divisions V"
			-f true
			-cal 1 "left"
			
			-min 0
			-max 8
			("polyWiz_" + $obj + "_" + $subDiv[$i] + "DivisionsV_intSliderGrp")
			`;
			
		connectControl $divVisg ($subDiv[$i] + ".divisionsV");
		
		catchQuiet(`attrControlGrp -l "Node State" -a ($subDiv[$i] + ".nodeState") ("polyWiz_" + $obj + "_" + $subDiv[$i] + "NodeState_attrControl")`);
		
		wizSeparator(); 
	
		
			
	}
	
	setParent ..;

}

//POLY PLANES LAYOUT
//-----------------------------
global proc polyPlanesLayout(string $parent)
{
	saveWizState("frameLayout", "-cl", "polyPlanesLayout_frameLayout_frameLayout");
	saveWizState("floatSliderButtonGrp", "-v", "createSinglePolyPlane_floatSliderButtonGrp");
	
	string $layout = `frameLayout
		-l "Planes"	
		-ann ""
		-bv true
		//-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent
		polyPlanesLayout_frameLayout
	`;	
	
	global float $WIZ_singlePolyPlaneSize;
	
	floatSliderButtonGrp 
		-cal 1 "left" 
		-cw3 140 70 100
		-l "Make A Single Poly Plane:" 
		-minValue 0.0001		
		-maxValue 100
		-value $WIZ_singlePolyPlaneSize 
		//-precision 3
		-fieldMinValue 0.0001 
		-fieldMaxValue 10000000
		-fs 0.05
		-sliderStep 1
		-step 1
		//-changeCommand "setPlaybackBy"
		-buttonLabel "Create"
		-buttonCommand "createSinglePolyPlane"
		-field true	
		-ann ""
		createSinglePolyPlane_floatSliderButtonGrp
		;
	
	setParent..;
}

//POLY TURBULENCE LAYOUT
//-----------------------------
global proc polyTurbulenceLayout(string $parent)
{

	string $layout = wizStandardFrameLayoutNoMargins($parent,"Poly Turbulence","polyTurbulenceLayout_frameLayout");
		
	string $sectionHelpTab[] = createSectionAndHelpTabLayout($layout,"PolyTurbulence");
		
	setParent $sectionHelpTab[0];
	
	checkBoxGrp 
		-numberOfCheckBoxes 3
		-labelArray3 "X-Axis" "Y-Axis" "Z-Axis"
		-v1 `getWizIntVar polyTurbulenceAxisesV1`
		-v2 `getWizIntVar polyTurbulenceAxisesV2`
		-v3 `getWizIntVar polyTurbulenceAxisesV3`
	       polyTurbulenceAxises_checkBoxGrp
	       ;
	
	floatFieldGrp 
		-numberOfFields 1
		-l "Turbulence Amount"
		-v1 1
		polyTurbulenceAmount_floatFieldGrp
		;

	button 
		-label "Generate Turbulence"
		-w 500
		-command "polyTurbulence()"
		;
		
	button
		-label "Smooth All Selected Poly Meshes"
		-w 500 
		-command "smoothAllSelectedPoly(`ls -sl`)"
		;
		
	button
		-label "Reduce All Selected Poly Meshes"
		-w 500 
		-command "reduceAllSelectedPoly(`ls -sl`)"
		;
	
		setParent $sectionHelpTab[1];
	
	text
		-align "left"
		-ww true
		-rs true
		-l "Turbulence Amount Moves the vertices of the selected object by a random amount."
		;
		
}

//SPLIT MESH BY CUBIC AREA LAYOUT
//-------------------------------------
global proc splitMeshByCubicAreaLayout(string $parent)
{
	string $layout = `frameLayout
		-l "Split Mesh By Cubic Area"
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true		
		-parent $parent
		`;
	
	intSliderGrp 
			-l "Split" 
			-minValue 1	
			-value 4
			-fmn 1
			-field true	
			-ann "This is how many cuts you want to make, not how many pieces you want to end up with."
			-cw 1 200
			splitMeshByCubicAreaSplitCountIntSliderGrp			
			;
			
		optionMenuGrp 
			-l "Axis:"
			-cal 1 "left"
			-cal 2 "left"
			-ann ("")
			splitMeshByCubicAreaDirectionalAxisOptionMenuGrp;				
				menuItem -label "X";
				menuItem -label "Y";
				menuItem -label "Z";

	button
		-label "Split Mesh By Cubic Area"
		-ann ""			
		-command "splitMeshByCubicArea(`ls -sl`)"
		splitMeshByCubicAreaButton
		;
		
	setParent..;
}

//RECREATE MESH LAYOU
//===========================================
global proc recreateMeshLayout(string $parent)
{
	string $layout = wizStandardFrameLayout($parent, "Recreate Mesh", "recreateMeshFrameLayout");	
	setParent $layout;
	
	/*
	string $debugMenuBar = addDebugWizDebuggerMenuBar($layout,{"recreateMeshByCreatingNewPolyForEveryFace","createPolyFacetCommandForEveryFace"}, {0,0},"recreateMeshDebugMenu");
	*/
	
	string $button = wizStandardActionButton("Recreate Mesh", ("recreateMeshByCreatingNewPolyForEveryFace(`ls -sl`)"), "recreateMeshButton");
	
	string $pbar = `progressBar recreateMeshProgressBar`;
	
	setParent..;
}

//CURVE PROJECTION LAYOUT
//===========================================
global proc projectCurvesLayout(string $parent)
{
	string $layout = `frameLayout
		-l "Project Curves"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
	
	//slicingMenuLayout();			
			
	directionalProjectingCurvesLayout($layout);
	
	setParent..;
}

//DIRECTIONAL PROJECTION CURVE LAYOUT
//--------------------------------------
global proc directionalProjectingCurvesLayout(string $parent)
{
	string $layout = `frameLayout
		-l "Directional Projecting Curves"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl false
		-p $parent
		`;
		
	directionalCurveProjectionMenuBarLayout($layout);
	
	optionMenuGrp 
		-l "Axis:"
		-cal 1 "left"
		-cal 2 "left"
		-ann ("")
		directionalCurveProjectionAxis;		
			menuItem -label "X";
			menuItem -label "Y";
			menuItem -label "Z";
			
	optionMenuGrp -edit -v "Y" directionalCurveProjectionAxis;
	
	intSliderGrp 
			-l "Curves" 
			-minValue 1	
			-value 10
			-fmn 1
			-fmx 99999999
			-field true	
			-ann "This is how many curves you want to project."
			-cw 1 200
			directionalCurveProjectionCount			
			;
			
	checkBox
			-l "Automatic Samples" 
			-v 0 
			directionalCurveAutomaticSamplesOption
			;
			
	intSliderGrp 
			-l "Curve Samples" 
			-minValue 1	
			-value 50
			-fmn 1
			-fmx 99999999
			-field true	
			-ann "This is the precision of how well the curves fit to the object."
			-cw 1 200
			directionalCurveSamples			
			;			
			
	checkBox
			-l "Project To Edges Only" 
			-v 0 
			directionalCurveProjectionEdgesOnlyOption
			;
	/*		
	checkBox
		-l "Loft" 
		-v 0 
		directionalCurveProjectionLoftOption
		;
	*/	
	checkBox
		-l "Keep Curves" 
		-v 0 
		directionalCurveProjectionKeepCurvesOption
		;
		
	button
		-label "Create Curves and Project"
		-ann ""
		-command "projectCurvesOnObjectInDirection(`ls -sl`)"
		projectCurvesOnObjectInDirection
		;
			
	setParent..;
}

global proc directionalCurveProjectionMenuBarLayout(string $parent)
{
	string $menuBarLayout = `menuBarLayout -p $parent directionalCurveProjectionMenuBarLayout`;
	intersectCurvesMenu();
}

global proc polyEdgeToCurveLayout(string $parent)
{
	string $layout = `frameLayout
		-l "Edge To Curve"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
			
	string $omg = `optionMenuGrp
		-l "Degree:"
		-cal 1 "left"
		-cal 2 "left"
		polyEdgeToCurveDegreeOptionMenuGrp
		`;
		menuItem -label "1";
		menuItem -label "2";
		menuItem -label "3";
		menuItem -label "5";
		menuItem -label "7";
		
	wizCheckBox(
		"-l Pickwalk Edges "
		+"-ann Pickwalks And Selects Edges "
		+"-v 0 "
		+"-n wiz_edgeToCurvePickwalkEnabled_checkBox"
		);
				
	wizIntFieldGrp(
		"-l Pickwalk Every Nth Edge "
		+"-ann Skip Pickwalk Steps When Builing Curves If You Dont Walk All Edges Turned Into Curves "
		+"-v 2 "
		+"-n wiz_polyEdgePickwalkNthEdge_intFieldGrp"
		);
		
	wizIntFieldGrp(
		"-l Total Pickwalk Steps "
		+"-v 20 "
		+"-n wiz_totalPickwalSteps_intFieldGrp"
		);	
		
	string $menuItemLabels[] = { "left", "up" };
	string $omg = wizOptionMenuGrpMenuItems("Pickwalk Direction", "wiz_polyEdgePickwalkDirection_optionMenuGrp", $menuItemLabels);
	string $val = `optionMenuGrp -q -v wiz_polyEdgePickwalkDirection_optionMenuGrp`;
	
		
	button 
		-l "Create Curve From Edge"
		-c ("wizEdgeToCurve(\"-wiz\");")
		;
		
	button 
		-l "Create Curve From Each Edge"
		-c ("wizEdgeToCurve(\"-ee -wiz\");")
		;
	
	optionMenuGrp -e -sl 1 $omg; 

}


//@ CONVERT POLY VERTEX COLORS TO TEXTURE LAYOUT
//====================================================================
global proc convertPolyVertexColorsToTextureLayout( string $parent )
{
	string $layout = `frameLayout
		-l "Convert Poly Vertex Colors To Texture"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;

	string $sizeIFG = `intFieldGrp
		-nf 2
		-l "Size"
		-v1 512
		-v2 512
		-cal 1 "left"
		convertPolyVertexColorsSize_intFieldGrp
		`;

	
	string $bc = (
	"string $newFile = wizGetAnyFile();"+"\n"
	+"textFieldButtonGrp -e -tx $newFile convertPolyVertexColorsExportFile_textFieldButtonGrp;"+"\n"
	);
	
	string $tfbg = `textFieldButtonGrp
		-l "Export File"
		-cal 1 "left"
		-bl "Select"
		-bc $bc
		convertPolyVertexColorsExportFile_textFieldButtonGrp
		`;
		
	string $exportCommand = (
	"int $size[] = `intFieldGrp -q -v convertPolyVertexColorsSize_intFieldGrp`;"+"\n"
	+"string $exFile = `textFieldButtonGrp -q -tx convertPolyVertexColorsExportFile_textFieldButtonGrp`;"+"\n"
	+"convertVertexColorsToTextureMap((\"-fn \" + $exFile + \" -fsx \" + $size[0] + \" -fsy \" + $size[1]));"
	); 
	
	button
		-l "Export"
		-c $exportCommand
		;
		
}


global proc wizPolyPiecesLayout(string $parent)
{
	string $layout = `frameLayout
		-l "Poly Pieces"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10				
		-cll true
		-cl true
		-p $parent
		`;
		
	wizFloatFieldGrp(
		"-l Offset "
		+"-ann Offsets The Chipoff Distance Leaving Distance Between Face Pieces "
		+"-v 0.0 "
		+"-n wiz_polyPiecesOffset_floatFieldGrp"
		);	
			
	wizCheckBox(
		"-l Extrude "
		+"-ann Extrudes Each Piece "
		+"-v 1 "
		+"-n wiz_polyPiecesExtrude_checkBox"
		);
		
	wizFloatFieldGrp(
		"-l Extrude Distance "
		+"-ann Extrudes Each Piece By Distance "
		+"-v 0.5 "
		+"-n wiz_polyPiecesExtrudeDistance_floatFieldGrp"
		);

	button 
		-l "Create Poly Pieces"
		-c ("wizPolyPieces(\"-wiz -sl\");")
		;
	
}


//PROCESS VUE TERRAIN TILE OPTIONS
//-----------------------------------------------------------------
global proc vueTerrainTileProcessingLayout( string $parent )
{
	
	string $selTileCommand = (
	"string $sel[] = `ls -sl`;"+"\n"
	+"if (`size $sel` == 0){"+"\n"
	+"	select -r `listTransforms \"-type mesh\"`;"+"\n"
	+"	$sel = `ls -sl`;"+"\n"
	+"}"+"\n"
	+"string $tile = $sel[0];"+"\n"
	);
	
	
	//string $layout = wizFrameLayout($parent, "Vue Terrain Tiles", "vueTerrainTileProcessingFrameLayout");
	//string $layout = wizFrameLayout("-l Vue Terrain Tiles -p " + $parent + " -n vueTerrainTileProcessingFrameLayout");
	
	string $layout = `frameLayout
		-l "Vue Terrain Tiles"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		-cll true
		-cl true
		-p $parent
		vueTerrainTileProcessingFrameLayout
		`;
		
	string $saveAs = wizOptionMenuGrp("Save Tile As","processVueTerrainTilesSaveAsOptionMenuGrp");
		menuItem -label "mb";
		menuItem -label "ma";		
		menuItem -label "obj";
		
	optionMenuGrp -edit -sl 1 $saveAs;
	
	/*
	string $max = `floatSliderGrp 
		-l "Max Angle"
		-ann "Lower Res Meshes - Set To 87\nHigher Res Meshes - Set To 89" 
		-f true
		-cal 1 "left"
		-cw 1 80		
		-adj 2
		-v 88.0000
		-min 1
		-max 180				
		-pre 4
		processVueTerrainTilesMaxAngleFloatSliderGrp
		`;
	*/
	
	text
		-l "Step 1: Delete Extra Sides Of Tiles"
		-al "left"
		;
	string $max = `floatSliderGrp 
		-l "Edge Cleanup Tolerance Max"
		-ann "This will find poly faces at this distance from bounding box edge and delete.\nUse higher values for lower resolution tiles. And Lower values for higher resolution tiles." 
		-f true
		-cal 1 "left"
		-cw 1 120		
		-adj 2
		-v 0.01
		-min 0.0001				
		-pre 4
		processVueTerrainTilesMaxAngleFloatSliderGrp
		`;
		
	string $normalAngle = `floatSliderGrp 
		-l "Normal Angle"
		-f true
		-ann "This is the normal smoothing angle to apply to faces"
		-cal 1 "left"
		-cw 1 80		
		-adj 2
		-v 80
		-min 1
		-max 180				
		-pre 0
		processVueTerrainTilesNormalAngleFloatSliderGrp
		`;
		
	/*	
	checkBox 
		-l "Quick Clean Up" 
		-v true 
		-ann "NOT IN USE!"
		processVueTerrainTilesQuickCleanUpCheckBox
		;
	*/
	
	button
		-l "Prep Selected Terrain Object"
		-c ("prepVueTerrainTiles(`ls -sl`);")
		;
        
	button
		-l "Remove Extra Sides From Vue Terrain Mesh Objects -OLD"
		-c ("removeExtraSidesFromVueTerrainMeshObjects(`ls -sl`);")
		;
	
	/*
	checkBox 
		-l "Reference Files After Processing" 
		-v true 
		processVueTerrainTilesReferenceAfterProcessingCheckBox
		;
	*/	
	
	text
		-l "Step 2: Bridge Edges Of Tiles"
		-al "left"
		;
		
	string $max = `floatSliderGrp 
		-l "Edge Selection Size"
		-ann "This will find poly edges at this distance from bounding box edge and delete.\nUse higher values for lower resolution tiles. And Lower values for higher resolution tiles." 
		-f true
		-cal 1 "left"
		-cw 1 120		
		-adj 2
		-v 0.01
		-min 0.0001				
		-pre 4
		processVueTerrainTilesEdgeSelectionSizeFloatSliderGrp
		`;
	
	button
		-l "Bridge Terrain Tile Edges"
		-c ("bridgeSelectedTerrainTileEdges(`ls -sl`);")
		;
		
	checkBox 
		-l "Remove Extra Sides" 
		-v true 
		processVueTerrainTilesRemoveExtraSidesCheckBox
		;
		
	checkBox 
		-l "Remove Bottom Side Only" 
		-v false 
		processVueTerrainTilesRemoveBottomSideOnlyCheckBox
		;
	
	checkBox 
		-l "Create UVs" 
		-v true 
		processVueTerrainTilesCreateUVsCheckBox
		;
		
	string $uvType = wizOptionMenuGrp("Generate UVs","processVueTerrainTilesUVsOptionMenuGrp");
		menuItem -label "none";
		menuItem -label "planar";
		menuItem -label "auto";
		
	//Select planar by default	
	optionMenuGrp -e -sl 2 $uvType;
		
	
	checkBox 
		-l "Assign Default Shader" 
		-v true 
		processVueTerrainTilesAssignDefaultShaderCheckBox
		;
		
	checkBox 
		-l "Reduce Poly" 
		-v false 
		processVueTerrainTilesReducePolyCheckBox
		;
	
	button
		-l "Reduce Polys"
		-c ($selTileCommand + "polyReduceVueTerrainTile($tile);")
		;
		
	string $reductionPercent = `intSliderGrp 
		-l "Reduction Percent"
		-ann "" 
		-f true
		-cal 1 "left"
		-cw 1 120		
		-adj 2
		-v 80
		-min 0
		-max 99
		processVueTerrainTilesPolyReductionPercentIntSliderGrp
		`;
		
	button
		-l "Process Selected Terrain Tile OBJ Files"
		-c ("processSelectedTerrainTileObjFiles();")
		;
	
	button
		-l "Process All Terrain OBJ Files In Directory"
		-c ("string $dir = getDirectoryFileDialog();processAllTerrainTilesInDirectory($dir);")
		;	
	
	button
		-l "Rename Terrain Tiles After File Names"
		-c ("renameTerrainTilesAfterFileNames();")
		;
	
	setParent..;
}

//MENUS
//==============================================================================

//POLY WIZ MENUBAR LAYOUT
//====================================
global proc polyWizMenuBarLayout()
{		
	string $menuBarLayout = `menuBarLayout polyWizMenuBarLayout`;
	
	//Mesh
	menu -label "Mesh" -to true;	
		menuItem -l "Fix Common Polygon Problems" -c ("fixCommonPolygonProblemsOnSelected(`ls -sl`);");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"fixCommonPolygonProblemsOptions\");");
		menuItem -sm true -l "Recreate Mesh" -to true;
			menuItem -l "Recreate Mesh Using Poly Create Facet" -c ("recreateMeshByCreatingNewPolyForEveryFace(`ls -sl`)");	
		setParent -menu..;
		menuItem -l "Delete Extra Mesh Nodes" -c ("deleteExtraMeshNodesOnSelectedObjects(`ls -sl`);");		
		
		menuItem -l "Reduce All" -c ("wizPolyReduceAll();");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"polyReduceOptions\");");
		
        menuItem -l "Make Low Res Copy" -c ("makeLowResNoHistoryCopyOfSelected(`ls -sl`);");
        menuItem -l "Make Low Res Copy With LOD Group" -c ("makeLowResCopyLODGroup(`ls -sl`);");
        
		menuItem -l "Add Wiz Poly Reduce Tag" -c ("addWizTag(\"-polyReduce\");");
        
		menuItem -l "Add Wiz Low Res Copy Tag" -c ("addWizTag(\"-lowResCopy\");");
		
		menuItem -l "Poly Separate All Faces" -c ("wizPolySeparateAllFaces(\"-sl\");");
		
		menuItem -l "Create Self Intersection Highlighter" -c ("wizCreateSelfIntersectionHelper();");
		setParent -menu..;
		
		meshDetailsMenuItems();
		
	//Edit Mesh
	menu -label "Edit Mesh" -to true;
		menuItem -l "Crease Edges" -c ("creaseEdgesOnSelectedObjects(`ls -sl`);");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"creaseEdgesOptionsMenu\");");
			
		menuItem -sm true -l "Turbulence" -to true;
			menuItem -l "Generate Turbulence" -c "polyTurbulence()";
			menuItem -l "Smooth All Selected Poly Meshes" -c "smoothAllSelectedPoly(`ls -sl`)";
			menuItem -l "Reduce All Selected Poly Meshes" -c "reduceAllSelectedPoly(`ls -sl`)";
		setParent -menu..;
		
		menuItem -l "Terrain Shrink Wrap" -c ("terrainShrinkWrapWindow();");
		
		menuItem -l "Toggle Boolean Source" -c ("wizToggleBoolBaseVisibility();");
		
		
	//Components	
	menu -l "Components" -to true;
		menuItem -sm true -l "Vertices" -to true;
			menuItem -l "Maximize Merge Vertices" -c ("maximizeMergeVertices(`ls -sl`)");
				menuItem -ob true -c ("openCurrentOptionsLayout(\"maximizeMergeVerticesOptionsMenu\");");
			menuItem -l "Delete Extra Vertices" -c ("deleteExtraVerticesOnSelected(`ls -sl`);");
			menuItem -l "Delete Edges And Vertices" -c ("deleteSelectedEdgesAndVertices(`ls -sl`);");
			
			
			setParent -menu..;
		menuItem -l "Fix High Valence Vertices" -c ("fixHighValenceVertices(`ls -sl`);");
		menuItem -l "Align Camera To Closest Poly Face" -c ("normalAlignCameraToClosestPointOnPoly(\"-sl\");");
		
	//Bounding Box	
	menu -l "Bounding Box" -to true;
		menuItem -l "Wiz GeomToBBox" -c ("string $sel[] = `ls -sl`; string $obj = $sel[0]; wizGeomToBBox($obj)");
		menuItem -l "Create Bounding Box Cube" -c ("string $sel[] = `ls -sl`; string $obj = $sel[0]; createBBoxCube($obj)");
		menuItem -l "Create Rotation Frozen Bounding Box Cube" -c ("string $sel[] = `ls -sl`; string $obj = $sel[0]; createRotationFrozenBBoxCube($obj)");
	
	menu -l "Curves" -to true;
		
		menuItem -sm true -l "Mirror" -to true;
			mirrorCurvesMenuItems();
		setParent -menu..;
		
		menuItem -sm true -l "Rebuild" -to true;
			rebuildCurvesMenuItems();
		setParent -menu..;
		
		menuItem -sm true -l "Bevel" -to true;
			bevelCurvesMenuItems();
		setParent -menu..;
		
		menuItem -sm true -l "Extrude" -to true;
			menuItem -l "Extrude Length" -c ("wizExtrudeLength();");		
		
		setParent -menu..;
		
		menuItem -sm true -l "Curve Projector" -to true;
			menuItem -l "Surface Normal Curve Projector" -c ("createCurveProjector(\"-sl -typ surfaceNormal\");");
			menuItem -l "Aim Curve Projector" -c ("createCurveProjector(\"-sl -typ aim\");");
		setParent -menu..;
		
	menu -l "Terrain" -to true;	
		menuItem -l "Process Selectd Vue Terrain Tiles" -c ("processSelectedTerrainTileObjFiles();");		
			menuItem -ob true -c ("openCurrentOptionsLayout(\"processVueTerrainTilesOptions\");");
		menuItem -l "Process All Vue Terrain Tiles In Directory" -c ("string $dir = getDirectoryFileDialog();processAllTerrainTilesInDirectory($dir);");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"processVueTerrainTilesOptions\");");
		menuItem -l "Remove Extra Sides From Vue Terrain Mesh Objects" -c ("removeExtraSidesFromVueTerrainMeshObjects(`ls -sl`);");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"processVueTerrainTilesOptions\");");
		menuItem -l "Terrain Tile Blanket" -c ("wizTerrainTileBlanket(\"-sl -xt 10 -yt 10 -xs 10 -ys 10 -n terrainTile\");");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"terrainTileBlanketOptions\");");
			
	setParent -menu..;	
	
}

//MESH DETAILS MENU ITEMS
//-----------------------------------
global proc meshDetailsMenuItems()
{
	string $anglesOfFaceEdgesCommand = ("string $sel[] = `ls -fl -sl`;"
	+"menuItem -e -cb true GetAnglesOfFaceEdgesDebugMenuItem;"
	+"getAnglesOfFaceEdges($sel[0]);");
	
	string $anglesBetweenTwoEdgesCommand = ("string $sel[] = `ls -fl -sl`;"
	+"menuItem -e -cb true GetAngleBetweenTwoEdgesDebugMenuItem;"
	+"getAngleBetweenTwoEdges($sel[0], $sel[1]);"
	+"openDebugWiz();");
	
	string $faceBBoxSizeCommand = ("string $sel[] = `ls -fl -sl`;"
	+"menuItem -e -cb true GetPolyFaceBoundingBoxSizeDebugMenuItem;"
	+"getPolyFaceBoundingBoxSize($sel[0]);"
	+"openDebugWiz();");
	
	string $faceBBoxMinCommand = ("string $sel[] = `ls -fl -sl`;"
	+"menuItem -e -cb true GetPolyFaceBoundingBoxMinDebugMenuItem;"
	+"getPolyFaceBoundingBoxMin($sel[0]);"
	+"openDebugWiz();");
	
	string $faceCenterCommand = ("string $sel[] = `ls -fl -sl`;"
	+"menuItem -e -cb true GetFaceCenterDebugMenuItem;"
	+"getFaceCenter($sel[0]);"
	+"openDebugWiz();");
	
	//Mesh Details	
	menuItem -sm true -l "Mesh Details";
		menuItem -l "Get Vertex Per Face Count" -c ("getVertexPerFaceCount(`ls -sl`)");
		menuItem -l "Get Face Normals" -c ("getFaceNormals(`ls -sl`)");
		menuItem -l "Get Face Center" -c $faceCenterCommand;
		menuItem -l "Get Angles Of Face Edges" -c $anglesOfFaceEdgesCommand -ecr true ;
		menuItem -l "Get Angle Between Two Edges" -c $anglesBetweenTwoEdgesCommand -ecr true;
		menuItem -l "Get Face Bounding Box Size" -c $faceBBoxSizeCommand -ecr true;
		menuItem -l "Get Face Bounding Box Min" -c $faceBBoxMinCommand -ecr true;
		
	setParent -menu..;	
}

//@ TERRAIN TILE BLANKET OPTIONS
//====================================================================
global proc terrainTileBlanketLayout( string $parent )
{
	string $layout = `frameLayout
		-l "Terrain Tile Blanket"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		-cll true
		-cl true
		-p $parent
		`;
    
	wizIntFieldGrp("-l Divisions Squared -nf 1 -v 10 -n terrainTileBlanketLayout_divisions_intFieldGrp");
	
	wizIntFieldGrp("-l Subdivisions -nf 1 -v 100 -n terrainTileBlanketLayout_subdivisions_intFieldGrp");
	
	wizCheckBox(
	"-l Smooth "
	+"-v 0 "
	+"-n terrainTileBlanketLayout_smooth_checkBox"
	);
	
	wizIntFieldGrp("-l Smooth Subdivisions -nf 1 -v 1 -n terrainTileBlanketLayout_smoothSubdivisions_intFieldGrp");
	
	string $tfbg = wizTextFieldGrp(
		"-l Name "
		+"-n terrainTileBlanketLayout_name_textFieldButtonGrp");
		
	string $com = ("int $tileDiv = `intFieldGrp -q -v1 terrainTileBlanketLayout_divisions_intFieldGrp`;"+"\n"
	+"int $subDiv = `intFieldGrp -q -v1 terrainTileBlanketLayout_subdivisions_intFieldGrp`;"+"\n"
	+"string $tileName = `textFieldGrp -q -tx terrainTileBlanketLayout_name_textFieldButtonGrp`;"+"\n"
	+"wizTerrainTileBlanket(\"-wiz -sl -xt \" + $tileDiv + \" -yt \" + $tileDiv + \" -xs \" + $subDiv + \" -ys \" + $subDiv + \" -name \" + $tileName);"+"\n"
	);
	
	wizCheckBox(
		"-l Tile UVs "
		+"-v 1 "
		+"-n terrainTileBlanket_tileUVs_checkBox"
		);
		
	button
		-l "Create Terrain Tile Blanket"
		-c $com
		;
		
	setParent..;
}

//POLY WIZ FUNCTIONS
//==============================================================================
//GET COMPONENT ID
//==========================================
global proc int getComponentId(string $component)
{
	//get the pattern [***]
	string $suffix=match("\\[(.)+", $component);
	//rip out the "[" and "]"
	int $id=match("[0-9]+", $suffix);
	
	return $id;
}


//@ WIZ EDGE TO CURVE
//====================================================================
/*****************************************************************//**
	Each continuous edge selected is converted into a single curve.
	<hr>
	<b>Synopsis</b><br>
	createCurveFromPolyEdge [string $e[]] <br>
	Each continuous edge is converted into a single curve.
	
	<b>Return value</b><br>
	string[] the curves created.
	
	<b>Flags</b><br>

	<hr>
	<b>Examples</b><br>
	<code>
	string $curves[] = wizEdgeToCurve(-wiz);
	
	</code>
*********************************************************************/
global proc wizEdgeToCurve( string $flags )
{
	string $sel[];
	int $eachEdge;
	int $pickwalk;
	int $pickwalkSteps;
	int $everyNthEdge;
	string $pickwalkDir = "left";
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-wiz" :
			$sel = `ls -sl`;
			$pickwalk = `checkBox -q -v wiz_edgeToCurvePickwalkEnabled_checkBox`;
			$everyNthEdge = `intFieldGrp -q -v1 wiz_polyEdgePickwalkNthEdge_intFieldGrp`;
			$pickwalkSteps = `intFieldGrp -q -v1 wiz_totalPickwalSteps_intFieldGrp`;
			$pickwalkDir = `optionMenuGrp -q -v wiz_polyEdgePickwalkDirection_optionMenuGrp`;
			break ;
			
			case "-ee" : case "-eachEdge" :
			$eachEdge = 1;
			break ;
		}
		
	}
	
	if ($pickwalk){
		for ($i=0;$i<$pickwalkSteps;$i++){
					
			if ($eachEdge){
				createCurveFromEachPolyEdge(`ls -sl`);	
			} else {
				createCurveFromPolyEdge(`ls -sl`);
			}
			
			for ($p=0;$p<$everyNthEdge;$p++){
				pickWalk -d $pickwalkDir -type edgeloop;
			}
		}	
		
	} else {
		if ($eachEdge){
			createCurveFromEachPolyEdge(`ls -sl`);	
		} else {
			createCurveFromPolyEdge(`ls -sl`);
		}
	}
	
	
}

//@ CREATE CURVE FROM POLY EDGE
//====================================================================
/*****************************************************************//**
	Each continuous edge selected is converted into a single curve.
	<hr>
	<b>Synopsis</b><br>
	createCurveFromPolyEdge [string $e[]] <br>
	Each continuous edge is converted into a single curve.
	
	<b>Return value</b><br>
	string[] the curves created.
	
	<b>Flags</b><br>

	<hr>
	<b>Examples</b><br>
	<code>
	string $curves[] = createCurveFromPolyEdge(`ls -sl`);
	
	</code>
*********************************************************************/
global proc string[] createCurveFromPolyEdge( string $e[] )
{
	wizlog ("[@] createCurveFromPolyEdge");
	
	select -r $e;
	
	int $degree = int(`optionMenuGrp -q -v polyEdgeToCurveDegreeOptionMenuGrp`);
	
	string $resultCurveGrp[];
	
	string $edges[]=`filterExpand -ex 1 -sm 32`;
	
	if(size($edges)<1){
		return $resultCurveGrp;
	}
	
	string $obj[]= `ls -sl -o`;
	
	//Get total edge number
	int $edgeNum[]= `polyEvaluate -edge $obj[0]`;
	
	//To trace which edges are selected
	int $isSelect[];
	
	//To trace which edges have been processed in the loop later.
	int $isProcessed[];
	
	//Set all to 0 (not processed, and not selected)
	for($i=0;$i<$edgeNum[0];$i++){
		$isSelect[size($isSelect)] = 0;
		$isProcessed[size($isProcessed)] = 0;
	}
	
	//Set the selected edges to 1
	for($edge in $edges){    
		$currId = getComponentId($edge);
		$isSelect[$currId] = 1;
	}
	
	//This is the final groups of connected edges
	string $edgeGroups[];
	
	//Start grouping edges
	for ($iter=0;$iter<size($edges);$iter++){
		int $edgeId = getComponentId($edges[$iter]);
		
		if($isProcessed[$edgeId])
		    continue;
		
		$isProcessed[$edgeId] = 1;
		
		string $currEdge = $edges[$iter];
		
		//Create a stack of connected edges
		string $edgeStack[] = {$currEdge};
		int $stackSize = 1;	
		
		/*
		this is the group string. since it's not convenient to create 2 dimension array in mel, instead
		we concatenate each of the edge, and divide them by ";" (to be tokenized later)
		*/
		
		string $currEdgeList = "";	
		//Start popping stack===//
		while($stackSize>0){
		    //Get the last item
		    $currEdge = $edgeStack[$stackSize-1];
		    $edgeStack[$stackSize-1] = "";
		    $stackSize -= 1 ;
		    
		    //Concatenate the edgeList string
		    $currEdgeList = $currEdgeList + $currEdge + ";";
		    
		    //Get neighbor edges
		    select -r $currEdge;
		    PolySelectTraverse 1;
		    select -d $currEdge;
		    string $nEdges[] =`filterExpand -ex 1 -sm 32`;
		
		    /*
		    the neighbor edges must fulfill two criteria before being put into the stack.
		    1. it is originally selected by user
		    2. it has not been traversed before.
		    */
		    
		    for($nEdge in $nEdges){
			int $nId = getComponentId($nEdge);
			if($isProcessed[$nId])
			    continue; 
			    
			if(!$isSelect[$nId])
			    continue;
			    
			$isProcessed[$nId] = 1;
			$edgeStack[$stackSize] = $nEdge;
			$stackSize+=1;
		    }
		}
		
		//Out the edge list into final group
		$edgeGroups[size($edgeGroups)] = $currEdgeList;
	
	}
	
	//Create a curve from each group
	for($edgeGroup in $edgeGroups){
		string $tokens[];
		int $numTokens = tokenize($edgeGroup,";",$tokens);
		select -r $tokens;
		string $newCurve[] = `polyToCurve -form 2 -degree $degree`;
		$resultCurveGrp[size($resultCurveGrp)] = $newCurve[0];
	
	}
	
	//And select them
	if(size($resultCurveGrp)>0){
		select -r $resultCurveGrp;
	}
	
	//And return them.
	return $resultCurveGrp;    
}


//@ CREATE CURVE FROM EACH POLY EDGE
//====================================================================
/*****************************************************************//**
	Creates a curve for every edge that is selected.
	<hr>
	<b>Synopsis</b><br>
	createCurveFromEachPolyEdge [string $e[]] <br>
	Each edge is passed individually to createCurveFromPolyEdge.
	This will produce a lot of curves.
	
	<b>Return value</b><br>
	string[] all the curves created
	
	<b>Flags</b><br>
	
	<hr>
	<b>Examples</b><br>
	<code>
	string $curves[] = createCurveFromEachPolyEdge(`ls -sl`);
	
	</code>
*********************************************************************/
global proc string [] createCurveFromEachPolyEdge( string $e[] )
{
	string $curves[];
	string $edges[] = `ls -fl $e`;
	for ($i=0;$i<`size $edges`;$i++){
		select -r $edges[$i];
		string $newCurve[] = createCurveFromPolyEdge({$edges[$i]});
		$curves[$i] = $newCurve[0];
	}
	return $curves;
}

//FACE POSITION
//-------------------------------------------------
global proc float[] getPolyFaceCenterPosition(string $face, string $obj)
{
	if($face == ""){
		debugML5(("Error in getPolyFaceCenterPosition!" + "\n"));
	}
	
	string $verts[] = `polyInfo -fv $face`;
	string $vert[] = stringToStringArray($verts[0],"FACE :");
	int $numVerts = (`size ($vert)`-2);
	float $px=0;
	float $py=0;
	float $pz=0;
	for($i=1;$i<($numVerts+1);$i++){
		string $vertID = ($obj+".vtx["+$vert[$i]+"]");
		float $pos[] = `xform -q -ws -t $vertID`;
		$px += $pos[0];
		$py += $pos[1];
		$pz += $pos[2];
	}
	float $center[] = {($px/$numVerts),($py/$numVerts),($pz/$numVerts)};
	
	return $center;	
}

//GET FACE CENTER
global proc float[] getFaceCenter(string $f)
{
	string $dbl = "-dmi GetFaceCenterDebugMenuItem -t Face Center"; string $dbm = "add"; int $dbc = 1;
	string $obj = getObjectFromComponent({$f});
	string $verts[] = `polyInfo -fv $f`;
	string $vert[] = stringToStringArray($verts[0],"FACE :");
	int $numVerts = (`size ($vert)`-2);
	float $px=0;
	float $py=0;
	float $pz=0;
	for($i=1;$i<($numVerts+1);$i++){
		string $vertID = ($obj+".vtx["+$vert[$i]+"]");
		float $pos[] = `xform -q -ws -t $vertID`;
		$px += $pos[0];
		$py += $pos[1];
		$pz += $pos[2];
	}
	float $center[] = {($px/$numVerts),($py/$numVerts),($pz/$numVerts)};
	
	if(`menuItem -q -cb GetFaceCenterDebugMenuItem`){
		string $n = removeIllegalCharacters($f);
		spaceLocator -n ($n + "FaceCenter") -p $center[0] $center[1] $center[2];
		
	}
	return $center;		
}

//SINGLE POLY PLANE
//===============================
global proc createSinglePolyPlane()
{
	global float $WIZ_singlePolyPlaneSize;
	float $planeSize = `floatSliderButtonGrp -q -v createSinglePolyPlane_floatSliderButtonGrp`;
	polyPlane -w $planeSize -h $planeSize -sx 1 -sh 1 -cuv 2 ;
	$WIZ_singlePolyPlaneSize = $planeSize;
}

//POLY TURBULENCE
//============================================
global proc polyTurbulence()
{
	string $selected[] = `ls -sl`;
	int $howMany[] = `polyEvaluate -vertex`;
	float $turb = `floatFieldGrp -q -v1 polyTurbulenceAmount_floatFieldGrp`;
	int $ifX = `checkBoxGrp -q -v1 polyTurbulenceAxises_checkBoxGrp`;
	int $ifY = `checkBoxGrp -q -v2 polyTurbulenceAxises_checkBoxGrp`;
	int $ifZ = `checkBoxGrp -q -v3 polyTurbulenceAxises_checkBoxGrp`;
	
	float $moveBy;
	
	select -cl;
	
	for($i=0;$i<$howMany[0];$i++){	
		select -r ($selected[0]+".vtx["+ $i +"]");	
		if($ifX){	
			$moveBy = rand($turb);	
			move -r $moveBy 0 0;		
		}		
		
		if($ifY){	
			$moveBy = rand($turb);
			move -r  0 $moveBy 0;
			
		}	
		if($ifZ){	
			$moveBy = rand($turb);
			move -r  0 0 $moveBy;
			
		}
	}

}

//REDUCE ALL SELECTED POLY
//==================================
global proc reduceAllSelectedPoly(string $sel[])
{
	for($i=0;$i<`size $sel`;$i++){
		polyReduce -percentage 50 -uvWeights 0 -colorWeights 0 -keepQuadsWeight 1 -keepBorder 1 -keepMapBorder 1 -keepOriginalVertices 0 -keepHardEdge 1 -compactness 0.5 -triangulate 0 -replaceOriginal 1 -cachingReduce 1 -ch 1 $sel[$i];
	}
}

//SMOOTH ALL SELECTED POLY
//==================================
global proc smoothAllSelectedPoly(string $sel[])
{
	for($i=0;$i<`size $sel`;$i++){
		polySmooth  -mth 0 -dv 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $sel[$i];
	}
}


//PROJECTING CURVES
//=============================
global proc projectCurvesOnObjectInDirection(string $sel[])
{
	//Draw a curve the height of the bbox or whatever axis we choose
	//Copy that curve how ever many times we want to
	//Do the projection onto the object
	//Loft away
	global int $WIZ_dm;
	
	int $curveCount = `intSliderGrp -q -v directionalCurveProjectionCount`;
	int $curveSamples = `intSliderGrp -q -v directionalCurveSamples`;
	int $autoSamples = `checkBox -q -v directionalCurveAutomaticSamplesOption`;
	int $edgeOnly = `checkBox -q -v directionalCurveProjectionEdgesOnlyOption`;
	int $keepCurves = `checkBox -q -v directionalCurveProjectionKeepCurvesOption`;
	string $axis = `optionMenuGrp -q -v directionalCurveProjectionAxis`;
	
	float $cc = $curveCount; //Convert int to float
	select -cl;
	for($i=0;$i<`size $sel`;$i++){
		float $bboxSize[] = `getAttr ($sel[$i] + ".boundingBoxSize")`;
		float $bboxMin[] = `getAttr ($sel[$i] + ".boundingBoxMin")`;
		float $bboxMax[] = `getAttr ($sel[$i] + ".boundingBoxMax")`;
		float $center[] = `getAttr ($sel[$i] + ".center")`;
		float $cS[]; //Curve start
		float $cE[]; //Curve end
		string $curve; 
		float $cMove;
		string $dir;
		if($axis == "X"){
			$cS = {$bboxMin[0],$bboxMin[1],$bboxMin[2]};
			$cE = {$bboxMax[0],$bboxMin[1],$bboxMin[2]};
			$curve = `curve -d 1 -p $cS[0] $cS[1] $cS[2] -p $cE[0] $cE[1] $cE[2]`;
			$cMove = $bboxSize[0] / $curveCount;
			$dir = "-direction 0 0 1";
		} else if($axis == "Y"){
			$cS = {$bboxMin[0],$bboxMin[1],$bboxMin[2]};
			$cE = {$bboxMin[0],$bboxMax[1],$bboxMin[2]};
			$curve = `curve -d 1 -p $cS[0] $cS[1] $cS[2] -p $cE[0] $cE[1] $cE[2]`;
			$cMove = $bboxSize[0] / $curveCount;
			$dir = "-direction 0 0 1";
		} else if($axis == "Z"){
			/*
			$cS = {$bboxMin[0],$bboxMin[1],$bboxMin[2]};
			$cE = {$bboxMin[0],$bboxMin[1],$bboxMax[2]};
			$curve = `curve -d 1 -p $cS[0] $cS[1] $cS[2] -p $cE[0] $cE[1] $cE[2]`;
			$cMove = $bboxSize[0] / $curveCount;
			$dir = "-direction 0 0 1";
			*/
			$cS = {$bboxMin[0],$bboxMin[1],$bboxMin[2]};
			$cE = {$bboxMax[0],$bboxMin[1],$bboxMin[2]};
			$curve = `curve -d 1 -p $cS[0] $cS[1] $cS[2] -p $cE[0] $cE[1] $cE[2]`;
			$cMove = $bboxSize[0] / $curveCount;
			$dir = "-direction 0 0 1";
		} 
		xform -cp $curve;
		xform -s 10 10 10 $curve;
		move -r 0 0 -10 $curve;
		makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $curve;
		//Move the curve over a little bit and scale the size of our "box" down so we catch the very ends of the object
		float $totCMove = $cMove;
		$cMove = $cMove * 0.999;
		float $diffCMove = $totCMove - $cMove;
		if($axis == "X"){move -r 0 $diffCMove 0 $curve ;}
		else if($axis == "Y"){move -r $diffCMove 0 0 $curve ;}
		else if($axis == "Z"){move -r 0 $diffCMove 0 $curve ;}
		//string $projectedCurves[];	
		if($WIZ_dm){print("CurveMoveAmount: " + $cMove +  "\n");}
		global string $WIZ_tempObjects[];
		string $allCurves[];
		for($s=0;$s<($cc + 1);$s++){			
			string $projectCommand = ("string $projCurve[] = `polyProjectCurve -ch true " + $dir
			+ " -pointsOnEdges " + $edgeOnly + " -curveSamples " + $curveSamples 
			+ " -automatic " + $autoSamples + " "
			+ "\"" + $curve + "\"" + " " + "\"" + $sel[$i] + "\"" + "`;" 
			+ "global string $WIZ_tempObjects[];"
			+ "appendStringArray($WIZ_tempObjects,$projCurve, `size $projCurve`);"
			);
			eval($projectCommand);
			string $oldCurve = $curve;
			string $dup[] = `duplicate $oldCurve`;
			if($keepCurves == 0){
				delete $oldCurve;			
			} else {
				$allCurves[`size $allCurves`] = $oldCurve;
			}
			$curve = $dup[0];
			float $curvePos[] = `getAttr ($curve + ".translate")`;
			if($WIZ_dm){print("Curve: " + $curve + " Pos: " + floatArrayToString($curvePos, " ") +  "\n");}
			/*
			if($axis == "X"){setAttr ($curve + ".translate") ($curvePos[0] + $cMove) $curvePos[1] $curvePos[2];}
			else if($axis == "Y"){setAttr ($curve + ".translate") $curvePos[0] ($curvePos[1] + $cMove) $curvePos[2];}
			else if($axis == "Z"){setAttr ($curve + ".translate") $curvePos[0] $curvePos[1] ($curvePos[2] + $cMove);}
			*/
			if($axis == "X"){move -r 0 $cMove 0 $curve ;}
			else if($axis == "Y"){move -r $cMove 0 0 $curve ;}
			else if($axis == "Z"){move -r 0 $cMove 0 $curve ;}
			
		}
		
		//string $projectedCurves[] = `ls -sl`;
		string $pCurveGroup = groupSelectedObjects($WIZ_tempObjects);
		if($keepCurves == 0){		
			delete $curve;
		} else {
			$allCurves[`size $allCurves`] = $curve;
			string $oldCurvesGroup = groupSelectedObjects($allCurves);
		}
		if(`checkBox -q -v directionalCurveProjectionLoftOption` == 1){
	
		}
		//global string $nodes[];
		//string $sel[] = `ls -sl`;
		//findAllIntersections($sel, `size $sel`, 0, 0, 0, 0, 0, 0, 0, $nodes);
	}
}

//RECREATE MESH
//==============================================================================
global proc recreateMesh(string $sel[])
{
	/*
	polyCreateFacet -p 0 0 0 -p 10 0 0 -p 10 10 0 -p 0 10 0;
	polyAppend -ed 1 -p 20 0 0;
	*/
	
	printProc("recreateMesh");
	string $mesh = $sel[0];
	
	//get the info for the object
	string $polyAppend = createPolyAppendCommandForEveryFace($mesh);
	
	
	//poly append untill it's rebuilt
	eval($polyAppend);
    
}

//RECREATE MESH BY CREATING NEW POLY FOR EVERY FACE
//-----------------------------------------------------
global proc string recreateMeshByCreatingNewPolyForEveryFace(string $sel[])
{
	global int $WIZ_refreshStep;	
	//int $debug = `menuItem -q -cb RecreateMeshByCreatingNewPolyForEveryFaceDebugMenuItem`;
	
	//printProc("recreateMeshByCreatingNewPolyForEveryFace");
	//global string $WIZ_currentProgressBar;
	//$WIZ_currentProgressBar = "recreateMeshProgressBar";
	//progressBar -e -pr 0 $WIZ_currentProgressBar;
	
	string $mesh = $sel[0];
	
	//create a polyCreateFacet command for each face in the mesh
	string $polyFacet[] = createPolyFacetCommandForEveryFace($mesh);
	//progressBar -e -max (`size $polyFacet` * 2) $WIZ_currentProgressBar;
	
	//polyCreateFacet untill it's rebuilt
	
	string $f[];
	for($i=0;$i<`size $polyFacet`;$i++){
		string $newF[] = `eval($polyFacet[$i])`;
		$f[`size $f`] = $newF[0];
		if($WIZ_refreshStep){
			refreshStep();
		}
		//progressBar -e -s 1 $WIZ_currentProgressBar;
	}
	/*
	if($debug){ debugList("New Face", $f, 2, "replace");}
	*/
	
	//Unite all the new faces
	string $newMesh = polyUniteInChunks($f, 20);
	/*
	string $newMesh = $f[0];
	for($i=1;$i<`size $f`;$i++){	
		string $united[] = `polyUnite -ch 0 -mergeUVSets 1 $f[$i] $newMesh`;
		$newMesh = $united[0];
		delete -ch $newMesh;
		progressBar -e -s 1 $WIZ_currentProgressBar;
	}
	//Merge all the vertices with a ver low tolerance 
	//since the vertices that are being merged are in the same exact position
	polyMergeVertex -d 0.0001 -am 1 -ch 0 $newMesh;
	*/
	
	//Copy the transforms from the old to the new
	transferTransforms($sel[0],$newMesh);
	
	//Make a new name from the old name
	string $newName = getUniqueNumberedName($sel[0]);
	rename $newMesh $newName;
	
	//Clean up
	delete -ch $newName;
	hide $sel[0];
	changeSelectMode -object;
	//progressBar -e -pr (`size $polyFacet` * 2) $WIZ_currentProgressBar;
	
	return $newName;
}

//POLY UNITE IN CHUNKS
//-----------------------------------------------------
global proc string polyUniteInChunks(string $arr[], int $chunks)
{
	string $chunk[];
	string $process[];
	int $chunkCount = 1;
	string $processString;
	string $united;
	
	//debugList("Chunks", {("ArrSize: " + `size $arr`)}, 1, "add");
	
	for($i=0;$i<`size $arr`;$i++){	
		//debugList("Chunks", {("ChunkCount: " + $chunkCount + " Index: " + $i)}, 1, "add");
		
		$process[`size $process`] = $arr[$i];
		
		if($chunkCount == $chunks || $i == `getLastArrayIndex $arr`){
			$united = uniteSelectedPolygonMeshes($process);
			$chunk[`size $chunk`] = $united;		
			clear $process;
			$chunkCount = 1;
		} else {		
			$chunkCount++;	
		}
		
	}
	$united = uniteSelectedPolygonMeshes($chunk);
	
	return $united;
	
}

//UNITE SELECTED POLYGON MESHES
//=====================================
global proc string uniteSelectedPolygonMeshes(string $mesh[])
{
	//global string $WIZ_currentProgressBar;
	string $newMesh = $mesh[0];
	for($i=1;$i<`size $mesh`;$i++){	
		string $united[] = `polyUnite -ch 0 -mergeUVSets 1 $mesh[$i] $newMesh`;
		$newMesh = $united[0];
		delete -ch $newMesh;
		//progressBar -e -s 1 $WIZ_currentProgressBar;
	}
	polyMergeVertex -d 0.0001 -am 1 -ch 0 $newMesh;	
	return $newMesh;
}

//POLY FACET COMMANDS
//=======================================
global proc string[] createPolyFacetCommandForEveryFace(string $mesh)
{
	//int $debug = `menuItem -q -cb CreatePolyFacetCommandForEveryFaceDebugMenuItem`;
	
	//printProc("createPolyFacetCommandForEveryFace");	
	select -r $mesh;
	ConvertSelectionToFaces;
	string $f[] = `ls -fl -sl`;
	//if($debug){ debugList("Original Mesh Faces", $f, 1, "replace");}
	
	string $polyFacet[];
	string $pcf[];
	
	for($i=0;$i<`size $f`;$i++){
		$polyFacet[`size $polyFacet`] = "polyCreateFacet ";
		string $v[] = getVerticesFromFace({$f[$i]});	
		//if($debug){  debugList("Vertices", $v, 1, "add");}
		
		for($vi=0;$vi<`size $v`;$vi++){
			float $vp[] = `xform -q -t $v[$vi]`;
			string $p = createPolyAppendPositionString($vp);
			$polyFacet[`size $polyFacet`] = $p;
			
		}
		
	$polyFacet[`size $polyFacet`] = ";";
	string $polyFacetCommand = stringArrayToString($polyFacet,"");
	$pcf[`size $pcf`] = $polyFacetCommand;
	clear $polyFacet;
	
	}
	
	//if($debug){ debugList("Poly Create Facet", $pcf, 2, "replace");}
	return $pcf;	

}

//POLY APPEND COMMANDS
//==========================================
global proc string createPolyAppendCommandForEveryFace(string $mesh)
{
	printProc("createPolyAppendCommandForEveryFace");	
	select -r $mesh;
	ConvertSelectionToFaces;
	string $f[] = `ls -fl -sl`;
	debugList("Faces", $f, 1, "replace");
	
	int $vCount[] = getVertCountPerFace($f);
	string $vCountString[] = intArrayToStringArray($vCount);
	debugList("Vertex Count Per Face", $vCountString, 2, "replace");
	
	select -r $f;
	ConvertSelectionToVertices;
	string $v[] = `ls -fl -sl`;
	debugList("Vertices", $v, 3, "replace");
	select -cl;
	
	float $vPos[];
	string $polyAppend[];
	int $fCount = 1;
	int $fi;
	int $edgeCount = -1;
	$polyAppend[`size $polyAppend`] = "polyCreateFacet ";
	
	for($i=0;$i<`size $v`;$i++){
		float $vp[] = `xform -q -t $v[$i]`;
		//Create a string of positions
		string $p = createPolyAppendPositionString($vp);
		$polyAppend[`size $polyAppend`] = $p;
		
		if($vCount[$fi] == $fCount){
			//Start a new face
			if($edgeCount == 0){
				$polyAppend[`size $polyAppend`] = "; \n" + "polyAppend " + "-ed " + $edgeCount;
			} else if($edgeCount > 0){
				$polyAppend[`size $polyAppend`] = "\n" + "-ed " + $edgeCount;
			} else {
				$polyAppend[`size $polyAppend`] = " ; ";
			}
			$edgeCount++;
		}
		
	}
	$polyAppend[`size $polyAppend`] = " ; ";
	debugList("Poly Append", $polyAppend, 4, "replace");
	string $polyAppendCommand = stringArrayToString($polyAppend,"");
	return $polyAppendCommand;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                    FIX COMMON POLYGON PROBLEMS
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//FIX
//==============================================================================
//FIX COMMON POLYGON PROBLEMS ON SELECTED
//--------------------------------------------------
global proc fixCommonPolygonProblemsOnSelected( string $sel[] )
{
	$startTime = `timerX`;
	
	global int $WIZ_wizProcCount;
	wizProgressWindowStart("Fix Common Polygon Problems", "Starting", 1);	
	int $processSize = 7;
	if(`checkBox -q -v fixHighValenceVerticesTriangulateNonQuadGeometryCheckBox`){
		$processSize = 6;
	}
	int $maxProgress = (`size $sel` * $processSize);
	$WIZ_wizProcCount += $maxProgress;
	wizProgressWindowMinMax(0,(`progressWindow -q -max` * $WIZ_wizProcCount));
	
	removeTextureWindow polyTexturePlacementPanel1;
	
	int $ch = `constructionHistory -q -tgl`;
	if(`checkBox -q -v fixCommonPolygonProblemsHistoryCheckBox` == 0){
		//Turn off construction history
		//deleteHistoryOnAllObjectsInArray($sel);	
		select -r $sel;
		DeleteHistory;
		delete -ch;		
		constructionHistory -tgl off;
		refresh;
		//print("History State: " + `constructionHistory -q -tgl`);
	}
	
	for($i=0;$i<`size $sel`;$i++){
		if(`attributeExists "polyMeshPreparedForMudbox" $sel[$i]`){
			if(`getAttr ($sel[$i] + ".polyMeshPreparedForMudbox")`){
				stringArrayRemoveAtIndex($i, $sel);
				string $warning = (
				"WIZ| fixCommonPolygonProblems : Removed For List For Checking : "
				+ $sel[$i] 
				+" : Because It Is Marked As Fixed.\n"
				+" Please uncheck the "
				+ $sel[$i]
				+".polyMeshPreparedForMudbox attribute if you wish to check this object again.\n"
				);
				warning $warning;
			}
		}
		fixCommonPolygonProblems($sel[$i]);
		if(wizProgressCancelled() == 1) break;
		
	}	
		
	wizProgressWindowEnd();
	debugTime("fixCommonPolygonProblemsOnSelected",(`timerX -startTime $startTime`));
	
	$WIZ_wizProcCount = $WIZ_wizProcCount - $maxProgress;
	constructionHistory -tgl $ch;
}

//FIX COMMON POLYGON PROBLEMS
//--------------------------------------------------
global proc fixCommonPolygonProblems( string $sel )
{
	$startTime = `timerX`;	
         
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
		
	reportList($rl, {(" - FIXING: " + $sel)}); 
	reportList($rl, {(tslDiv(""))}); 
	
	//Fix Too Many Sides
	wizProgressWindowUpdate(($sel + "\n" + "Fixing Faces With Too Many Sides"), 0);
	fixFacesWithTooManySides({$sel});	
	
	select -r $sel;
	
	//Fix T Shapes
	wizProgressWindowStatus(("Fixing T Shapes On: " + $sel));
	fixTShapes({$sel});
		
	select -r $sel;
	
	//Fix High Valence Vertices
	wizProgressWindowStatus(("Fixing High Valence Vertices On: " + $sel));
	fixHighValenceVertices({$sel});
	
	select -r $sel;
	
	//Fix Non Manifold Vertices	
	wizProgressWindowStatus(("Fixing Non Manifold Vertices On: " + $sel));
	fixNonManifoldVertices({$sel});
	
	select -r $sel;
	
	//Fix Non Quad Geometry
	if(`checkBox -q -v fixHighValenceVerticesTriangulateNonQuadGeometryCheckBox`){	
		wizProgressWindowStatus(("Fixing Non Quad Geometry: " + $sel));
		fixNonQuadGeometry({$sel});
	}
	
	reportList($rl, {(tslDiv("[END]"))}); 	
	reportList($rl, {(tslDiv(""))}); 	
			
	wizProgressWindowStatus(("Checking If All Problems Are Fixed On: " + $sel));	
	int $pStep = wizProgressWindowGetStepValue(5);
	
	int $remainingProblems;
	string $tms[] = getFacesWithTooManySides({$sel});	
	if(`size $tms` > 0){
		$remainingProblems += `size $tms`;
	}
	wizProgressWindowStep($pStep);
	
	string $ts[] = getTShapes({$sel});	
	if(`size $ts` > 0){
		$remainingProblems += `size $ts`;
	}
	wizProgressWindowStep($pStep);
	
	string $hvv[] = getHighValenceVertices({$sel});	
	if(`size $hvv` > 0){
		$remainingProblems += `size $hvv`;
	}
	wizProgressWindowStep($pStep);
	
	string $nmv[] = getNonManifoldVertices({$sel});	
	if(`size $nmv` > 0){
		$remainingProblems += `size $nmv`;
	}
	wizProgressWindowStep($pStep);
	
			
	wizProgressWindowUpdate("Finished", $pStep);
	
	if($remainingProblems > 0){
		string $warningMessage = ("There Are " + $remainingProblems + " Remaing Problems That Were Not Fixed.\n"
		+"Do You Want To Run Fix Common Polygon Problems Again?");
		int $runAgain = wizWarningDialog("More Polygon Problems!", $warningMessage, "Yes", "No");
		if($runAgain == 1){
			string $evalDef = ("fixCommonPolygonProblems(\"" + $sel + "\");");
			evalDeferred($evalDef);
						
		}
	} 
	
	string $objs[] = getObjectsFromComponents({$sel});
	if(`size $objs` == 0){
		$objs[0] = $sel;	
	}
	string $notes = ("WIZ| FIXED ALL POLYGON PROBLEMS - " + `date` + "<br>------------------------------------------------------------");
	addNotesToObjects($objs,$notes);
	addPolyPreparedCheckAttr($objs);
		
	debugTime("fixCommonPolygonProblems",(`timerX -startTime $startTime`));
	
}

/*
global proc checkForCommonPolygonProblems(string $sel[])
{
	
}
*/

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			GET PROBLEMS
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//GET PROBLEMS COMPONENTS WITH CRITERIA
//==============================================================================

//FACES WITH TOO MANY SIDES
//===============================================================
//GET FACES WITH TO MANY SIDES
//------------------------------------------------
global proc string[] getFacesWithTooManySides(string $sel[])
{
	$startTime = `timerX`;
	string $dbl = "-dmi GetFacesWithTooManySidesDebugMenuItem -t Get Faces With Too Many Sides"; string $dbm = "add"; int $dbc = 1;
		
	string $tms[];
	
	string $f[] = wizConvertSelection($sel, "face");
	
	for($i=0;$i<`size $f`;$i++){
		
		string $e[] = wizConvertSelection({$f[$i]}, "edge");
		
		if(`size $e` >= 16){
			$tms[`size $tms`] = $f[$i];
			debugListString($dbl, (" - Face: " + $f[$i] + " Sides: " + `size $e`), $dbc, $dbm);
			
		if(wizProgressCancelled() == 1) return $tms; }
	}
	$tms = stringArrayRemoveDuplicates($tms);
	debugListArray($dbl, " - Faces With Too Many Sides: ", $tms, $dbc, $dbm, "", 0);
	select -r $tms;
	
	if(`size $tms` > 0){
		string $objs[] = getObjectsFromComponents($tms);
		string $notes = ("WIZ| FOUND " + `size $tms` + " FACE WITH TOO MANY SIDES - " + `date` + "<br>");
		addNotesToObjects($objs,$notes);
	}
	
	debugTime("getFacesWithTooManySides",(`timerX -startTime $startTime`));
	
	return $tms;
}

//FIX FACES WITH TOO MANY SIDES
//------------------------------------------------
global proc fixFacesWithTooManySides(string $sel[])
{
	$startTime = `timerX`;
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
	reportList($rl, {(" - FIXING FACES WITH TOO MANY SIDES - ")}); 
	
	string $dbl = "-dmi FixFacesWithTooManySidesDebugMenuItem -t Fix Faces With Too Many Sides"; string $dbm = "add"; int $dbc = 1;
	
	$sel = checkSel($sel);
	string $tms[] = getFacesWithTooManySides($sel);
	int $pStep = wizProgressWindowGetStepValue(`size $tms`);
	if(`size $tms` > 0){
		
		if(`size $tms` > 15){
			wizProgressWindowStatus("Fixing " + `size $tms` + " Faces With Too Many Sides\nThis May Take A While");
		} else if(`size $tms` > 30){
			wizProgressWindowStatus("Fixing " + `size $tms` + " Faces With Too Many Sides\nThis Is Going To Take A Long Time");
		} else {						
			wizProgressWindowStatus("Fixing " + `size $tms` + " Faces With Too Many Sides");
		}
		reportList(($rl + " -af -head [FIXING] Faces With Too Many Sides: -div NEXT -lmt 10"), $tms); 
		debugListArray($dbl, " - Faces With Too Many Sides: ", $tms, $dbc, $dbm, "", 100);
				
	} else {
		
		wizProgressWindowStep($pStep);
		reportList($rl, {(" - NO FACES WITH TOO MANY SIDES FOUND - ")}); 
		reportList($rl, {(tslDiv("[NEXT]"))}); 
		
		return;
	}
	select -r $tms;
	
	string $tmsSet = createSetFromSelection($tms, "fixFacesWithTooManySidesTempSet");
	debugListString($dbl, (" - Too Many Sides Set: " + $tmsSet), $dbc, $dbm);
	
	//Turn off smoothing of chamfer of high valence vertices temporarily
	int $sc = `checkBox -q -v fixHighValenceVerticesSmoothChamferCheckBox`;
	checkBox -e -v false fixHighValenceVerticesSmoothChamferCheckBox;
	
	$tms = getComponentsFromSetFlat($tmsSet);
	
	int $ok = 0;
	while($ok == 0){
		$tms = getComponentsFromSetFlat($tmsSet);
		if(`size $tms` == 0){
			$ok = 1;
			break;
		}
		sets -rm $tmsSet $tms[0];
		debugListString($dbl, (" - Fixing Face: " + $tms[0]), $dbc, $dbm);
		fixFaceWithTooManySides($tms[0]);
		
		wizProgressWindowStep($pStep);
		if(wizProgressCancelled() == 1) return;
	}
	
	emptyAndDeleteSet($tmsSet);
	
	debugTime("fixFacesWithTooManySides",(`timerX -startTime $startTime`));
	
	select -r $sel;
	
	if(`size $tms` > 0){
		string $notes = ("WIZ| FIXED " + `size $tms` + " FACES WITH TOO MANY SIDES - " + `date` + "<br>");
		addNotesToObject($sel[0],$notes);
	}
	
	checkBox -e -v $sc fixHighValenceVerticesSmoothChamferCheckBox;
}

//FIX FACE WITH TOO MANY SIDES
//------------------------------------------------
global proc fixFaceWithTooManySides(string $f)
{
	$startTime = `timerX`;
	
	string $dbl = "-dmi FixFacesWithTooManySidesDebugMenuItem -t Fix Face With Too Many Sides"; string $dbm = "add"; int $dbc = 1;
	
	select -r $f;
	debugListString($dbl, (" - Fixing Face: " + $f), $dbc, $dbm);
	
	refreshStepPause(1);
	
	//Triangulate
	int $ch = `checkBox -q -v fixCommonPolygonProblemsHistoryCheckBox`;
	polyTriangulate -ch $ch;
	
	if(`optionMenuGrp -q -sl tooManySidesFixMethodOptionMenuGrp` == 2){ return;}
	if(`menuItem -q -cb FixFacesWithTooManySidesDebugMenuItem`){
		menuItem -e -cb true SpinEdgesConnectedToVertexDebugMenuItem;
	}
	menuItem -e -cb false GetAngleBetweenTwoEdgesDebugMenuItem;
		
	//Get the edges created by triangulating
	ConvertSelectionToContainedEdges;
	refreshStepPause(1);
	
	string $e[] = `ls -fl -sl`;
	debugListArray($dbl, " - Edges Created By Triangulating: ", $e, $dbc, $dbm, "", 20);
	
	//Get any high valence vertices created by triangulating
	//select -r $f;
	string $highv[] = getHighValenceVertices($e);
	debugListArray($dbl, " - High Valence Vertices Created By Triangulating: ", $highv, $dbc, $dbm, "", 20);
	if(`size $highv` == 0){
		return;	
	}
	//select -r $highv;
	
	for($i=0;$i<`size $highv`;$i++){
		select -r $highv[$i];
		//Get the edges connected to the high valence vertices
		ConvertSelectionToEdges;
		string $highvEdges[] = `ls -fl -sl`;
		
		//Get the edges that are contained on the face and also connected to the high valence vertices
		string $spinEdges[] = intersectStringArrays($e, $highvEdges);
		debugListArray($dbl, " - Spin Edges: ", $spinEdges, $dbc, $dbm, "", 0);
		
		//Spin the edges
		spinEdgesConnectedToVertex($highv[$i], $spinEdges);
		string $hv[] = getHighValenceVertices({$highv[$i]});
		if(`size $hv` > 0){
			fixHighValenceVertex($hv[0]);	
		}
		if(wizProgressCancelled() == 1) return;
	}
	
	debugTime("fixFaceWithTooManySides",(`timerX -startTime $startTime`));
	
	select -r $f;
}


//SPIN EVERY OTHER EDGE
//=====================================================
global proc spinEdgesConnectedToVertex(string $vertex, string $e[])
{
	$startTime = `timerX`;	
	string $dbl = "-dmi SpinEdgesConnectedToVertexDebugMenuItem -t Spin Edges Connected To Vertex"; string $dbm = "add"; int $dbc = 1;
	int $ch = `checkBox -q -v fixCommonPolygonProblemsHistoryCheckBox`;
	debugListArray($dbl, " - Spin Edges: ", $e, $dbc, $dbm, "", 100);
	
	//Keep Selecting Every Other Edge - 1,3,5,7,9 ; 2,6,10 ; 4,12....
	int $si = 0; //Start Index
	int $ei = 0; //Edge Index
	int $eo = 2; //Every Other	
	int $spinCycle = 0;
	int $ok = 0;
	int $minSpinCount = int(ceil(`size $e` * 1));
	
	select -cl;
	int $skip;
	int $spinCount;
	while($ok == 0){		
		for($ei = $si;$ei<`size $e`;$ei = $ei + $eo){
			
			debugListString($dbl, ($e[$ei]), $dbc, $dbm);
			select -r $e[$ei];
			refreshStep();
			
			//Find the angle between the two outter edges
			//If the angle is greater than 180 then don't spin
			//Get the vertices of the edge			
			ConvertSelectionToVertices;
			string $ev[] = `ls -fl -sl`;
			debugListArray($dbl, (" 	- Vertices Of Edge: " + $e[$ei] + " "), $ev, $dbc, $dbm, "", 0);
			refreshStep();
			
			select -r $e[$ei];
			refreshStep();
			
			//Get the surrounding faces
			string $botf[] = `polyListComponentConversion -bo -tf`;
			select -r $botf;
			string $fse[] = `ls -fl -sl`;			
			debugListArray($dbl, (" 	- Faces Surrounding Edge: " + $e[$ei] + " "), $fse, $dbc, $dbm, "", 0);
			refreshStep();
			
			ConvertSelectionToVertices;
			string $fv[] = `ls -fl -sl`;
			debugListArray($dbl, (" 	- Vertices Of Surrounding Faces: " + $e[$ei] + " "), $fv, $dbc, $dbm, "", 0);
			refreshStep();
			
			//Remove the connecting vertex from the vertex list
			$fv = stringArrayRemove({$vertex}, $fv);
			select -r $fv;
			refreshStep();
			
			//Get the edges of the remaining vertice
			string $pcc[] = `polyListComponentConversion -in -te`;
			select -r $pcc;
			string $oe[] = `ls -fl -sl`; //Outside Edges
			if(`size $oe` < 2){ continue;}
			
			debugListArray($dbl, (" 	- Outside Edges: " + $e[$ei] + " "), $oe, $dbc, $dbm, "", 0);
			refreshStep();
			
			//Get the angle bettween the edge and the two outside edges
			float $angles[];
			$angles[0] = getAngleBetweenTwoEdges($e[$ei], $oe[0]);
			$angles[1] = getAngleBetweenTwoEdges($e[$ei], $oe[1]);			
				
			debugListString($dbl, (" - Edges: " + $oe[0] + " | " + $oe[1]), $dbc, $dbm);
			debugListString($dbl, (" - Angles: " + $angles[0] + " | " + $angles[1]), $dbc, $dbm);		
			
			//Add the angle together
			float $totAngle = $angles[0] + $angles[1];
			debugListString($dbl, (" - Total Angle: " + $totAngle), $dbc, $dbm);
			
			if($totAngle > 180){
				debugListString($dbl, (tslDiv("[ANGLE OVER 180 - DO NOT SPIN]")), $dbc, $dbm);
				//continue;	
			} else {		
							
				//Spin the edge
				select -r $e[$ei];
				polySpinEdge -ch $ch;	
				$spinCount++;
				
				debugListString($dbl, (" - Spin Edge: " + $e[$ei]), $dbc, $dbm);
				debugList($dbl, {(tslDiv("[SPIN" + $spinCount + "]"))}, $dbc, $dbm);
				
				refreshStep();
			}
			if(wizProgressCancelled() == 1) return;
		}
		
		//Skip every other		
		if($si == 0){			
			$si = 1;
		} else {
			$si = $si * 2;	
		}
		$eo = $eo * 2;
		
		//End the cycle
		if($spinCycle >= 1){
		
			if($spinCount >= $minSpinCount || ($si + $eo) > `size $e`){
				$ok = 1;	
				break;
			}		
						
		}
		$spinCycle++;
		
	}
	if($spinCount <= 8){
		debugListString($dbl, (" - CANNOT FIX :" + $vertex + " : BY SPINNING EDGES -"), $dbc, $dbm);	
	}
	debugListString($dbl, (" - Spun :" + $spinCount + " : Edges"), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END SPINNING]"))}, $dbc, $dbm);
	
	debugTime("spinEdgesConnectedToVertex",(`timerX -startTime $startTime`));
	
	return;	
}

//T SHAPES
//================================================================
//GET T SHAPES
//------------------------------------------------
global proc string[] getTShapes(string $sel[])
{
	$startTime = `timerX`;
		
	int $debug = `menuItem -q -cb GetTShapesDebugMenuItem`;
	string $dbl = "T Shapes";
	int $dbc = 1;
	string $dbm = "add";
	
	string $tse[]; //T Shape Edges
	string $tsf[]; //T Shape Faces
	//string $e[] = wizGetComponentFromSelection($sel, "edge");
	string $e[] = wizConvertSelection($sel, "edge");
	
	//int $pStep = wizProgressWindowGetStepValue(`size $e`);
	
	for($i=0;$i<`size $e`;$i++){
		//string $f[] = wizGetComponentFromSelection({$e[$i]}, "face");	
		string $f[] = wizConvertSelection({$e[$i]}, "face");
		
		if(`size $f` >= 3){
			$tse[`size $tse`] = $e[$i];
			appendStringArray($tsf, $f, `size $f`);
			if($debug){	
				debugList($dbl, {(" * T SHAPE * ")}, $dbc, $dbm);			
				debugList($dbl, {(" - Number Of Faces Adjacent To Edge: " + `size $f`)}, $dbc, $dbm);
				debugList($dbl, {$e[$i]}, $dbc, $dbm);
				debugList($dbl, $f, $dbc, $dbm);
				debugList($dbl, {("---------------------------------")}, $dbc, $dbm);
			}
		}
		clear $f;
		//wizProgressWindowStep($pStep);
		if(wizProgressCancelled() == 1){ return $tse;}
	}
	$tsf = stringArrayRemoveDuplicates($tsf);
	$tse = stringArrayRemoveDuplicates($tse);
	
	//string $ts[] = { (" - T Shape Edges - ") };
	//appendStringArray($ts,$tse,`size $tse`);
	
	//addSelectedObjectsToTextScrollList($tse, "selectMasterListB");
	//addSelectedObjectsToTextScrollList($tsf, "selectMasterListB");
	
	if($debug){	
		if(`size $tse` == 0){
			debugList($dbl, {(" * No T Shapes Found *")}, $dbc, $dbm);	
		}
		//debugList($dbl, $highV, $dbc, $dbm);
		openDebugWiz();
	}
	select -r $tse;
	
	if(`size $tse` > 0){
		string $objs[] = getObjectsFromComponents($tse);
		string $notes = ("WIZ| FOUND " + `size $tse` + " T SHAPES - " + `date` + "<br>");
		addNotesToObjects($objs,$notes);
	}
	
	debugTime("getTShapes",(`timerX -startTime $startTime`));
	return $tse;	
}

//GET INTERIOR FACES OF T SHAPES
//------------------------------------------------
global proc string[] getInteriorFacesOfTShapes(string $sel[])
{
	$startTime = `timerX`;
	$sel = checkSel($sel);
	select -r $sel;
	
	//This gets the edges of the t shapes
	string $tse[] = getTShapes($sel);
	
	//Get the faces inside those edges
	string $f[] = getInteriorFacesOfEdges($tse);
	select -r $f;
	
	debugTime("getInteriorFacesOfTShapes",(`timerX -startTime $startTime`));
	
	return $f;
}

//GET T SHAPE FACES ON BORDER
//------------------------------------------------
global proc string[] getTShapeFacesOnBorder(string $sel[])
{
	$startTime = `timerX`;
	string $dbl = "-dmi GetTShapeFacesOnBorderDebugMenuItem -t T Shape Faces On Border"; string $dbm = "add"; int $dbc = 1;
	
	$sel = checkSel($sel);
	debugListArray($dbl, " - Selected: ", $sel, $dbc, $dbm, "", 100);
	/*
	optionMenuGrp -e -sl 3 getComponentsOfTypeOnBorderPolyComponentsTypeOptionMenuGrp;
	string $type = `optionMenuGrp -q -v getComponentsOfTypeOnBorderPolyComponentsTypeOptionMenuGrp`;
	*/
	//Get the border edges
	string $be[] = getComponentsOfTypeOnBorder(`ls -sl`, "edges");
	debugListArray($dbl, " - T Shape Border Edges: ", $be, $dbc, $dbm, "", 100);
	polySelectConstraint -dis;
	
	//Get the edges of the t shapes
	select -r $sel;
	string $tse[] = getTShapes($sel);
	debugListArray($dbl, " - T Shape Edges: ", $tse, $dbc, $dbm, "", 100);
	polySelectConstraint -dis;
	
	//Select the border edges and the tshape edges
	select -r $be;
	select -add $tse;
	string $e[] = `ls -fl -sl`;
	
	//Get all the faces inside those edges
	string $bf[] = getInteriorFacesOfEdges($e);
	select -r $bf;
	debugListArray($dbl, " - T Shape Border Faces: ", $bf, $dbc, $dbm, "", 100);
	polySelectConstraint -dis;
	
	debugTime("getTShapeFacesOnBorder",(`timerX -startTime $startTime`));
	
	return $bf;
}

//FIX T SHAPES
//------------------------------------------------
global proc fixTShapes(string $sel[])
{
	$startTime = `timerX`;
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
	
	string $ts[] = getTShapes($sel);
	
	int $pStep = wizProgressWindowGetStepValue(`size $ts`);
	
	if(`size $ts` > 0){ 			
		wizProgressWindowStatus("Fixing " + `size $ts` + " T Shapes");
		
		reportList(($rl + " -af -head T Shapes: -div NEXT -lmt 10"), $ts); 
	} else {
		wizProgressWindowStep($pStep);
		
		reportList($rl, {(" - NO T SHAPES FOUND - ")}); 
		reportList($rl, {(tslDiv("[NEXT]"))}); 
		
		return;
	}
	
	reportList(($rl + " -af -head T Shapes: -div [NEXT] -lmt 10"), $ts); 

	select -r $ts;
	string $if[] = getInteriorFacesOfTShapes($ts);
	
	reportList(($rl + " -af -head [DELETING] Interior Faces Of T Shapes: -div [NEXT] -lmt 10"), $if); 

	select -r $if;
	delete $if;
	string $bf[] = getTShapeFacesOnBorder($sel);
	
	reportList(($rl + " -af -head [DELETING] T Shape Faces On Border: -div [END] -lmt 10"), $bf);

	select -r $bf;
	delete $bf;
	
	string $notes = ("WIZ| FIXED " + `size $ts` + " T SHAPES - " + `date` + "<br>");
	addNotesToObject($sel[0],$notes);
	
	wizProgressWindowStep($pStep);	
	
	debugTime("fixTShapes",(`timerX -startTime $startTime`));
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			HIGH VALENCE VERTICES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//GET HIGH VALENCE VERTICES
//---------------------------------------------
global proc string[] getHighValenceVertices(string $sel[])
{
	$startTime = `timerX`;
	
	string $dbl = "-dmi GetHighValenceVerticesDebugMenuItem -t High Valence Vertices"; string $dbm = "add"; int $dbc = 1;
	
	$sel = checkSel($sel);
	
	string $highV[];
	//string $v[] = wizGetComponent($sel, "vertex");
	ConvertSelectionToVertices;
	string $v[] = `ls -fl -sl`;
	
	for($i=0;$i<`size $v`;$i++){
		//string $e[] = wizGetComponent({$v[$i]}, "edge");
		select -r $v[$i];
		ConvertSelectionToEdges;
		string $e[] = `ls -fl -sl`;
		
		if(`size $e` > 16){
			$highV[`size $highV`] = $v[$i];			
			debugList($dbl, {$v[$i]}, $dbc, $dbm);			
			debugList($dbl, {(tslDiv("[NEXT]"))}, $dbc, $dbm);			
		}
		clear $e;
		if(wizProgressCancelled() == 1){ return $highV;}

	}
	$highV = stringArrayRemoveDuplicates($highV);
	select -r $highV;
	
	if(`size $highV` > 0){
		string $objs[] = getObjectsFromComponents($highV);
		string $notes = ("WIZ| FOUND " + `size $highV` + " HIGH VALENCE VERTICES - " + `date` + "<br>");
		addNotesToObjects($objs,$notes);
	}
	
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	debugTime("getHighValenceVertices",(`timerX -startTime $startTime`));
	
	return $highV;
}

//GET HIGH VALENCE VERTICES COUNT
//-----------------------------------
global proc int getHighValenceVerticesCount(string $sel[])
{
	int $highVCount;	
	for($i=0;$i<`size $sel`;$i++){	
		string $highV[] = getHighValenceVertices({$sel[$i]});
		$highVCount = $highVCount + `size $highV`;
		if(wizProgressCancelled() == 1){ return $highVCount; }
	}
	return $highVCount;
}

//FIX HIGH VALENCE VERTICES
//-----------------------------------
global proc fixHighValenceVertices(string $sel[])
{
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
	reportList($rl, {(" - FIXING HIGH VALENCE VERTICES - ")}); 
	
	$startTime = `timerX`;
	string $v[] = getHighValenceVertices($sel);
	int $pStep = wizProgressWindowGetStepValue(`size $v`);
	if(`size $v` > 0){
				
		wizProgressWindowStatus("Fixing " + `size $v` + " High Valence Vertices");
		
		reportList(($rl + " -af -head [FIXING] High Valence Vertices: -div NEXT -lmt 10"), $v);		
	} else {
		wizProgressWindowStep($pStep);
		
		reportList($rl, {(" - NO HIGH VALENCE VERTICES FOUND - ")}); 
		reportList($rl, {(tslDiv("[NEXT]"))}); 	
		
		return;
	}
	
	select -r $v;
	$v = `ls -fl -sl`;
	
	int $method = `optionMenuGrp -q -sl fixHighValenceVerticesMethodOptionMenuGrp`;
	
	string $dbl = "-dmi FixHighValenceVertexDebugMenuItem -t Fix High Valence Vertex"; string $dbm = "add"; int $dbc = 1;
	//Create a set from vertex selection
	//Once we start fixing the vertices the order and name of vertice will change
	string $vSet = createSetFromSelection($v, "fixHighValenceVertexVertexSet");
	
	string $vs[] = getComponentsFromSetFlat($vSet);	
	int $highvCount = `size $vs`;
	debugListArray($dbl, " - High Valence Vertices: ", $v, $dbc, $dbm, "", 100);	
	debugList($dbl, { (" - High Valence Vertices Set: " + $vSet) }, $dbc, $dbm);
	debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
	
	debugList($dbl, { (" * FIXING HIGH VALENCE VERTICES * ") }, $dbc, $dbm);
	debugList($dbl, {(tslDiv("START"))}, $dbc, $dbm);
	
	int $progressStep = (`progressWindow -q -max` / `size $vs`) / 6;
	
	int $ok = 0;
	while($ok == 0){
		$vs= getComponentsFromSetFlat($vSet);
		//debugList($dbl, { (" - HVV Set Size: " + `size $vs`) }, $dbc, $dbm);	
	
		if(`size $vs` == 0){
			$ok = 1;
			break;
		}
		debugList($dbl, { (" - Fixing Vertex: " + $vs[0]) }, $dbc, $dbm);
		debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
		
		if($method == 1){
			fixHighValenceVertex($vs[0]);
		} else if($method == 2){
			fixHighValenceVertexSpinEdges($vs[0]);
		}
		debugList($dbl, {(tslDiv("NEXT"))}, $dbc, $dbm);
		
		wizProgressWindowStep($pStep);
		if(wizProgressCancelled() == 1){ return;}
	}
	
	string $notes = ("WIZ| FIXED " + $highvCount + " HIGH VALENCE VERTICES - " + `date` + "<br>");
	addNotesToObject($sel[0],$notes);
	
	debugList($dbl, { (" - Fix High Valence Vertices Complete - ") }, $dbc, $dbm);
	debugList($dbl, {(tslDiv("END"))}, $dbc, $dbm);
	debugTime("fixHighValenceVertices",(`timerX -startTime $startTime`));
		
	emptyAndDeleteSet($vSet);
	
}

//FIX HIGH VALENCE VERTEX
//-----------------------------------
global proc fixHighValenceVertex(string $v)
{
	$startTime = `timerX`;
	
	string $dbl = "-dmi FixHighValenceVertexDebugMenuItem -t Fix High Valence Vertex"; string $dbm = "add"; int $dbc = 1;
	//We either delete the hole the chamfer makes and close the vertices up tight or...
	//Triangulate the hole
	int $chamferOption = `optionMenuGrp -q -sl highValenceVerticesChamferOptionOptionMenuGrp`;
	float $chamferWidth = 0.001;
	int $deleteHole = 1;
	if($chamferOption == 2){
		$deleteHole = 0;
		$chamferWidth = 0.025;
	}
	select -r $v;
	
	float $fPos[] = `xform -q -ws -t $v`;
	
	//Get the surrounding edges and put them in a set for later
	ConvertSelectionToEdges;
	string $e[] = `ls -fl -sl`;
	string $eCount = `size $e`;
	string $eSet = createSetFromSelection($e, "fixHighValenceVertexEdgeSet");
	
	debugList($dbl, { (" - Vertex: " + $v) }, $dbc, $dbm);
	debugListArray($dbl, " - Edges: ", $e, $dbc, $dbm, "", 20);
		
	//Chamfer the vertex
	select -r $v;
	polyChamferVtx 1 $chamferWidth $deleteHole;
	
	if(`checkBox -q -v fixHighValenceVerticesSmoothChamferCheckBox` == 1){
		//Select one of the edges from above and do a polySplit ring to get a smoother surface
		int $splitCount = 3;
		int $splitCountDown = $splitCount + 1;
		debugListString($dbl,(" - Splitting Rings - "), $dbc, $dbm);	
		for($i=0;$i<$splitCount;$i++){
			$e = `sets -q $eSet`;
			select -r $e;
			float $weight = 1 - ((1 / ($splitCountDown + 0.1)) / $splitCountDown);
			debugListString($dbl,(" - Weight: " + $weight), $dbc, $dbm);	
			polySplitRing -ch on -splitType 1 -weight $weight -smoothingAngle 30 -fixQuads 0 -insertWithEdgeFlow 0 ;	
			
			ConvertSelectionToVertices;
			string $ring[] = `ls -fl -sl`;
			float $sv = 1 + (0.1 / ($i + 1));
			debugListString($dbl,(" - Scale Vertices: " + $sv), $dbc, $dbm);
			polyMoveVertex -s $sv $sv $sv;	
			
			$splitCountDown = $splitCountDown - 1;
			debugListString($dbl, (tslDiv("NEXT SPLIT")), $dbc, $dbm);
			if(wizProgressCancelled() == 1){ return;}
		}
	}
	if($chamferOption == 2){	
		$e = `sets -q $eSet`;
		select -r $e;
		
		string $cface[] = getComponentsOfTypeAtDistanceFromPoint($e,"face", $fPos, 0, 1);
		polySelectConstraint -dis;
		/*
		debugList($dbl, { (" - Chamfer Face Search: " + `size $cface`) }, $dbc, $dbm);
		debugList($dbl, { (" - Point: " + $fPos[0] + " " + $fPos[1] + " " + $fPos[2]) }, $dbc, $dbm);
		debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
		debugList($dbl, $cface, $dbc, $dbm);
		debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
		*/
		
		$e = `sets -q $eSet`;
		select -r $e;
		ConvertSelectionToFaces;
		select -add $cface;
		
		polyTriangulate;
	}
	
	emptyAndDeleteSet("fixHighValenceVertexEdgeSet");
	debugTime("fixHighValenceVertex",(`timerX -startTime $startTime`));

}

//FIX HIGH VALENCE VERTEX SPIN EDGES
//-----------------------------------
global proc fixHighValenceVertexSpinEdges(string $v)
{
	//Get the surrounding edges and put them in a set for later
	ConvertSelectionToEdges;
	string $e[] = `ls -fl -sl`;
	string $eCount = `size $e`;
	string $eSet = createSetFromSelection($e, "fixHighValenceVertexEdgeSet");
	
	spinEveryOtherEdge($e);
	
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			NON MANIFOLD VERTICES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//NON MANIFOLD VERTICES
//=========================================================================================
//GET NON MANIFOLD VERTICES
//------------------------------------------------
global proc string[] getNonManifoldVertices(string $sel[])
{
	$startTime = `timerX`;
	
	$sel = checkSel($sel);
	select -r $sel;
	if(`size $sel` == 0){ return $sel; }
	
	//string $nmv[] = `polyCleanupArgList 3 { "0","2","0","0","0","0","0","0","0","1e-05","0","1e-05","0","1e-05","0","1","0" }`;
	string $nmv[] = `polyInfo -nmv`;
	/*
	for($i=0;$i<`size $nmvPolyInfo`;$i++){
		string $tok[] = tokenizeString($nmvPolyInfo[$i], " ");
		$tok = stringArrayRemoveAtIndices({0,1,4},$tok);
		
	}
	*/
	//string $nm[] = `ls -fl -sl`;
	select -r $nmv;
	
	if(`size $nmv` > 0){
		string $objs[] = getObjectsFromComponents($nmv);
		string $notes = ("WIZ| FOUND " + `size $nmv` + " NON MANIFOLD VERTICES - " + `date` + "<br>");
		addNotesToObjects($objs,$notes);
	}
	
	debugTime("getNonManifoldVertices",(`timerX -startTime $startTime`));
	
	return $nmv;
	

}

//GET INTERIOR FACES OF NON MANIFOLD VERTICES
//------------------------------------------------
global proc string[] getInteriorFacesOfNonManifoldVertices(string $sel[])
{
	string $nmv[] = getNonManifoldVertices($sel);
	string $if[] = getInteriorFacesOfVertices($nmv);
	select -r $if;
	
	return $if;

}

//FIX NON MANIFOLD VERTICES
//-----------------------------------------------
global proc fixNonManifoldVertices(string $sel[])
{
	$startTime = `timerX`;
	
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
	
	reportList($rl, {(" - FIXING NON-MANIFOLD(VERTEX SPLICES) - ")}); 
	
	string $nmv[] = getNonManifoldVertices($sel);
	
	int $pStep = wizProgressWindowGetStepValue(`size $nmv`);
	
	if(`size $nmv` > 0){		
		wizProgressWindowStatus("Fixing " + `size $nmv` + " Non Manifold Vertices");
		
		reportList(($rl + " -af -head NonManifold Vertices: -div NEXT -lmt 10"), $nmv);	
		
	} else {
		wizProgressWindowStep($pStep);		
		wizProgressWindowStatus(" - NO NON-MANIFOLD(VERTEX SPLICES) FOUND - ");
		
		reportList($rl, {(" - NO NON-MANIFOLD(VERTEX SPLICES) FOUND - ")}); 
		
		return;
	}
	select -r $sel;
	string $fnmv[] = getInteriorFacesOfNonManifoldVertices($sel);
	reportList(($rl + " -af -head [DELETING] NonManifold(Vertex Splices): -div NEXT -lmt 10"), $fnmv);
	
	select -r $fnmv;
	
	string $notes = ("WIZ| FIXED " + `size $nmv` + " NON MANIFOLD VERTICES - " + `date` + "<br>");
	addNotesToObject($sel[0],$notes);
	
	debugTime("fixNonManifoldVertices",(`timerX -startTime $startTime`));
	
	delete $fnmv;
	wizProgressWindowStep($pStep);
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			NON QUAD GEOMETRY
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//FIX NON QUAD GEOMETRY
//-----------------------------------------------------
global proc fixNonQuadGeometry(string $sel[])
{
	$startTime = `timerX`;
	string $rl = ("-t Common Polygon Problems -h 500 -p inspectionReportColumnLayout -n fixCommonPolygonProblemsInspectionReport");
	reportList($rl, {(" - FIXING NON QUAD GEOMETRY - ")}); 
	
	string $dbl = "-dmi FixNonQuadGeometryDebugMenuItem -t Fix Non Quad Geometry"; string $dbm = "add"; int $dbc = 1;
	
	$sel = checkSel($sel);
	
	string $nsf[] = getNSidedFaces($sel);
	int $pStep = wizProgressWindowGetStepValue(`size $nsf`);
	if(`size $nsf` > 0){
	
		wizProgressWindowStatus("Fixing " + `size $nsf` + " Faces Of Non Quad Geometry");
		
		reportList(($rl + " -af -head [FIXING] Faces Of Non Quad Geometry: -div NEXT -lmt 10"), $nsf); 
		debugListArray($dbl, " - Faces Of Non Quad Geometry: ", $nsf, $dbc, $dbm, "", 100);
				
	} else {
		
		wizProgressWindowStep($pStep);
		reportList($rl, {(" - NO NON QUAD GEOMETRY FOUND - ")}); 
		reportList($rl, {(tslDiv("[NEXT]"))}); 
		
		return;
	}
	select -r $sel;
	polyTriangulate;
	
	debugTime("fixNonQuadGeometry",(`timerX -startTime $startTime`));
	
	wizProgressWindowStep(`size $nsf`);
	
	if(`size $nsf` > 0){
		string $notes = ("WIZ| FIXED " + `size $nsf` + " FACES OF NON QUAD GEOMETRY - " + `date` + "<br>");
		addNotesToObject($sel[0],$notes);
	}
}


//GET FACES WITH MORE THAN 4 VERTICES
//========================================
global proc string[] getFacesWithMoreThan4Vertices(string $sel[])
{
	
	string $highV[];
	//string $f[] = wizGetComponentFromSelection($sel, "face");
	string $f[] = wizConvertSelection($sel, "face");
	
	for($i=0;$i<`size $f`;$i++){
		string $v[] = wizGetComponentFromSelection({$f[$i]}, "vertex");
		if(`size $v` > 4){
			appendStringArray($highV, $v, `size $v`);
			//debugList("Faces With More Than 4 Vertices", $v, 1, "add");
		}
	}
	$highV = stringArrayRemoveDuplicates($highV);
	//debugList("Faces With More Than 4 Vertices", $highV, 1, "add");
	
	return $highV;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                     OTHER POLYGON SELECTIONS
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//GET VERT COUNT PER FACE
//=============================================
global proc int[] getVertCountPerFace(string $face[])
{
	int $vertCount[];
	for($i=0;$i<`size $face`;$i++){
		select -r $face[$i];
		ConvertSelectionToVertices;
		string $v[] = `ls -fl -sl`;
		$vertCount[`size $vertCount`] = `size $v`;	
	}
	return $vertCount;
}

//CREATE POLY APPEND STRING
//=============================================
global proc string createPolyAppendPositionString(float $vPos[])
{
	string $p = "-p ";
	for($i=0;$i<`size $vPos`;$i++){
		$p = $p + $vPos[$i] + " ";
	}
	return $p;
}


//GET QUAD FACES
//=============================================
global proc string[] getQuadFaces(string $sel[])
{
	if(`size $sel` == 0){
		$sel = checkSel($sel);
	}
	polySelectConstraint -m 3 -t 0x0008 -sz 2;
	string $quadFaces[] = `ls -fl -sl`;
	polySelectConstraint -dis;
	return $quadFaces;	
}

//GET TRI FACES
//=============================================
global proc string[] getTriFaces(string $sel[])
{
	if(`size $sel` == 0){
		$sel = checkSel($sel);
	}
	polySelectConstraint -m 3 -t 0x0008 -sz 1;
	string $triFaces[] = `ls -fl -sl`;
	polySelectConstraint -dis;
	return $triFaces;	
}

//GET N SIDED FACES
//=============================================
global proc string[] getNSidedFaces(string $sel[])
{
	if(`size $sel` == 0){
		$sel = checkSel($sel);
	}
	polySelectConstraint -m 3 -t 0x0008 -sz 3;
	string $nSidedFaces[] = `ls -fl -sl`;
	polySelectConstraint -dis;
	return $nSidedFaces;	
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         CONVERT SELECTION
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//GET VERTICES FROM FACE
//=============================================
global proc string[] getVerticesFromFace(string $sel[])
{
	string $face = $sel[0];	
	string $polyInfo[] = `polyInfo -fv $face`;
	
	string $buffer[];
	int $numTok = `tokenize $polyInfo[0] " " $buffer`;
	//debugList("Buffer1",$buffer,1,"replace");
	
	$buffer = stringArrayRemoveAtIndices({0,1},$buffer);
	//debugList("Buffer2",$buffer,2,"replace");
	
	string $f[] = {$face};
	string $mesh = getObjectFromComponent($f);
	string $vPrefix = $mesh + ".vtx";
	string $v[] = createIndexSelectionStringArray($vPrefix, $buffer);
	//debugList("Vert",$v,3,"replace");
	select -r $v;
	return $v;
}

//POLY INFO EDGE TO VERTEX
//=============================================
global proc string[] polyInfoEdgeToVertex(string $sel[])
{
	string $edge = $sel[0];	
	string $polyInfo[] = `polyInfo -ev $edge`;
	
	string $buffer[];
	int $numTok = `tokenize $polyInfo[0] " " $buffer`;
	$buffer = stringArrayRemoveAtIndices({0,1,4},$buffer);
	
	string $e[] = {$edge};
	string $mesh = getObjectFromComponent($e);
	string $vPrefix = $mesh + ".vtx";
	string $v[] = createIndexSelectionStringArray($vPrefix, $buffer);

	return $v;
}

//GET VERTEX PER FACE COUNT
//=============================================
global proc getVertexPerFaceCount(string $sel[])
{
	string $mesh = $sel[0];
	printProc("getVertexPerFaceCount");	
	select -r $mesh;
	ConvertSelectionToFaces;
	string $f[] = `ls -fl -sl`;
	debugList("Faces", $f, 1, "replace");
	
	int $vCount[] = getVertCountPerFace($f);
	string $vCountString[] = intArrayToStringArray($vCount);
	debugList("Vertex Count Per Face", $vCountString, 2, "replace");

}

//POLY VERTEX SELECTION CONVERSION
//=============================================
global proc string[] doPolyVertexSelectionConversion(string $sel[])
{
	select -r $sel;
	ConvertSelectionToVertices;
	string $v[] = `ls -fl -sl`;
	return $v;
}

//POLY FACE SELECTION CONVERSION
//=============================================
global proc string[] doPolyFacesSelectionConversion(string $sel[])
{
	select -r $sel;
	ConvertSelectionToFaces;
	string $v[] = `ls -fl -sl`;
	return $v;
}


//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                    OTHER GEOMETRY INFORMATION
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//OTHER GEOMETRY INFORMATION
//==============================================================================
//GET EDGE DIRECTION
//=============================================
global proc float[] getEdgeDirection(string $e, float $refDir[])
{
	string $v[] = wizConvertSelection({$e}, "vertices");
	
	$v = sortByDirection($v, $refDir);
	
	float $vt0[] = `xform -q -t $v[0]`;
	float $vt1[] = `xform -q -t $v[1]`;
	
	float $dir[] = getDirectionFromTwoPoints($vt0, $vt1);
	
	return $dir;
}

//GET NEXT COMPONENT IN DIRECTION
//================================================
global proc string getNextComponentInDirection(string $comp, float $dir[])
{
	string $dbl = "-dmi GetNextComponentInDirectionDebugMenuItem -t Get Next Component In Direction"; string $dbm = "add"; int $dbc = 1;
	
	float $min = `floatFieldGrp -q -v1 getNextComponentInDirectionMinFloatFieldGrp`;
	float $max = `floatFieldGrp -q -v1 getNextComponentInDirectionMaxFloatFieldGrp`;
	
	debugListString($dbl, (" - Direction: " + $dir[0] + " " + $dir[1] + " " + $dir[2]), $dbc, $dbm);
	
	string $obj = getObjectFromComponent({$comp});
	debugListString($dbl, (" - Object: " + $obj), $dbc, $dbm);
	
	string $compType = getComponentSelectionType($comp);
	debugListString($dbl, (" - Component Type: " + $compType), $dbc, $dbm);
	
	string $cdir[] = getComponentsInDirection({$comp},$dir, $min, $max);
	debugListArray($dbl, " - Components In Direction: ", $cdir, $dbc, $dbm, "", 20);
	
	/*
	string $allComp[] = wizGetComponent({$obj}, $compType);
	debugListArray($dbl, " - All Components: ", $allComp, $dbc, $dbm, "", 20);
	*/
	
	float $t[] = `xform -q -ws -t $comp`;
	debugListString($dbl, (" - Component Transform: " + $t[0] + " " + $t[1] + " " + $t[2]), $dbc, $dbm);
	//float $tTot = addAllInArray($t);
	
	$cdir = stringArrayRemove({$comp},$cdir);
	
	string $closest[] = sortByClosestToPoint($cdir, $t);
	debugListArray($dbl, " - Sorted By Closest To Point: ", $closest, $dbc, $dbm, "", 0);
	
	select -r $closest[0];
	debugListString($dbl, (" - Next In Direction: " + $closest[0]), $dbc, $dbm);
	return $closest[0];
	
	/*
	float $nextDir[];
	$nextDir = multiplyArrays($t,$dir);	
	//$nextDir = normalizeFloatArray($nextDir);
	*/
	
	/*
	debugListString($dbl, (" - Next Dir: " + $nextDir[0] + " " + $nextDir[1] + " " + $nextDir[2]), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[LOOKING IN DIR]"))}, $dbc, $dbm);
	
	for($i=0;$i<`size $closest`;$i++){
		if($closest[$i] == $comp){continue;}
		
		float $pos[] = `xform -q -ws -t $closest[$i]`;
		$pos = multiplyArrays($pos, $nextDir);
		float $pTot = addAllInArray($pos);
		
		debugListString($dbl, ($closest[$i]), $dbc, $dbm);
		
		debugListString($dbl, (" - Compare: " + $pos[0] + " < " + $nextDir[0] + " && " + $pos[1] + " < " + $nextDir[1] + " && " + $pos[2] + " < " + $nextDir[2]), $dbc, $dbm);
		//debugListString($dbl, (" - Compare: " + $pTot + " < " + $tTot), $dbc, $dbm);
		
		if($pos[0] < $nextDir[0] && $pos[1] < $nextDir[1] && $pos[2] < $nextDir[2]){
			debugList($dbl, {(tslDiv("[NOT IN DIR]"))}, $dbc, $dbm);
			continue;	
			
		} else {
			
			debugListString($dbl, (" - FOUND CLOSEST IN DIRECTION: " + $closest[$i]), $dbc, $dbm);
			debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
			select -r $closest[$i];
			return $closest[$i];	
		}
		
	}
	*/
	//select -r $comp;
	//return $comp;	
}

//POLY COMPARE
//=================================================
global proc int polyCompareSelected(string $sel[], string $compare)
{
		
	string $polyCompare = "polyCompare ";
	switch($compare){
		case "faces" : case "Faces" : case "-fd" :
		$polyCompare = $polyCompare + " -fd ";
		break;
		case "vertices" : case "Vertices" : case "-v" :
		$polyCompare = $polyCompare + " -v ";
		break;
		case "edges" : case "Edges" : case "-e" :
		$polyCompare = $polyCompare + " -e ";
		break;
		case "uvs" : case "UVs" : case "-uv" :
		$polyCompare = $polyCompare + " -uv ";
		break;
		case "uvSetIndices" : case "UV Set Indices" : case "-iuv" :
		$polyCompare = $polyCompare + " -iuv ";
		break;
		case "all" : case "All" : case "-all" :
		$polyCompare = $polyCompare + " -fd -v -e -uv -iuv ";
		break;
	}
	$polyCompare = $polyCompare + $sel[0] + " " + $sel[1] + ";";
	int $same = `eval($polyCompare)`;
	return $same;
}

//GET FACE NORMALS
//=================================================
global proc float[] getFaceNormals( string $sel[] )
{
	int $debug = `menuItem -q -cb GetFaceNormalsDebugMenuItem`;
	string $dbl = "Get Face Normals";
	int $dbc = 1;
	string $dbm = "add";	
	
	float $fn[];	
	select -r $sel;
	string $polyInfo[] = `polyInfo -fn`;
	
	for($i=0;$i<`size $polyInfo`;$i++){
		string $piTok[] = tokenizeString($polyInfo[$i], ":");
		string $vals[] = tokenizeString($piTok[1], " ");
		float $n[] = stringArrayToFloatArray($vals);
		$fn = appendFloatArray($fn, $n, `size $n`);
		
		if($debug){
			//debugList($dbl, { (floatArrayToString($n, " | ")) }, $dbc, $dbm);		
		}
	}
	
	if($debug){
		debugList($dbl, { ("------------------------------") }, $dbc, $dbm);
	}
	
	return $fn;
}

//IS SURFACE CLOSED
//============================================
global proc int isSurfaceClosed(string $sel[])
{
	string $e[] = getComponentsOfTypeOnBorder($sel, "edge");
	if(`size $e` == 0){
		return 1;	
	} else {
		return 0;	
	}
}

global proc int inwardOrOutwardNormals(string $sel[])
{
	return 1;
}

//GET SYMETRICAL AXIS
//======================================================
global proc string[] getMeshSymetricalAxis(string $sel[])
{
	
	return $sel;	
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         MERGE VERTICES
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//MERGE VERTICES ON SELECTED
//=========================================
global proc mergeVerticesOnSelected(string $sel[], float $d)
{
	for($i=0;$i<`size $sel`;$i++){	
		mergeVertices($sel[$i], $d);
	}
	}
	
	global proc mergeVertices(string $obj, float $d)
	{
	//polyMergeVertex  -d $d $obj;	
	polyMergeVertex $obj;
}

//MAXIMIZE MERGE VERTICES
//======================================================
global proc maximizeMergeVertices(string $sel[])
{
	for($i=0;$i<`size $sel`;$i++){
		maximizeMergeVerticesOnSelected({$sel[$i]});
	}
}

//MAXIMIZE MERGE VERTICES ON SELECTED
//======================================================
global proc maximizeMergeVerticesOnSelected(string $sel[])
{
	//<DEBUG>
	string $dbl = "-dmi MaximizeMergeVerticesDebugMenuItem -t Maximize Merge Vertices";
	int $dbc = 1;
	string $dbm = "add";
	//<DEBUG>
	
	openCurrentOptions("maximizeMergeVerticesOptionsMenu");
	
	float $inc = `floatSliderGrp -q -v maximizeMergeVerticesIncrementDistanceFloatSliderGrp`;
	float $d = `floatSliderGrp -q -v maximizeMergeVerticesMinDistanceFloatSliderGrp`; //The starting distance between vertices
	float $maxD = `floatSliderGrp -q -v maximizeMergeVerticesMaxDistanceFloatSliderGrp`;
	string $mesh = $sel[0];
	
	int $initFaceCount[];
	string $initFCString;
	if(catchQuiet($initFaceCount = `polyEvaluate -f $mesh`) == 1){
		if(catchQuiet($initFCString = `polyEvaluate -f $mesh`) == 1){
			catchQuiet($initFaceCount[0] = int($initFCString));
			print("WIZ| polyWiz: maximizeMergeVertices: Cannot polyEvaluate -f for some strange reason\n");
		}
	}
	int $initVertCount[] = `polyEvaluate -v $mesh`;
	
	//<DEBUG>	
	debugList($dbl, { (" * Maximizing Merge Vertices On Mesh: " + $mesh + " *") }, $dbc, $dbm);
	debugList($dbl, { (" - Initial Merge Distance: " + $d) }, $dbc, $dbm);
	debugList($dbl, { (" - Increment Distance By: " + $inc) }, $dbc, $dbm);
	debugList($dbl, { (" - Maximum Distance: " + $maxD) }, $dbc, $dbm);
	debugList($dbl, { (" -----------------------------") }, $dbc, $dbm);
	debugList($dbl, { (" - Init Vert Count: " + $initVertCount[0]) }, $dbc, $dbm);
	debugList($dbl, { (" - Init Face Count: " + $initFaceCount[0]) }, $dbc, $dbm);
	debugList($dbl, { (" ----------START------------") }, $dbc, $dbm);	
	
	//<DEBUG>
	
	int $ok = 1;
	while($ok){
		int $beforeFaceCount[] = `polyEvaluate -f $mesh`;
		int $beforeVertCount[] = `polyEvaluate -v $mesh`;
		polyMergeVertex -d $d -am 0 -ch 0 $mesh;
		
		int $afterFaceCount[] = `polyEvaluate -f $mesh`;
		int $afterVertCount[] = `polyEvaluate -v $mesh`;
		
		if($afterFaceCount[0] < $beforeFaceCount[0]){
			string $undo = `undoInfo -q -un`;
			undo;
			int $undoFaceCount[] = `polyEvaluate -f $mesh`;
			//<DEBUG>
			int $vertLoss = $initVertCount[0] - $afterVertCount[0];
			int $faceLoss = $beforeFaceCount[0] - $afterFaceCount[0];
			debugList($dbl, { (" - Lost Face Count: " + $afterVertCount[0]) }, $dbc, $dbm);
			debugList($dbl, { (" - Lost: " + $faceLoss + " Faces At Merge Distance: " + $d) }, $dbc, $dbm);
			debugList($dbl, { (" - Undo: " + $undo) }, $dbc, $dbm);				
			debugList($dbl, { (" - Face Count After Undo: " + $undoFaceCount[0]) }, $dbc, $dbm);
			debugList($dbl, { (" - Init Face Count: " + $initFaceCount[0]) }, $dbc, $dbm);		
			//<DEBUG>
			$ok = 0;
			break;
		} else {
			if($d < $maxD){
				$d = $d / $inc;	
				//<DEBUG>							
				int $vertLoss = $beforeVertCount[0] - $afterVertCount[0];	
				debugList($dbl, { (" - Merge Distance: " + $d) }, $dbc, $dbm);
				debugList($dbl, { (" - Vertex Count After Merge: " + $afterVertCount[0]) }, $dbc, $dbm);
				debugList($dbl, { (" - Vertices Merged This Distance: " + $vertLoss) }, $dbc, $dbm);				
				debugList($dbl, { (" ------------NEXT D------------") }, $dbc, $dbm);			
				//<DEBUG>
			} else {
				$ok = 0;
				break;
			}
		}
	}
	
	//<DEBUG>
	int $finalVertCount[] = `polyEvaluate -v $mesh`;
	int $vertLoss = $initVertCount[0] - $finalVertCount[0];
	$d = $d * $inc;	
	debugList($dbl, { (" ------------MAX--------------") }, $dbc, $dbm);
	debugList($dbl, { (" - Init Vert Count: " + $initVertCount[0]) }, $dbc, $dbm);
	debugList($dbl, { (" - Vertex Count After Merge: " + $finalVertCount[0]) }, $dbc, $dbm);
	debugList($dbl, { (" - Total Merged Vertices: " + $vertLoss) }, $dbc, $dbm);
	debugList($dbl, { (" - Merge Distance Before Losing Faces: " + $d) }, $dbc, $dbm);			
	debugList($dbl, { (" ------------END------------") }, $dbc, $dbm);	
	
	//<DEBUG>
	//select -r $sel;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         CREASES
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//CREASE EDGES ON SELECTED OBJECTS
//----------------------------------
global proc creaseEdgesOnSelectedObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		creaseObjectEdges($sel[$i]);
	}	
}

//CREASE OBJECT EDGES
//----------------------------------
global proc creaseObjectEdges( string $sel )
{
	if (`objExists $sel` == 0){ return; }
	
	select -r $sel;
	
	//loadCurrentOptions("creaseEdgesOptionsMenu");
	
	float $minAngle = `floatSliderGrp -q -v creaseEdgesMinAngleFloatSliderGrp`;
	float $maxAngle = `floatSliderGrp -q -v creaseEdgesMaxAngleFloatSliderGrp`;
	
	string $e[] = getComponentsOfTypeAtMinMaxAngle({$sel}, "edges", $minAngle, $maxAngle);
		
	if (`size $e` == 0){
		return;	
	}
	
	select -r $e;	
	
	//polySoftEdge -a 0 -ch 1;
	polyCrease -v 2;
}

//CREASE BORDER EDGES ON SELECTED OBJECTS
//----------------------------------
global proc creaseBorderEdgesOnSelectedObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		creaseObjectBorderEdges($sel[$i]);
	}	
}

//CREASE OBJECT BORDER EDGES
//-------------------------------------
global proc creaseObjectBorderEdges( string $sel )
{

	string $be[] = getComponentsOfTypeOnBorder({$sel}, "edges");
	if (`size $be` == 0){
		return ;
	}
	select -r $be;
	//polySoftEdge -a 0 -ch 1;
	polyCrease -v 2;
}

//REMOVE CREASES FROM SELECTED OBJECTS
//----------------------------------
global proc removeCreasesFromSelectedObjects(string $sel[])
{
	for($i=0;$i<`size $sel`;$i++){
		removeCreasesFromObject($sel[$i]);
	}	
}

//REMOVE CREASES OBJECT
//----------------------------------
global proc removeCreasesFromObject(string $sel)
{
	select -r $sel;
	polyCrease -op 2;

}


//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         ALIGNMENT
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//ALIGN POLY OBJECTS BY VERTICES
//---------------------------------------
global proc alignPolyObjectsByVertices(string $alignTo, string $sel[])
{
	string $f[] = getPolyComponentsInLogicalOrder({$alignTo}, "faces");
	float $fc[] = getPolyFaceCenterPosition($f[0],$alignTo);

	
}

//CENTER SELECTED VERTICES XY
//=============================================
global proc centerAllSelectedVerticesXY()
{
	string $sel[] = `ls -fl -sl`;
	for($i=0;$i<`size $sel`;$i++){
		float $trans[] = `xform -q -ws -t $sel[$i]`;
		xform -ws -t 0 $trans[1] 0 $sel[$i];
		//setAttr ($sel[$i] + ".translateX") 0;
		//setAttr ($sel[$i] + ".translateZ") 0;
	}
}

//SPLIT POLY FACE
//=======================================================================
global proc splitPolyFacesFromVertexToVertex(string $f[], string $v[])
{
	string $dbl = "-dmi SplitPolyFacesFromVertexToVertexDebugMenuItem -t Split Face From Vertex To Vertex"; string $dbm = "add"; int $dbc = 1;
	string $v[] = `ls -sl`;
	
	float $v1t[] = `xform -q -os -t $v[0]`;
	float $v2t[] = `xform -q -os -t $v[1]`;
	
	debugList($dbl, { (" - V1T: " + $v1t[0] + " " + $v1t[1] + " " + $v1t[2]) }, $dbc, $dbm);
	debugList($dbl, { (" - V2T: " + $v2t[0] + " " + $v2t[1] + " " + $v2t[2]) }, $dbc, $dbm);
	debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
	
	string $sel[] = `ls -fl -sl`;
	string $edge1 = $sel[0];
	string $edge2 = $sel[1];
	int $eid1 = getComponentId($edge1);
	int $eid2 = getComponentId($edge2);
	
	
	
	polySplit -ep $eid1 0 -ep $eid2 0 -s 2;

}

//GET ANGLES OF FACE EDGES
//===================================================================
global proc float[] getAnglesOfFaceEdges(string $f)
{
	string $dbl = "-dmi GetAnglesOfFaceEdgesDebugMenuItem -t Angles Of Face Edges"; string $dbm = "add"; int $dbc = 1;
	
	float $angles[];
	select -r $f;
	debugListString($dbl, (" - Face: " + $f), $dbc, $dbm);
	
	//Get the edges of the face
	ConvertSelectionToEdges;
	string $e[] = `ls -fl -sl`;
	debugListArray($dbl, " - Edges: ", $e, $dbc, $dbm, "", 100);
	
	float $firstDir[];
	float $lastDir[];
	float $angle;
	for($i=0;$i<`size $e`;$i++){
		//Get the direction of the edge
		float $dir[] = getDirectionOfEdge($e[$i]);
		
		debugListString($dbl, (" - Edge Direction: " + $dir[0] + " " + $dir[1] + " " + $dir[2]), $dbc, $dbm);
		
		//Save the direction for comparisons
		if(`size $lastDir` == 0){
			appendFloatArray($firstDir, $dir, `size $dir`);
			appendFloatArray($lastDir, $dir, `size $dir`);
			continue;	
		}
		
		//Get the angle
		debugListString($dbl, (" - GETTING ANGLE - "), $dbc, $dbm);
		
		$angle = getAngleBetweenDirections($lastDir, $dir);
		
		$angles[`size $angles`] = $angle;
		
		debugListString($dbl, (" 	- Edges: " + $e[$i] + " | " + $e[($i - 1)]), $dbc, $dbm);
		debugListString($dbl, (" 	- DirA: " + $lastDir[0] + " " + $lastDir[1] + " " + $lastDir[2]), $dbc, $dbm);
		debugListString($dbl, (" 	- DirB: " + $dir[0] + " " + $dir[1] + " " + $dir[2]), $dbc, $dbm);
		debugListString($dbl, (" - Angle: " + $angle), $dbc, $dbm);
		
		clear $lastDir;
		appendFloatArray($lastDir, $dir, `size $dir`);
		
		if($i < `size $e`){
			debugList($dbl, {(tslDiv("[NEXT EDGE]"))}, $dbc, $dbm);
		}
		
	}
	//Get the angle between the first and last edge
	$angle = getAngleBetweenDirections($lastDir, $firstDir);
	$angles[`size $angles`] = $angle;
	
	debugList($dbl, {(tslDiv(""))}, $dbc, $dbm);
	debugListArray($dbl, " - Angles: ", (floatArrayToStringArray($angles)), $dbc, $dbm, "", 100);
	
	float $totAngle = addAllInArray($angles);
	
	debugListString($dbl, (" - Angles Total: " + $totAngle), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	select -r $f;
	return $angles;
}

//GET DIRECTION OF EDGE
//============================================================
global proc float[] getDirectionOfEdge( string $e )
{
	select -r $e;
	ConvertSelectionToVertices;
	string $v[] = `ls -fl -sl`;
	
	//debugListArray($dbl, (" - Vertices Of Edge: " + $e[$i] + " "), $v, $dbc, $dbm, "", 100);
		
	float $vt0[] = `xform -q -ws -t $v[0]`;
	float $vt1[] = `xform -q -ws -t $v[1]`;
	
	float $dir[] = getDirectionFromTwoPoints({$vt0[0],$vt0[1],$vt0[2]}, {$vt1[0],$vt1[1],$vt1[2]});
	
	//debugListString($dbl, (" - Edge Direction: " + $dir[0] + " " + $dir[1] + " " + $dir[2]), $dbc, $dbm);
	return $dir;
}

//GET ANGLE BETWEEN DIRECTIONS
//============================================================
global proc float getAngleBetweenDirections(float $dirA[], float $dirB[])
{
	vector $va = <<$dirA[0],$dirA[1],$dirA[2]>>;
	vector $vb = <<$dirB[0],$dirB[1],$dirB[2]>>;
	float $angle = rad_to_deg(`angle $va $vb`);
	return $angle;
}

//GET ANGLE BETWEEN TWO EDGES
//============================================================
global proc float getAngleBetweenTwoEdges(string $e1, string $e2)
{
	string $dbl = "-dmi GetAngleBetweenTwoEdgesDebugMenuItem -t Angle Between Two Edges"; string $dbm = "add"; int $dbc = 1;
	string $sharedV = getVertexSharedByTwoEdges($e1, $e2);
	debugListArray($dbl, " - Edges: ", {$e1, $e2 }, $dbc, $dbm, "", 0);
	
	float $dirA[];
	float $dirB[];
	
	if(`size $sharedV` > 0){ 
		debugListArray($dbl, " - Edges Share Vertex: ", {($sharedV) }, $dbc, $dbm, "", 0);		
		
		string $ev1[] = wizConvertSelection({$e1}, "v");
		string $ev2[] = wizConvertSelection({$e2}, "v");
		
		$ev1 = stringArrayRemove({$sharedV}, $ev1);
		$ev2 = stringArrayRemove({$sharedV}, $ev2);
		
		float $svt[] = `xform -q -ws -t $sharedV`;
		float $evt1[] = `xform -q -ws -t $ev1[0]`;
		float $evt2[] = `xform -q -ws -t $ev2[0]`;
		
		$dirA = getDirectionFromTwoPoints($svt, $evt1);
		string $dirAString[] = floatArrayToStringArray($dirA);
		debugListArray($dbl, " - Edge Direction 1: ", $dirAString, $dbc, $dbm, "[NEXT]", 0);
		
		$dirB = getDirectionFromTwoPoints($svt, $evt2);
		string $dirBString[] = floatArrayToStringArray($dirB);
		debugListArray($dbl, " - Edge Direction 2: ", $dirBString, $dbc, $dbm, "[NEXT]", 0);		
		
	} else {	
		$dirA = getDirectionOfEdge($e1);
		string $dirAString[] = floatArrayToStringArray($dirA);
		debugListArray($dbl, " - Edge Direction 1: ", $dirAString, $dbc, $dbm, "[NEXT]", 0);
		
		$dirB = getDirectionOfEdge($e2);
		string $dirBString[] = floatArrayToStringArray($dirB);
		debugListArray($dbl, " - Edge Direction 2: ", $dirBString, $dbc, $dbm, "[NEXT]", 0);	
	}
	
	float $angle = getAngleBetweenDirections($dirA, $dirB);
	debugListString($dbl, (" - Angle: " + $angle), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	select -r $e1;
	select -add $e2;
	return $angle;
}

//GET VERTEX SHARED BY TWO EDGES
//==============================================================
global proc string getVertexSharedByTwoEdges(string $e1, string $e2)
{
	select -r $e1;	
	ConvertSelectionToVertices;
	string $v1[] = `ls -fl -sl`;
	
	select -r $e2;	
	ConvertSelectionToVertices;
	string $v2[] = `ls -fl -sl`;
	
	string $shared[] = intersectStringArrays($v1, $v2);
	return $shared[0];
	
}

global proc string[] getOutsideEdgesOfTwoTris(string $tri1, string $tri2)
{
	
	return { " " };
}


//SPIN EVERY OTHER EDGE
//=====================================================
global proc spinEveryOtherEdge( string $e[] )
{
	string $dbl = "-dmi SpinEveryOtherEdgeDebugMenuItem -t Spin Every Other Edge"; string $dbm = "add"; int $dbc = 1;
	
	debugListArray($dbl, " - Spin Edges: ", $e, $dbc, $dbm, "", 100);
	
	//Keep Selecting Every Other Edge - 1,3,5,7,9 ; 2,6,10 ; 4,12....
	int $si = 0; //Start Index
	int $ei = 0; //Edge Index
	int $eo = 2; //Every Other	
	int $spinCycle = 0;
	int $ok = 0;

	select -cl;
	int $skip;
	int $spinCount;
	while($ok == 0){		
		for($ei = $si;$ei<`size $e`;$ei = $ei + $eo){
			
			debugListString($dbl, ($e[$ei]), $dbc, $dbm);
			select -r $e[$ei];
			
			//Find the angle between the two outter edges
			//If the angle is greater than 180 then don't spin
						
			ConvertSelectionToVertices;
			string $ev[] = `ls -fl -sl`;
			debugListArray($dbl, (" 	- Vertices Of Edge: " + $e[$ei] + " "), $ev, $dbc, $dbm, "", 0);
				
			select -r $e[$ei];
			
			//Get the surrounding faces
			string $botf[] = `polyListComponentConversion -bo -tf`;
			select -r $botf;
			string $f[] = `ls -fl -sl`;			
			debugListArray($dbl, (" 	- Faces Surrounding Edge: " + $e[$ei] + " "), $f, $dbc, $dbm, "", 0);
			
			ConvertSelectionToVertices;
			string $fv[] = `ls -fl -sl`;
			debugListArray($dbl, (" 	- Vertices Of Surrounding Faces: " + $e[$ei] + " "), $fv, $dbc, $dbm, "", 0);
			
			string $v[] = stringArrayRemove($ev, $fv);
			select -r $v;
			debugListArray($dbl, (" 	- Vertices Parallel To Edge: " + $e[$ei] + " "), $v, $dbc, $dbm, "", 0);
			
			string $pcc[] = `polyListComponentConversion -in -te`;
			select -r $pcc;
			string $angleEdges[] = `ls -fl -sl`;
			debugListArray($dbl, (" 	- Outside Edges Of Faces: " + $e[$ei] + " "), $angleEdges, $dbc, $dbm, "", 0);
			
			float $angle;
			float $angles[];
			for($aei=0;$aei<`size $angleEdges`;$aei++){				
				$angle = getAngleBetweenTwoEdges($e[$ei], $angleEdges[$aei]);
				
				debugListString($dbl, (" - Edges: " + $e[$ei] + " | " + $angleEdges[$aei]), $dbc, $dbm);
				debugListString($dbl, (" - Angle: " + $angle), $dbc, $dbm);
				
				$angles[`size $angles`] = $angle;
			}
			float $totAngle = $angles[0] + $angles[1];
			debugListString($dbl, (" - Total Angle: " + $totAngle), $dbc, $dbm);
			
			if($totAngle > 180){
				debugListString($dbl, (tslDiv("[ANGLE OVER 180 - DO NOT SPIN]")), $dbc, $dbm);
				//continue;	
			} else {			
							
				//Spin the edge
				select -r $e[$ei];
				polySpinEdge;	
				$spinCount++;
				
				debugListString($dbl, (" - Spin Edge: " + $e[$ei]), $dbc, $dbm);
				debugList($dbl, {(tslDiv("[SPIN" + $spinCount + "]"))}, $dbc, $dbm);
				
				refreshStep();
			}
		}
		
		//Skip every other		
		if($si == 0){			
			$si = 1;
		} else {
			$si = $si * 2;	
		}
		$eo = $eo * 2;
		
		//End the cycle
		if($spinCycle == 1){				;			
			$ok = 1;	
			break;			
		}
		$spinCycle++;
		
	}
	
	debugListString($dbl, (" - Spun :" + $spinCount + " : Edges"), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END SPINNING]"))}, $dbc, $dbm);
	return;	
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         BOUNDING BOX
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//POLY FACE BOUNDING BOX
//====================================================
//GET POLY FACE BOUNDING BOX SIZE
//----------------------------------------------------
global proc float[] getPolyFaceBoundingBoxSize( string $f )
{
	string $dbl = "-dmi GetPolyFaceBoundingBoxSizeDebugMenuItem -t Face BBox Size"; string $dbm = "add"; int $dbc = 1;
	
	select -r $f;
	debugListString($dbl, (" - Face: " + $f), $dbc, $dbm);
	
	string $v[] = wizConvertSelection({$f},"v");
	debugListArray($dbl, " - Vertice Of Face: ", $v, $dbc, $dbm, "[NEXT]", 0);
	
	string $vx[] = sortByDirection($v, { 1.0, 0.0, 0.0 });
	debugListArray($dbl, " - Vertice Sorted By X Direction: ", $vx, $dbc, $dbm, "[NEXT]", 0);
	int $lastVx = (`size $vx` - 1);
	float $vxt0[] = `xform -q -ws -t $vx[0]`;
	float $vxt1[] = `xform -q -ws -t $vx[$lastVx]`;
	$vxt0 = multiplyArrays($vxt0, { 1.0, 0.0, 0.0 });
	$vxt1 = multiplyArrays($vxt1, { 1.0, 0.0, 0.0 });
	float $xSize = getDistanceBetweenPoints($vxt0, $vxt1);
	
	string $vy[] = sortByDirection($v, { 0.0, 1.0, 0.0 });
	debugListArray($dbl, " - Vertice Sorted By Y Direction: ", $vy, $dbc, $dbm, "[NEXT]", 0);
	int $lastVy = (`size $vy` - 1);
	float $vyt0[] = `xform -q -ws -t $vy[0]`;
	float $vyt1[] = `xform -q -ws -t $vy[$lastVy]`;
	$vyt0 = multiplyArrays($vyt0, { 0, 1, 0 });
	$vyt1 = multiplyArrays($vyt1, { 0, 1, 0 });
	float $ySize = getDistanceBetweenPoints($vyt0, $vyt1);
	
	string $vz[] = sortByDirection($v, { 0, 0, 1 });
	debugListArray($dbl, " - Vertice Sorted By Z Direction: ", $vz, $dbc, $dbm, "[NEXT]", 0);
	int $lastVz = (`size $vz` - 1);
	float $vzt0[] = `xform -q -ws -t $vz[0]`;
	float $vzt1[] = `xform -q -ws -t $vz[$lastVz]`;
	$vzt0 = multiplyArrays($vzt0, { 0, 0, 1 });
	$vzt1 = multiplyArrays($vzt1, { 0, 0, 1 });
	float $zSize = getDistanceBetweenPoints($vzt0, $vzt1);
	
	debugListString($dbl, (" - X Size: " + $xSize), $dbc, $dbm);
	debugListString($dbl, (" - Y Size: " + $ySize), $dbc, $dbm);
	debugListString($dbl, (" - Z Size: " + $zSize), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	float $fBBoxSize[] = { $xSize, $ySize, $zSize };
	return $fBBoxSize;	
}

//GET POLY FACE BOUNDING BOX MIN
//----------------------------------------------------
global proc float[] getPolyFaceBoundingBoxMin(string $f)
{
	string $dbl = "-dmi GetPolyFaceBoundingBoxMinDebugMenuItem -t Face BBox Min"; string $dbm = "add"; int $dbc = 1;
	select -r $f;
	float $min[];
	string $v[] = wizConvertSelection({$f},"v");
	string $vx[] = sortByDirection($v, { -1, 0, 0 });
	float $xMin[] = `xform -q -ws -t $vx[0]`;
	float $x = $xMin[0];
	
	string $vy[] = sortByDirection($v, { 0, 1, 0 });
	float $yMin[] = `xform -q -ws -t $vy[0]`;
	float $y = $yMin[1];
	
	string $vz[] = sortByDirection($v, { 0, 0, 1 });
	float $zMin[] = `xform -q -ws -t $vz[0]`;
	float $z = $zMin[2];	
	
	debugListString($dbl, (" - X Min: " + $x), $dbc, $dbm);
	debugListString($dbl, (" - Y Min: " + $y), $dbc, $dbm);
	debugListString($dbl, (" - Z Min: " + $z), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	if(`menuItem -q -cb GetPolyFaceBoundingBoxMinDebugMenuItem`){
		string $n = removeIllegalCharacters($f);
		spaceLocator -n ($n + "FaceBBoxMin") -p $x $y $z;
	}
	float $bboxMin[] = { $x, $y, $z };
	return $bboxMin;	
}

//GET POLY FACE BOUNDING BOX MAX
//----------------------------------------------------
global proc float[] getPolyFaceBoundingBoxMax(string $f)
{
	string $dbl = "-dmi GetPolyFaceBoundingBoxMaxDebugMenuItem -t Face BBox Max"; string $dbm = "add"; int $dbc = 1;
	select -r $f;
	float $min[];
	string $v[] = wizConvertSelection({$f},"v");
	string $vx[] = sortByDirection($v, { 1, 0, 0 });
	float $xMax[] = `xform -q -ws -t $vx[0]`;
	float $x = $xMax[0];
	
	string $vy[] = sortByDirection($v, { 0, -1, 0 });
	float $yMax[] = `xform -q -ws -t $vy[0]`;
	float $y = $yMax[1];
	
	string $vz[] = sortByDirection($v, { 0, 0, -1 });
	float $zMax[] = `xform -q -ws -t $vz[0]`;
	float $z = $zMax[2];	
	
	debugListString($dbl, (" - X Max: " + $x), $dbc, $dbm);
	debugListString($dbl, (" - Y Max: " + $y), $dbc, $dbm);
	debugListString($dbl, (" - Z Max: " + $z), $dbc, $dbm);
	debugList($dbl, {(tslDiv("[END]"))}, $dbc, $dbm);
	
	if(`menuItem -q -cb GetPolyFaceBoundingBoxMaxDebugMenuItem`){
		string $n = removeIllegalCharacters($f);
		spaceLocator -n ($n + "FaceBBoxMax") -p $x $y $z;
	}
	
	float $bboxMax[] = { $x, $y, $z };
	return $bboxMax;	
}

//ADD POLY PREPARED CHECK ATTR
//========================================================================
global proc addPolyPreparedCheckAttr(string $sel[])
{
	//select -r $sel;
	//string $shapes[] = `ls -sl`;
	for($i=0;$i<`size $sel`;$i++){
		addAttr -ln "polyMeshPreparedForMudbox" -at bool $sel[$i];
		setAttr ($sel[$i] + ".polyMeshPreparedForMudbox") true;
		
	}
	
}

//DELETE EXTRA VERTICES ON SELECTED
//========================================================================
global proc deleteExtraVerticesOnSelected(string $sel[])
{
	for($i=0;$i<`size $sel`;$i++){
		deleteExtraVerticesOnObject($sel[$i]);
	}

}

//DELETE EXTRA VERTICES ON OBJECT
//========================================================================
global proc deleteExtraVerticesOnObject(string $obj)
{
	string $e[] = getComponentsOfTypeOnBorder(`ls -sl`, "edge");
	InvertSelection;
	ConvertSelectionToVertices;
	doDelete;
}
//junk

/*
int $fid = getComponentId("pPlane3.f[24]");

string $v[] = `ls -sl`;

float $v1t[] = `xform -q -os -t $v[0]`;
float $v2t[] = `xform -q -os -t $v[1]`;

polySplit -ip $fid ($v2t[0] - $v1t[0]) ($v2t[0] - $v1t[0]) ($v2t[0] - $v1t[0]) -s 2;

*/

/*
string $sel[] = `ls -fl -sl`;
string $edge1 = $sel[0];
string $edge2 = $sel[1];
int $eid1 = getComponentId($edge1);
int $eid2 = getComponentId($edge2);

polySplit -ep $eid1 0 -ep $eid2 0 -s 2;
*/

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         VUE
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

/*======================| SUMMARY |===================================
	This processing terrain tiles exported from vue to clean up geometry
	
====================================================================*/
global proc processAllTerrainTilesInDirectory( string $dir )
{
	print("**********************************************************************\n");
	print("WIZ| processAllTerrainTilesInDirectory : " + $dir + " \n");	
	string $dbl = "-dmi ProcessAllTerrainTilesInDirectoryMenuItem -t ProcessAllTerrainTilesInDirectory";
	string $dbm = "add";
	int $dbc = 1;
		
	string $tileFiles[] = getAllFilesOfTypeInDirectory($dir, "obj");
	string $message = ("Found " + `size $tileFiles` + " Files\nIn : " + $dir + "\n"
	+"Press OK To Process");
	
	int $ok = wizInformationDialog("Process Vue Terrain Tiles", $message, "OK", "Cancel");
	if($ok == 0){
		return;
	}
	
	//debugListArray($dbl, " - Tile File: ", $tileFiles, $dbc, $dbm, "[NEXT]", 100);
	
	processVueTerrainTileFiles($tileFiles);	
	
}

global proc processSelectedTerrainTileObjFiles()
{
	string $tileFiles[] = wizGetMultipleFiles();
	print("**********************************************************************\n");
	print("WIZ| processSelectedTerrainTileObjFiles : " + `size $tileFiles` + " Selected To Process\n");
	string $dbl = "-dmi ProcessAllTerrainTilesInDirectoryMenuItem -t ProcessAllTerrainTilesInDirectory";
	string $dbm = "add";
	int $dbc = 1;
	
	string $message = ("Ready To Process " + `size $tileFiles` + " Terrain Tile Files\n"
	+"Press OK To Process");
	
	int $ok = wizInformationDialog("Process Vue Terrain Tiles", $message, "OK", "Cancel");
	if($ok == 0){
		return;
	}
	//debugListArray($dbl, " - Tile File: ", $tileFiles, $dbc, $dbm, "[NEXT]", 100);
	
	processVueTerrainTileFiles($tileFiles);	
}

global proc processVueTerrainTileFiles( string $tileFiles[] )
{
	
	wizProgressWindowStart("Processing Terrain Tiles", "Starting", 1);	
	wizProgressWindowMinMax(0, `size $tileFiles`);	
	
	float $processTime;
	float $startTime;
	
	for ( $i = 0; $i < `size $tileFiles`; $i++){
		//Start a new file
		file -f -new;
		
		//Time Feedback
		$startTime = `timerX`;		
		string $bn = getFileNameNoPathNoExt($tileFiles[$i]);
		string $statusMessage = (
		"Processing File : " + $bn + "\n"
		+"Estimated Time : " + ($processTime * `size $tileFiles`)
		);
		print ($statusMessage + "\n");
		wizProgressWindowStatus($statusMessage);		
		wizAddToProgressWindowStatusMessage("\n - Processing - \n");
		
		//Process the terrain tile file
		processVueTerrainTileFile($tileFiles[$i]);
		
		//Time Feedback
		if(wizProgressCancelled() == 1){ break;}
		wizProgressWindowStep(1);
		
		if($i == 0){
			$processTime = `timerX -startTime $startTime`;			
		}
		
		
	}
	
	print("WIZ| Processing Vue Terrain Tiles Complete\n");
	wizProgressWindowEnd();
	
}

/*
//PROCESS VUE TERRAIN TILE FILE
//===================================================
global proc processVueTerrainTileFile( string $file )
{

	//Get the base filename
	string $bn = basename($file, ".obj");
	//wizProgressWindowStatus(("Processing : " + $bn));
	
	//Import the file
	file -i $file;
	
	//Select the terrain tile
	select -r `listTransforms -g`;
	string $sel[] = `ls -sl`;
	
	//Remove extra polygons on sides and bottom
	if(`checkBox -q -v processVueTerrainTilesRemoveExtraSidesCheckBox`){
		removeExtraSidesFromVueTerrainMeshObjects($sel);
	}
	
	//Select all geometry transforms	
	select -r `listTransforms -g`;
	$sel = `ls -sl`;
	
	//Select the faces
	select -r $sel[0];
	ConvertSelectionToFaces;
	
	//Create UVs	
	if (`optionMenuGrp -q -v processVueTerrainTilesUVsOptionMenuGrp` == "planar"){
		polyProjection -ch 1 -type Planar -ibd off -kir -md y `ls -sl`;
	} else if (`optionMenuGrp -q -v processVueTerrainTilesUVsOptionMenuGrp` == "auto"){
		polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.1 -ws 0;
	}
	
	//Delete the history
	select -r $sel[0];
	delete -ch;	
	
	//Select all geometry transform
	select -r `listTransforms -g`;
	string $sel[] = `ls -sl`;
	
	//Assign Default Shader
	if(`checkBox -q -v processVueTerrainTilesAssignDefaultShaderCheckBox`){
		assignDefaultShaderToSelected($sel);	
	}
	
	//Rename the tile after the file name
	renameTerrainTileAfterFileName($file);
		
	//Save the file in different formats
	string $saveDir = getPathPart($file);
	string $fileName = $saveDir + "/" + $bn;
	if (`optionMenuGrp -q -v processVueTerrainTilesSaveAsOptionMenuGrp` == "mb"){	
		$fileName = $fileName + ".mb";
		file -rename $fileName;	
		file -s -typ "mayaBinary";
	} else if (`optionMenuGrp -q -v processVueTerrainTilesSaveAsOptionMenuGrp` == "obj"){
		$fileName = $fileName + ".obj";
		wizExportOBJ($fileName);
	}	
	
	print("WIZ| processVueTerrainFile : Finished Processing : " + $bn + "\n");
	
	
}
*/

//PROCESS VUE TERRAIN TILE FILE
//===================================================
global proc processVueTerrainTileFile( string $file )
{

	//Get the base filename
	string $bn = getFileNameNoPathNoExt($file);
	//wizProgressWindowStatus(("Processing : " + $bn));
	
	//Open or Import the file
	string $ext = `fileExtension $file` ;
	if ($ext != "ma" || $ext != "mb"){
		//Import the file
		file -i $file;
	} else {
		file -f -o $file;
	}
	
	
	//Select the terrain tile
	
	select -r `listTransforms "-type mesh"`;
	string $sel[] = `ls -sl`;
	
	//Rename the tile after the file name
	string $tile;
	if ($ext != "ma" || $ext != "mb"){		
		$tile = renameTerrainTileAfterFileName($file);
		select -r $tile;
	} else {
		$tile = $sel[0];
	}
	
	//Cut the edges off the tile
	if (`checkBox -q -v processVueTerrainTilesRemoveExtraSidesCheckBox`){
		prepVueTerrainTile($tile);
	}
	
	//Reduce polys
	if (`checkBox -q -v processVueTerrainTilesReducePolyCheckBox`){
		polyReduceVueTerrainTile($tile);
	}
	
	select -r $tile;
	
	//Create UVs	
	if (`checkBox -q -v processVueTerrainTilesCreateUVsCheckBox`){
		ConvertSelectionToFaces;
		string $f[] = `ls -sl`;
		polyProjection -ch 1 -type Planar -ibd off -kir  -md y  $f;
		//polyProjection -ch 1 -type Planar -ibd off -kir -md y $tile;
		/*
		if (`optionMenuGrp -q -v processVueTerrainTilesUVsOptionMenuGrp` == "planar"){
			polyProjection -ch 1 -type Planar -ibd off -kir -md y $tile;
		} else if (`optionMenuGrp -q -v processVueTerrainTilesUVsOptionMenuGrp` == "auto"){
			polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.1 -ws 0 $tile;
		}
		*/
	}
	
	//Delete the history
	select -r $tile;
	delete -ch;	
	    
	//Assign Default Shader
	if (`checkBox -q -v processVueTerrainTilesAssignDefaultShaderCheckBox`){
		assignDefaultShaderToSelected({$tile});	
		hyperShadePanelMenuCommand("hyperShadePanel1", "deleteUnusedNodes");
	}
		
	
	//Save the file in different formats
	print ("Current File Name : " + $file + "\n");
	string $saveDir = getDirectoryFromFullFilePath($file);
	print ("Save Directory : " + $saveDir + "\n");
	string $fileName = $saveDir + $bn;
	
	/*
	string $message = ("Save File : " + ($fileName + ".mb") + " : Press OK To Process");
	
	int $ok = wizInformationDialog("Save Terrain Tiles", $message, "OK", "Cancel");
	if ($ok == 0){
		return;
	}
	*/
	//Save as new file or just save the file
	if ($ext == "obj"){
		if (`optionMenuGrp -q -v processVueTerrainTilesSaveAsOptionMenuGrp` == "mb"){	
			$fileName = $fileName + ".mb";
			print ("Saving Terrain Tile File : " + $fileName + "\n");
			file -rename $fileName;	
			file -f -s -typ "mayaBinary";
		} else if (`optionMenuGrp -q -v processVueTerrainTilesSaveAsOptionMenuGrp` == "ma"){	
			$fileName = $fileName + ".ma";
			print ("Saving Terrain Tile File : " + $fileName + "\n");
			file -rename $fileName;	
			file -f -s -typ "mayaAscii";
		} else if (`optionMenuGrp -q -v processVueTerrainTilesSaveAsOptionMenuGrp` == "obj"){
			$fileName = $fileName + ".obj";
			print ("Saving Terrain Tile File : " + $fileName + "\n");
			wizExportOBJ($fileName);
		}	
	} else {
		//file -rn $bn;
		file -prompt 0 -save;
		//file -save;
	}
	
	print("WIZ| processVueTerrainFile : Finished Processing : " + $bn + "\n");
	
	
}

//POLY REDUCE VUE TERRAIN TILE
//===================================================
global proc polyReduceVueTerrainTile( string $tile )
{
	//string $tr[] = `listTransforms "-g"`;
	select -r $tile;
	delete -ch;
	int $redPer = `intSliderGrp -q -v processVueTerrainTilesPolyReductionPercentIntSliderGrp`;
	print ("WIZ| Reducing Poly Count By : " + $redPer + "% On : " + $tile);
	polyReduce -ver 1 -trm 0 -p $redPer -vct 0 -tct 0 -shp 0 -keepBorder 1 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 0 -keepCreaseEdge 0 -keepBorderWeight 1 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 1 -vertexMapName "" -replaceOriginal 1 -cachingReduce 1 $tile;
	print (" : Reduction Complete\n");
	select -r $tile;
	delete -ch;	
}

//REMOVE EXTRA SIDES FROM VUE TERRAIN MESH OBJECT
//===================================================
global proc removeExtraSidesFromVueTerrainMeshObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		removeExtraSidesFromVueTerrainMeshObject($sel[$i]);	
	}
}

global proc removeExtraSidesFromVueTerrainMeshObject( string $sel )
{
	string $dbl = "-dmi ProcessAllTerrainTilesInDirectoryMenuItem -t ProcessAllTerrainTilesInDirectory";
	string $dbm = "add";
	int $dbc = 1;
	
	float $max = `floatSliderGrp -q -v processVueTerrainTilesMaxAngleFloatSliderGrp`;
	float $normalAngle = `floatSliderGrp -q -v processVueTerrainTilesNormalAngleFloatSliderGrp`;
	//Old method
	/*
	if(`checkBox -q -v processVueTerrainTilesQuickCleanUpCheckBox` == 0){
		warning("WIZ| removeExtraSidesFromVueTerrainMeshObject : Use Quick Clean Up! Non quick clean up doesn't work yet.\n");
		polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.1 -ws 0;
		
		//int $ch = `constructionHistory -q -tgl`;
		string $obj = $sel;
		constructionHistory -tgl off;
		ConvertSelectionToFaces;
		
		polySelectConstraint -m 3 -t 0x0008 -o 1 -ob 0 $max -oa 0 1 0;	
		string $keep[] = `ls -fl -sl`;	
		//polySeparate -rs 1 -ch 1;
		InvertSelection;
		delete;	
			
		//Delete smallest shells
		select -r $sel;	
		string $shells[] = `polySeparate -rs 1 -ch 1`;
		debugListArray($dbl, " - Shells: ", $shells, $dbc, $dbm, "[NEXT]", 100);
		
		int $lastFC = 0;
		string $largest;
		for($i=0;$i<(`size $shells` - 1);$i++){
			select -r $shells[$i];
			debugList($dbl, { (" - Selected : " + $shells[$i]) }, $dbc, $dbm);
			
			int $fc[] = `polyEvaluate -f $shells[$i]`;	
			debugList($dbl, { (" - Face Count : " + $fc[0]) }, $dbc, $dbm);
			
			if($fc[0] > $lastFC){
				debugList($dbl, { (" - Face Count : " + $fc[0] + " > Last Face Count : " + $lastFC) }, $dbc, $dbm);
				debugList($dbl, { (" - Highest Face Count : " + $fc[0]) }, $dbc, $dbm);
				$largest = $shells[$i];	
			} 
			$lastFC = $fc[0];
		}
		debugList($dbl, { (" - Highest Face Count Object: " + $largest) }, $dbc, $dbm);
		
		for($i=0;$i<`size $shells`;$i++){
			if($shells[$i] != $largest){
				delete $shells[$i];	
			}
		}
		
		//string $newSel = getObjectFromComponent($largest);
		select -r $largest;
		//Unlock normals
		polyNormalPerVertex -ufn true;
		polySoftEdge -angle $normalAngle -ch 1;
		delete -ch $largest;
		
	} else {
				
		//Method2
		float $max = `floatSliderGrp -q -v processVueTerrainTilesMaxAngleFloatSliderGrp`;
		string $f[];
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0.0,-1.0,0.0} , ($max * 2.0));
		print("WIZ| deleting " + `size $f` + " Faces \n");
		delete $f;		
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {-1,0,0} , $max);
		print("WIZ| deleting " + `size $f` + " Faces \n");
		delete $f;		
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {1,0,0} , $max);
		delete $f;
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0,0,-1} , $max);
		delete $f;
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0,0,1} , $max);
		delete $f;
		//delete -ch $sel;
		
		//Delete History
		select -r $sel;
		delete -ch $sel;
		
		//Unlock normals
		polyNormalPerVertex -ufn true;
		polySoftEdge -angle $normalAngle -ch 1;
		
		//Delete History Again
		delete -ch $sel;
	}
	*/
	
	string $obj = $sel;
	constructionHistory -tgl off;
			
	//Method1
	/*
	ConvertSelectionToFaces;
	
	//Select only the faces in the positive y direction
	polySelectConstraint -m 3 -t 0x0008 -o 1 -ob 0 $max -oa 0 1 0;	
	string $keep[] = `ls -fl -sl`;	
	
	//Delete extra faces
	InvertSelection;
	delete;		
	*/
	
	//Method2
	float $max = `floatSliderGrp -q -v processVueTerrainTilesMaxAngleFloatSliderGrp`;
	
	string $f[];
	if (`checkBox -q -v processVueTerrainTilesRemoveBottomSideOnlyCheckBox`){
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0.0,-1.0,0.0} , ($max * 2.0));
		print("WIZ| deleting " + `size $f` + " Faces \n");
		delete $f;		
		//delete -ch $sel;
	
	} else {
		/*
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0.0,-1.0,0.0} , ($max * 2.0));
		print("WIZ| deleting " + `size $f` + " Faces \n");
		delete $f;		
		//delete -ch $sel;
		*/
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {-1.0,0.0,0.0} , $max);
		print("WIZ| deleting " + `size $f` + " Faces \n");
		delete $f;		
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {1.0,0.0,0.0} , $max);
		delete $f;
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0.0,0.0,-1.0} , $max);
		delete $f;
		//delete -ch $sel;
		
		select -r $obj;
		$f = getComponentsOnBoundingBoxSide({$obj}, "face", {0.0,0.0,1.0} , $max);
		delete $f;
		//delete -ch $sel;
	
	}
	
	//Delete History
	select -r $sel;
	delete -ch $sel;
	
	//Unlock normals
	polyNormalPerVertex -ufn true;
	polySoftEdge -angle $normalAngle -ch 1;
	
	//Delete History Again
	delete -ch $sel;
		
	polySelectConstraint -dis;
	constructionHistory -tgl on;
	
}

//PREP VUE TERRAIN TILES
//======================================================
global proc prepVueTerrainTiles( string $sel[] )
{
    for ($i=0;$i<`size $sel`;$i++){
        prepVueTerrainTile($sel[$i]);
    }
}

//PREP VUE TERRAIN TILE
//======================================================
//This is another attempt to process terrain tiles
//Used for Europa terrain tiles
global proc prepVueTerrainTile( string $sel )
{
    floatSliderGrp -e -v 1 processVueTerrainTilesMaxAngleFloatSliderGrp;
	
    removeExtraSidesFromVueTerrainMeshObject($sel);
    select -r $sel;
    string $borderEdges[] = getComponentsOfTypeOnBorder({$sel}, "e");
    ConvertSelectionToFaces;
    GrowPolygonSelectionRegion;
    string $delFaces[] = `ls -sl`;
    delete $delFaces;
    
    select -r $sel;
    
    string $e[];
    string $edgeCurve[];
    $e = getComponentsOnBoundingBoxSide({$sel}, "e", {-1.0,0.0,0.0} , 0.1);
    $edgeCurve = createCurveFromPolyEdge($e);
    rename $edgeCurve[0] ("Left_Edge" + $sel + "Curve1");
    if (`checkBox -q -v processVueTerrainTilesRemoveBottomSideOnlyCheckBox`){
    	 return;   
    }
    select -r $sel;
    $e = getComponentsOnBoundingBoxSide({$sel}, "e", {1.0,0.0,0.0} , 0.1);
    $edgeCurve = createCurveFromPolyEdge($e);
    rename $edgeCurve[0] ("Right_Edge" + $sel + "Curve1");
    
    select -r $sel;
    $e = getComponentsOnBoundingBoxSide({$sel}, "e", {0.0,0.0,-1.0} , 0.1);
    $edgeCurve = createCurveFromPolyEdge($e);
    rename $edgeCurve[0] ("Front_Edge" + $sel + "Curve1");
    
    select -r $sel;
    $e = getComponentsOnBoundingBoxSide({$sel}, "e", {0.0,0.0,1.0} , 0.1);
    $edgeCurve = createCurveFromPolyEdge($e);
    rename $edgeCurve[0] ("Back_Edge" + $sel + "Curve1");
    
    string $curves[] = `ls -type nurbsCurve`;
    select -r $sel;
    select -add $curves;
    string $all[] = `ls -sl`;
    group -n ($sel + "Group1") -r $all;
    
}

/*
global proc getTerrainTilesInProcessingOrder()
{
    string $tiles[] = `ls -tr ("*TerrainTile*")`;
    string $numSort[];
    for ($i=0;$i<`size $tiles`;$i++){
        string $numbers = `match "[0-9]+" $tiles[$i]`;
        $numSort[$i] = $numbers;
        
    }
    sort($numSort);
    
}
*/


global proc loftTerrainTileEdgeCurves()
{    
/*
    string $mesh[] = `listTransforms "-type mesh"`;
    print ("Meshes : \n - " + stringArrayToString($mesh, "\n - ") + "\n");
    string $groups[] = `listRelatives -p $mesh`;
    print ("Groups : \n - " + stringArrayToString($groups, "\n - ") + "\n");
    string $sel[] = sort($mesh);
    print ("Sorted Meshes : \n - " + stringArrayToString($sel, "\n - ") + "\n");
    int $sizeSel = `size $sel`;
    
    int $sqrt = int(`sqrt $sizeSel`);
    
    for ($i=0;$<`size $sel`;$i++){
        string $rel[] = `listRelatives -typ transform $groups[$i]`;
        string $left[] = `ls ("*Left*") $rel`;
        string $rel[] = `listRelatives -typ transform $sel[$i]`;
    }
    */
}


global proc renameTerrainTilesAfterFileNames()
{
	print("WIZ| renameTerrainTilesAfterFileNames : STARTING\n");
	string $files[] = wizGetMultipleFiles();
	for($i=0;$i<`size $files`;$i++){
		renameTerrainTilesAfterFileName($files[$i]);
	}
	print("WIZ| renameTerrainTilesAfterFileNames : COMPLETE\n");
}

global proc renameTerrainTilesAfterFileName( string $file )
{
	file -f -o $file;
	renameTerrainTileAfterFileName($file);
	
	file -s;
}

global proc string renameTerrainTileAfterFileName( string $file)
{
	string $ext = `fileExtension $file` ;
	string $bn = basename($file, $ext);
		
	select -r `listTransforms "-type mesh"`;
	string $sel[] = `ls -sl`;
	string $nn = removeIllegalCharacters($bn);
	$nn = removeSpecialCharacters($nn);
	string $newName = `rename -is $sel[0] $nn`;
	return $newName;
}

global proc terrainHeightShrinkwrap(float $_moveStep  , float $_distance , int $inOut )
{

	string $piuMeno = "" ;
	
	if ($inOut==1) //inward 
		$piuMeno = "-" ;
	
	
	
	string $sel[] = `ls -sl -tr ` ;
	
	string $trgt = $sel[0] ;
	string $trgtShap[] = `listRelatives -s $trgt` ;
	string $cloth = $sel[1] ;
	if ( `objExists CPOM ` ) {
		disconnectAttr  ($trgtShap[0]+".worldMesh[0]") CPOM.inMesh;
		disconnectAttr  CPOM.position DISTBTW.point1; // calcoloo le distanze 
		disconnectAttr  CPOM.inPosition DISTBTW.point2; // calcoloo le distanze 
		delete "CPOM" "DISTBTW";
	}
	
	createNode closestPointOnMesh -n "CPOM"; 
	createNode distanceBetween -n "DISTBTW" ;
	connectAttr -f ($trgtShap[0]+".worldMesh[0]") CPOM.inMesh;
	
	int $numVert[] = `polyEvaluate -v $cloth` ;
	connectAttr -f CPOM.position DISTBTW.point1; // calcoloo le distanze 
	connectAttr -f CPOM.inPosition DISTBTW.point2; // calcoloo le distanze 
	select - cl ; 
	
	for ($i = 0 ; $i < $numVert[0] ; $i ++) { //PER OGNI VERTICE 
		string $thisVtx = ( $cloth +".vtx["  +$i+ "]" );
		float $pos[3]= `pointPosition -w $thisVtx`; 
		//setAttr   CPOM.inPositionX  $pos[0];
		setAttr   CPOM.inPositionY  $pos[1];	
		//setAttr   CPOM.inPositionZ  $pos[2];	
		
		float $dist = (`getAttr "DISTBTW.distance"`);
		if (  $dist  > $_distance )
		select -tgl $thisVtx;	 
	}	
	if ( size(`ls -sl -fl`)==0) error "no more vertices will be moved " ;
	
	// a questo punto ho tutti i vertici da spostare selezionati 
	$numVert[0] = size(`ls -sl -fl`);
	string $comando = "moveVertexAlongDirection " ;
	for ($i = 0 ; $i < $numVert[0] ; $i ++) { //PER OGNI VERTICE 
		$comando += ( " -n "+ $piuMeno +$_moveStep ) ;
	}// a questo punto ho scritto il comando 
	eval ($comando) ;
	select -r $sel;
	
}

global proc terrainShrinkWrapWindow()
{
	if (( `window -ex terrainShrinkWrapWin` ) == true)
			 deleteUI terrainShrinkWrapWin;
	window
		-t "Terrain Srink Wrap"
		-w 420 
		-h 250	
		-s true 
		terrainShrinkWrapWin
		;
		
	frameLayout
		-label "Setup"
		-labelAlign "top"
		-borderStyle "in"
		;
	
	columnLayout;
	
	text -l "" ;
	text -l " select the surface to be wrapped and then the surface that will wrap" ;
	text -l "" ;
	separator -height 10 -style "singleDash";
	
	floatSliderGrp
		-label "Distance"
		-field true
		-minValue 0
		-maxValue 10.0
		-fieldMinValue -100.0
		-fieldMaxValue 100.0
		-value .1
		-s .02 
		terrainShrinkWrapDistanceSlider
		;
		
	floatSliderGrp
		-label "Step Size"
		-field true
		-minValue 0
		-maxValue 10.0
		-fieldMinValue -100.0 
		-fieldMaxValue 100.0
		-value 1 
		-s .1 
		terrainShrinkWrapStepSlider
		;
	
	
	text -l "" ;
	string $group1 = `radioButtonGrp -numberOfRadioButtons 2
		-label "Normal direction"
		-labelArray2 "Inward" "Outward"
		-sl 1
		terrainHeightShrinkWrapDirectionRadioButtonGroup
		`;
	
	string $command = ("terrainHeightShrinkwrap(`floatSliderGrp  -q -v terrainShrinkWrapStepSlider` ,  ` floatSliderGrp  -q -v terrainShrinkWrapDistanceSlider`,`radioButtonGrp -q - sl $group1`);") ;
	
	text -l "" ;
	
	button -l " GO ONE STEP ->" -c ("terrainHeightShrinkwrap(`floatSliderGrp -q -v terrainShrinkWrapStepSlider`,  `floatSliderGrp -q -v terrainShrinkWrapDistanceSlider`, `radioButtonGrp -q -sl terrainHeightShrinkWrapDirectionRadioButtonGroup`);") ;

	setParent ..;
	
	showWindow terrainShrinkWrapWin;
	
}

global proc bridgeSelectedTerrainTileEdges( string $sel[] )
{
	
	//for ($i=0;$i<`size $sel`;$i++){
	//	bridgeTerrainTileEdges($sel[$i]);
	//}
}

global proc bridgeTerrainTileEdges( string $sel[] )
{
	/*
		Select the edges of one side
			Get border edges, then select edges near bounding box, then intersect array
		Create a curve from the edges
		
		Do same for next tile
		Loft both curves
	*/

	float $max = `floatSliderGrp -q -v processVueTerrainTilesEdgeSelectionSizeFloatSliderGrp`;
	
	/*
	string $e[];
	
	for ($i=0;$i<`size $sel`;$i++){
		select -r $sel[$i];
		$e = getComponentsOnBoundingBoxSide({$sel[$i]}, "edge", {-1.0,0.0,0.0} , $max);
		
		string $edgeCurves[] = createCurveFromPolyEdge($e);
	
		
		select -r $sel[$i];
		$f = getComponentsOnBoundingBoxSide({$sel[$i]}, "face", {1.0,0.0,0.0} , $max);
	
		
		select -r $sel[$i];
		$f = getComponentsOnBoundingBoxSide({$sel[$i]}, "face", {0.0,0.0,-1.0} , $max);
		
		select -r $sel[$i];
		$f = getComponentsOnBoundingBoxSide({$sel[$i]}, "face", {0.0,0.0,1.0} , $max);

	}
	*/
}
	
//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                     DELETE EXTRA MESH NODES
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//@ DELETE EXTRA MESH NODES ON SELECTED OBJECTS
//===================================================================
global proc deleteExtraMeshNodesOnSelectedObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		deleteExtraMeshNodesOnSelectedObject($sel[$i]);
	}
}

//@ DELETE EXTRA MESH NODES ON SELECTED OBJECT
//===================================================================
global proc deleteExtraMeshNodesOnSelectedObject( string $sel )
{
	string $meshShapes[] = `listRelatives -typ mesh -f $sel`;
	if (`size $meshShapes` < 2){
		print ("WIZ| deleteExtraMeshNodesOnSelectedObject : " + $sel + " Does Not Have Extra Mesh Nodes\n");
		return;
	}
	print ("WIZ| deleteExtraMeshNodesOnSelectedObject : Found : " + `size $meshShapes` + " Mesh Nodes Connected To : " + $sel + "\n");
	print ("	- " + stringArrayToString($meshShapes, "\n	- ") + "\n");
	string $del[];
	int $intObj = 0;
	print (wizDiv("s") + "\n");
	for ($i=0;$i<`size $meshShapes`;$i++){

		if (`gmatch $meshShapes[$i] "*outputCloth*"`){
			string $cloth[] = `listConnections -type nCloth $meshShapes[$i]`;
			if (`size $cloth` == 0){
				$del[`size $del`] = $meshShapes[$i];
				if ($i == (`size $meshShapes` - 1)){
					break;	
				}
				continue;
			}
		}
		//print ("IntObj: " + $intObj + "\n");
		string $isIO = $meshShapes[$i];

		int $objIO;
		if (catchQuiet($objIO == `getAttr ($meshShapes[$i] + ".intermediateObject")`) == 1){ 
		   // print ("is io\n");
		   	int $objIOArr[] = `getAttr ($meshShapes[$i] + ".intermediateObject")`;
		   	$intObj = $objIOArr[0];
		} else {
			$intObj = `getAttr ($isIO + ".intermediateObject")`;
		}

		print ($meshShapes[$i] + " : Intermediate Object : " + boolToString($intObj) + "\n");
		//print ("int $assHole = `getAttr " + $isIO + ".intermediateObject`; print (\"AssHole: \" + $assHole + \"\\n\");" + "\n");
		if ($intObj == 1){
			//if ($i == (`size $meshShapes` - 1)){
			//	break;	
			//}
			select -r $meshShapes[$i];
			setAttr ($meshShapes[$i] + ".intermediateObject") 0;
			
			$del[`size $del`] = $meshShapes[$i];
			print (" - Delete : " + $meshShapes[$i] + "\n");
		}
	}
	select -r $del;
	delete $del;
	print (wizDiv("end") + "\n");
}



//DELETE SELECTED EDGES AND VERTICES
//==================================================
/*
	USAGE:
	Given a selection of either vertices or edges
	this will select both the vertices and the edges and delete
*/
global proc deleteSelectedEdgesAndVertices( string $sel[] )
{
	//Edges must be deleted before vertices.
	if (`size $sel` == 0){
		$sel = `ls -fl -sl`;
	}
	string $curSelType = getComponentSelectionType($sel[0]);
	string $other[];
	if ($curSelType == "v"){
		$other = wizConvertSelection($sel, "e");
		select -r $other;
		delete $other;
		select -r $sel;
		delete $sel;
	} else if ($curSelType == "e"){
		$other = wizConvertSelection($sel, "vtx");
		select -r $sel;
		delete $sel;
		select -r $other;
		delete $other;
	}

}

// WIZ POLY REDUCE ALL
//==========================================
global proc wizPolyReduceAll()
{
	string $all[] = `ls -ni -typ mesh`;
	//string $all[] = `listTransforms "-typ mesh"`;
	
	stringArrayRemoveDuplicates($all);
	if (`size $all` < 100){
		print ("Reducing Meshes : \n - " + wizDiv("s") + stringArrayToString($all, "\n - ") + "\n");
	}
    for ($i=0;$i<`size $all`;$i++){
		wizPolyReduce($all[$i]);
	}
}

// WIZ POLY REDUCE
//==========================================
global proc wizPolyReduce( string $sel )
{
	float $p = `floatSliderGrp -q -v polyWizReductionPercentFloatSliderGrp`;
	polyReduce -ver 1 -trm 0 -p $p -vct 0 -tct 0 -shp 1 -keepBorder 1 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 0 -keepCreaseEdge 0 -keepBorderWeight 1 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 1 -vertexMapName "" -replaceOriginal 1 -cachingReduce 1 -ch 1 $sel;
}

//@ MAKE LOW RES NO HISTORY COPY
//====================================================================
global proc makeLowResNoHistoryCopy()
{
	//importAllReferences();
	print ("Making Low Res No History Copy\n");
	string $all[] = `ls -typ mesh`;
    $all = getObjectsWithWizTags("-sel -lowResCopy");

    makeLowResNoHistoryCopyOfSelected($all);
	
	global string $WIZ_subFileFolderSuffix;
	string $sceneFile = `file -q -sn` ;
	string $fileSplice[] = wizSpliceFilePath($sceneFile, "-dir -ffn -fn");
	string $lrDir = $fileSplice[0] + $fileSplice[2] + $WIZ_subFileFolderSuffix + "/";
    string $makeDir = wizMakeDir($lrDir);
	if ($makeDir == ""){
		print ("WIZ| makeLowResNoHistoryCopy : Counld Not Make Directory : " + $lrDir + "\n");
		return;
	}
    
	string $copyName = $lrDir + $fileSplice[1];
    print ("New Low Res File : " + $copyName + "\n");
	file -rename $copyName;
	file -f -save;
	
	autoSaveSceneThumbnailImage();
	
	
}

//@ MAKE LOW RES COPY LOD GROUP
//====================================================================
global proc makeLowResCopyLODGroup( string $sel[] )
{
    for ($i=0;$i<`size $sel`;$i++){	
        string $dup[] = `duplicate -rr -renameChildren $sel[$i]`;
		wizPolyReduce($dup[0]);
		delete -ch $dup[0];
        createBoundingBoxProxyLODGroupForSelected({ $sel[$i], $dup[0] });
        
	}
}

//@ MAKE LOW RES NO HISTORY COPY OF SELECTED
//====================================================================
global proc makeLowResNoHistoryCopyOfSelected( string $sel[] )
{
    for ($i=0;$i<`size $sel`;$i++){	
        string $dup[] = `duplicate -rr -renameChildren $sel[$i]`;
        hide $sel[$i];
		wizPolyReduce($dup[0]);
		delete -ch $dup[0];
        
	}
}


//@ EXPORT NO HISTORY LOD GROUPED COPY OF SELECTED
//====================================================================
/*======================| SUMMARY |===================================
    This will create copies of the selected geometry and then 
    poly reduce one copy, then create LOD proxy groups and then export
    the copies.
/*=======================| USAGE |====================================	

====================================================================*/

global proc exportNoHistoryLODGroupedCopyOfSelected( string $sel[] )
{
    string $exportObj[] ;
    for ($i=0;$i<`size $sel`;$i++){	
        string $dup[] = `duplicate -rr -renameChildren $sel[$i]`;
        string $lrdup[] = `duplicate -rr -renameChildren $sel[$i]`;
		wizPolyReduce($lrdup[0]);
		delete -ch $dup[0];
        //$dup[0] = renameWizRenameObject($dup[0], ($dup[0]);
        createBoundingBoxProxyLODGroupForSelected({ $dup[0], $lrdup[0] });
        
        $exportObj[`size $exportObj`] = $dup[0];
        $exportObj[`size $exportObj`] = $lrdup[0];
        
	}
    string $filePathSplice[] = wizSpliceFilePath(`file -q -sn`, "-fn -dir -ex");
      
    string $exportGroup = `group -n $filePathSplice[0] -w $exportObj`;
    select -r $exportGroup;
    string $exportName;
    int $v = getLatestFileVersionNumber($exportName);
    $exportName = $filePathSplice[1] + $filePathSplice[0] + "Obj" + "." + $filePathSplice[2];
    int $v = getLatestFileVersionNumber($exportName);
    
    global string $WIZ_subFileFolderSuffix;
    string $newDir = wizMakeDir(($filePathSplice[1] + $filePathSplice[0] + $WIZ_subFileFolderSuffix + "/"));
    if ($newDir == ""){ return;}
    $exportName = $newDir + $filePathSplice[0] + "Obj" + $v + "." + $filePathSplice[2];
    
    print ("Exporting : " + $exportGroup + " : To File : " + $exportName + "\n");
    file -force -options "v=0;" -typ "mayaBinary" -es $exportName;

}

global proc autoExportNoHisLODGrpCopyOfSel()
{
    print ("Making Low Res No History Copy\n");
	string $all[];
    $all = getObjectsWithWizTags("-all -lowResCopy");
    if (`size $all` == 0){
        print ("Could Not Find Any Objects With the -lowResCopy Tag\n");
        return;
    }
    exportNoHistoryLODGroupedCopyOfSelected($all);
    

}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                     ENABLE DISABLE ALL INPUTS
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

/*======================| SUMMARY |===================================
    This disables all the input on selected geometry.
    Useful if you don't want things like deformers to evaluate.
    You can enable the inputs on a referenced file, then when it's loaded,
    disable the inputs so that you don't evaluate the deformers and such
    if not needed. Speeds things up drastically.
/*=======================| USAGE |====================================	
    string $sel[] = `ls -type mesh -type nurbsSurface`;
    disableAllInputsOnSelectedGeometry($sel);
====================================================================*/

//@ ENABLE THEN DISABLE ALL INPUTS ON SELECTED GEOMETRY
//====================================================================
global proc enableThenDisableAllInputsOnSelectedGeometry( string $sel[] )
{
    printNiceArrayList("Enabling Then Disabling All Inputs Of Geometry : ", $sel);
    enableAllInputsOnSelectedGeometry($sel);
    disableAllInputsOnSelectedGeometry($sel);
}

//@ DISABLE ALL INPUTS ON SELECTED GEOMETRY
//====================================================================
/*****************************************************************//**
*	Disables all inputs on selected objects.
*	More information.
*	USAGE : 
*
*********************************************************************/
global proc disableAllInputsOnSelectedGeometry( string $sel[] )
{
    for ($i=0;$i<`size $sel`;$i++){
        string $con[] = `listConnections -c off -s on -d on $sel[$i]`;
        string $def[] = `findRelatedDeformer $sel[$i]`;
        appendStringArray($con, $def, `size $def`);
		string $listed = stringArrayToString($con, " ");
        disableAllListed $listed;

		//<!ToDoWiz> - finish this
		/*
		string $qc[] = wizMGMT("-q enableInputs","");
		if (`size $qc` == 0){
			scriptJob -ro -e 
		}
		wizMGMT("-qc enableInputs", ("enableAllListed " + $listed + ";"));
		*/
    }
}

//@ ENABLE ALL INPUTS ON SELECTED GEOMETRY
//====================================================================
/*======================| SUMMARY |===================================
    This enables all the input on selected geometry.
    You can enable the inputs on a referenced file, then when it's loaded,
    disable the inputs so that you don't evaluate the deformers and such
    if not needed. Speeds things up drastically.
    
/*=======================| USAGE |====================================	
    string $sel[] = `ls -type mesh -type nurbsSurface`;
    enableAllInputsOnSelectedGeometry($sel);
====================================================================*/

global proc enableAllInputsOnSelectedGeometry( string $sel[] )
{
    for ($i=0;$i<`size $sel`;$i++){
        string $con[] = `listConnections -c off -s on -d on $sel[$i]`;
        string $def[] = `findRelatedDeformer $sel[$i]`;
        appendStringArray($con, $def, `size $def`);
        enableAllListed (stringArrayToString($con, " "));
    }
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         AREA OF POLY
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//@ AREA OF POLYGON
//====================================================================
/*======================| SUMMARY |===================================
    Computes the area of selected faces
    Uses areaOfTriangle for each triangle to do the actual computation
/*=======================| USAGE |====================================	
    string $f[] = `ls -sl`; // A selection of faces
    float $area = areaOfPolygon($f[0]);
====================================================================*/
global proc float areaOfPolygon( string $mf )
{
    if ($mf == ""){ warning ("Mesh Face is Null\n");}
    string $tf = getObjectFromComponent({$mf});
    string $r[] = `listRelatives -c $tf`;
    string $mesh = $r[0];
   // string $mesh = getObjectFromComponent({$mf});
    //print ("Area Of Polygon : Mesh : " + $mesh + "\n");
    float $area;
    
    select -r $mf;
    
    string $vertIndicesStr[] = `polyInfo -fv`;

    // place the indices into an array
    string $vertIndices[];
    tokenize $vertIndicesStr[0] $vertIndices;

    // note the vert count for the polygon
    int $vertCount = `size($vertIndices)` - 2;

    // calculate the area based on polygon type

    // triangle
    if ($vertCount == 3) {
        string $triangle[3] = {$vertIndices[2], $vertIndices[3], $vertIndices[4]};

        $area = areaOfTriangle($mesh, $triangle);
    } else if ($vertCount == 4) {
        // quad (decompose into two triangles)
        string $triangle1[3] = {$vertIndices[2], $vertIndices[3], $vertIndices[4]};
        string $triangle2[3] = {$vertIndices[2], $vertIndices[4], $vertIndices[5]};

        $area = areaOfTriangle($mesh, $triangle1) + areaOfTriangle($mesh, $triangle2);
    } else {
        // n-gon (decompose into n - 2 triangles where n = # of verts)
        int $i;
        for ($i=0; $i < $vertCount-2; $i++) { 
            string $triangle[3] = {$vertIndices[2], $vertIndices[$i+3], $vertIndices[$i+4]};

            $area += areaOfTriangle($mesh, $triangle);
        }
    }

    return $area;
}

//@ AREA OF TRIANGLE 
//-------------------------------------------------------
global proc float areaOfTriangle( string $mesh, string $vertIndices[] )
{
    vector $verts[3];

    if (`objExists $mesh` == 0){
        warning ($mesh + " Does Not Exist!\n");
        return 0;
    }
    // get the transform node for the mesh
    string $transform[] = `listRelatives -p $mesh`;
    if (`objExists $transform[0]` == 0){
        warning ($transform[0] + " Does Not Exist!\n");
        return 0;
    }
    
    // query the matrix transform
    float $transformMatrix[] = `xform -q -ws -m $transform[0]`;

    int $i;
    for ($i=0; $i<3; $i++) {
        // vert pos with tweaks
        vector $vert = `getAttr ($mesh+".vt["+ $vertIndices[$i] +"]")`;
        vector $offset = `getAttr ($mesh+".pt["+ $vertIndices[$i] +"]")`;
        $vert = $vert + $offset;

        // apply the transform matrix to the point
        float $v[] = pointMatrixMult($vert, $transformMatrix);
        $verts[$i] = <<$v[0], $v[1], $v[2]>>;
    }

    // calculate the area using the cross product of vectors
    vector $v1 = $verts[1] - $verts[0];
    vector $v2 = $verts[2] - $verts[0];
    return abs(cross($v1, $v2)) / 2;
}

//@ GET BOUNDING BOX CENTER OF SELECTED COMPONENTS
//====================================================================
global proc float[] getBoundingBoxCenterOfSelectedComponents()
{    
    float $bc[] = `polyEvaluate -bc`;    
    float $bbcenter[] = getMidpointBetweenPoints({ $bc[0], $bc[2], $bc[4] }, { $bc[1], $bc[3], $bc[5] });
    return $bbcenter;
    
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                       AREA OF POLYGON FACES
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
/*======================| SUMMARY |===================================
	getAreaOfPolygonFaceSet : This is slow but get's the real area
/*=======================| USAGE |====================================	
	string $sel[] = `ls -sl`;
	getAreaOfPolygonFaceSet($sel[0]);
====================================================================*/
global proc float getAreaOfPolygonFaceSet( string $fs )
{
	string $return[];
	
	string $sel[] = `sets -q $fs`;	
    string $obj = getObjectFromComponent($sel);
	
	float $polyArea;
	
    for ($i=0;$i<`size $sel`;$i++){
        select -r $sel[$i];
        float $area = areaOfPolygon($sel[$i]);
		$polyArea = $polyArea + $area;
        //print ("Faces : " + $sel[$i] + " Area : " + $area + "\n");

    }
	
    return $polyArea;
}

/*======================| SUMMARY |===================================
    Must not be given flat selection, has to be like { mesh.f[20:40], mesh.f[50:60] }
    
/*=======================| USAGE |====================================	

====================================================================*/
//@ GET POLY AREAS GREATER THAN
//====================================================================
global proc string[] getPolyAreasGreaterThan( string $sel[] , float $minArea )
{

    string $return[];
    string $obj = getObjectFromComponent($sel);
	//float $polyArea;
    for ($i=0;$i<`size $sel`;$i++){
        select -r $sel[$i];
        float $area = areaOfPolygon($sel[$i]);
		//$polyArea = $polyArea + $area;
        print ("Faces : " + $sel[$i] + " Area : " + $area + "\n");
        if ($area > $minArea ){
            $return[`size $return`] = $sel[$i];
        }
    }
	//if ($polyArea > $minArea ){
	//	$return[`size $return`] = $sel[$i];
	//}
    return $return;
}

/*======================| SUMMARY |===================================
	This method is faster than getting the area of every face, but
	not as accurate.
/*=======================| USAGE |====================================	
string $sel[] = `ls -sl`;
getPolyShellSetAreasGreaterThan(`ls -sl`, 1);
====================================================================*/
global proc string[] getPolyShellSetAreasGreaterThan( string $shellSet[] , float $minArea )
{
	string $return[];
	string $sel[] = `sets -q $shellSet[0]`;	
    //string $obj = getObjectFromComponent($sel);

    for ($i=0;$i<`size $shellSet`;$i++){
        select -r $shellSet[$i];
		refresh -f;
        float $bc[] = `polyEvaluate -bc`;
		/************ IMPORTANT **********************************************
		This is not really getting the area.. just the distance between the 
		bounding box min and max. 
		It's faster though...
		*********************************************************************/
		float $dis = getDistanceBetween({ $bc[0], $bc[2], $bc[4]}, { $bc[1], $bc[3], $bc[5]});
		$dis = $dis * 3;
		printNiceFloatArrayList("polyEvaluate -b : ", $bc);
        print ("Shell Set Area : " + $dis + "\n");
        if ($dis > $minArea ){
            $return[`size $return`] = $shellSet[$i];
        }
    }

    return $return;

}


global proc string[] getPolyShellSetsWithFaceCountGreaterThan( string $shellSet[], float $minArea )
{
	string $return[];
	for ($i=0;$i<`size $shellSet`;$i++){		
		select -r $shellSet[$i];
		string $sel[] = `ls -fl -sl`;
		int $setSize = `size $sel`;
		//int $setSize = `sets -q -s $shellSet[$i]`;
		//print ("Set Size : " + $setSize + "\n");
		if ($setSize > $minArea){
			
			$return[`size $return`] = $shellSet[$i];
		}
		
	}
	return $return;
	
}

global proc string[] getPolyShellSetsWithinHeightRange( string $shellSet[], float $minHeight, float $maxHeight )
{
	string $return[];
	for ($i=0;$i<`size $shellSet`;$i++){		
		select -r $shellSet[$i];
		string $sel[] = `ls -fl -sl`;
		float $bc[] = `polyEvaluate -bc $sel[$i]`;
		float $center[] = getMidpointBetweenPoints({ $bc[0], $bc[2], $bc[4] }, { $bc[1], $bc[3], $bc[5] } );
		//printNiceArrayList(" - Get Height Of Face Selection : ", (floatArrayToStringArray($center)));
		
		//print ("if ( " + $center[1] + " >= " + $minHeight + " && " + $center[1] + " <= " + $maxHeight + " )" + "\n");
		// <!ToDoWiz> This only gets absolute height, make this work for relative height.
		if ($center[1] >= $minHeight && $center[1] <= $maxHeight){
			//print (" - " + $shellSet[$i] + " Is Within Height Range : " + $minHeight + " - " + $maxHeight + "\n");
			
			$return[`size $return`] = $shellSet[$i];	
		}
		
	}
	return $return;
}


//@ GET BOUDING BOX AREA OF SELECTED COMPONENTS
//====================================================================
/*****************************************************************//**
	Gets an estimated area of components that are selected.
	<hr>
	<b>Synopsis</b><br>
	getBoudingBoxAreaOfSelectedComponents [-fa string] [-fb linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	none
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	float $area = getBoudingBoxAreaOfSelectedComponents();
	
	</code>
*********************************************************************/
global proc float getBoudingBoxAreaOfSelectedComponents()
{
	float $bc[] = `polyEvaluate -bc`;
	/************ IMPORTANT **********************************************
	This is not really getting the area.. just the distance between the 
	bounding box min and max. 
	It's faster though...
	*********************************************************************/
	float $dis = getDistanceBetween({ $bc[0], $bc[2], $bc[4]}, { $bc[1], $bc[3], $bc[5]});
	$dis = $dis * 3;
	return $dis;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         POLY COUNT WARNING
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================


//@ WIZ HIGH POLY COUNT WARNING
//====================================================================
/*****************************************************************//**
	This will alert the user that there is a high poly count 
	and may want to lower the poly count before continueing.
	<hr>
	<b>Synopsis</b><br>
	wizHighPolyCountWarning [string $sel[]] [int $highCount] <br>
	This function will do the poly count.
	Pass a int value of what is considered a high poly count.
	
	<b>Return value</b><br>
	int 0 if continue is chosen 1 if lower poly count is chosen.
	if no flags are passed default labels will be used.
	
	<b>Flags</b><br>
	-title, -message, -defaultButtonLabel, -cancelButtonLabel
	
	<hr>
	<b>Examples</b><br>
	<code>
	int $lowerPolyCount = wizHighPolyCountWarning(`ls -sl`, 100000, "");
	if ($lowerPolyCount == 1){
		doSomeLowerPolyCountProc();
	}
	
	</code>
*********************************************************************/
global proc int wizHighPolyCountWarning( string $sel[], int $highCount , string $flags )
{
	string $curSel[] = `ls -sl`;
	select $sel;
	int $fco[] = `polyEvaluate -f`;
	string $title = "High Poly Count Warning";
	string $message = "Poly Count Is High.\n Operation May Be Slow.\n";
	string $dbl = "Continue";
	string $cbl = "Lower Poly Count";
	string $tok[] = tokenizeString($flags, " ");
	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	//	<!ToDoWiz>
	//	This needs to be fixed so that strings with spaces can be passed.	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-t" : case "-title" :
			$title = $tok[($i + 1)];
			break;
			
			case "-m" : case "-message" :
			$message = $tok[($i + 1)];
			break;
			
			case "-dbl" : case "-defaultButtonLabel" :
			$dbl = $tok[($i + 1)];
			break;
			
			case "-cbl" : case "-cancelButtonLabel" :
			$cbl = $tok[($i + 1)];
			break;
		}
	}
	if ($fco[0] > $highCount){
		if (wizInformationDialog($title, $message, $dbl, $cbl) == 0){
			return 1;
		} else {
			return 0;
		}	
	} 
	return 0;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         VERTEX COLORS
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//@ CREATE MESH VERTEX COLOR SELECTION MAP
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-fa, -fb
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = createMeshVertexColorSelectionMap("-fa aString -fb anotherString");
	
	</code>
*********************************************************************/
global proc string createMeshVertexColorSelectionMap( string $flags )
{
	string $obj;
	string $v[];
	string $esf;
	int $fsx = 512;
	int $fsy = 512;
	string $eft = "tiff";
	float $floodColor = 1;
	float $selColor = 0;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-inv" : case "-invert" :
			$floodColor = 0;
			$selColor = 1;
			break;
				
			case "-fn" : case "-fileName" :
			$esf = $tok[($i + 1)];
			break;
			
			case "-fsx" : case "-exportfilesizex" :
			$fsx = int($tok[($i + 1)]);
			break;			
			
			case "-fsy" : case "-exportfilesizey" :
			$fsy = int($tok[($i + 1)]);
			break;
			
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break;
			
			case "-v" : case "-vertices" : 
			$v = wizFlagArray($tok, $i);
			break;
			
			case "-eft" : case "-exportFileType" :
			$eft = $tok[($i + 1)];
			break ;
			
			
		}
	}
	/*
	string $sel[] = wizFlagObjTrail($flags);
	if (`size $sel` == 0){
		$sel = `ls -fl -sl`;
	}
	*/
	if (`size $v` == 0){
		$v = `ls -fl -sl`;
	}
	
	polyColorSet -create -clamped 1 -rpt RGBA -colorSet "colorSet";
	
	select -r $obj;
	
	polyColorPerVertex -r $floodColor -g $floodColor -b $floodColor -cdo;

	select -r $v;
	
	polyColorPerVertex -r $selColor -g $selColor -b $selColor -cdo;

	/*	
	PaintVertexColorToolOptions;
	artPaintVertexInitPaintableAttr;
	string $artPaintVertex = "artAttrColorPerVertexContext";
	currentCtx;
	artAttrPaintVertexCtx -q -ex $artPaintVertex;
	artAttrPaintVertexCtx -e -efm "luminance/rgb" -eef false -eft "tiff" -esf "C:/Users/Glen/Documents/maya/projects/Assets/scenes/Testing/wizCraftTesting/AreaSizeAnalysisTest6_files/TestVertexColorMap5.tif" $artPaintVertex;
	*/
	
	string $artPaintVertex = "artAttrColorPerVertexContext";
	if (`artAttrPaintVertexCtx -q -ex $artPaintVertex` == 0){
		PaintVertexColorToolOptions;
		artPaintVertexInitPaintableAttr;
	}
	setToolTo $artPaintVertex;
	artAttrPaintVertexCtx -e -efm "luminance/rgb" -fsx $fsx -fsy $fsy -eef false -eft $eft -esf $esf $artPaintVertex;

	return $esf;
}

//@ CONVERT VERTEX COLORS TO TEXTURE MAP
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-fa, -fb
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-fa aString -fb anotherString");
	
	</code>
*********************************************************************/
global proc string convertVertexColorsToTextureMap( string $flags )
{
	string $sel[] = `ls -sl`;
	string $obj;
	string $v;
	string $ext = "tiff";
	string $esf;
	int $fsx = 512;
	int $fsy = 512;
	int $prompt;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-inv" : case "-invert" :
			$floodColor = 0;
			$selColor = 1;
			break;
				
			case "-fn" : case "-fileName" :
			$esf = $tok[($i + 1)];
			break;
			
			case "-fsx" : case "-exportfilesizex" :
			$fsx = int($tok[($i + 1)]);
			break;			
			
			case "-fsy" : case "-exportfilesizey" :
			$fsy = int($tok[($i + 1)]);
			break;
			
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break;
			
			case "-fp" : case "-filePrompt" :
			$prompt = 1;
			break ;
			
		}
	}
	
	string $extTok[] = tokenizeString($esf, ".");
	if (`size $extTok` > 1){
		$ext = $extTok[2];	
	}
	
	
	if ($prompt){
		$esf = wizGetAnyFile();
	}

	if (`size $sel` == 0 && `objExists $obj` == 1){
		select -r $obj;
	} else {
		$obj = $sel[0];
	}
	if (`size $esf` == 0){
		string $filename[] = wizCraftGetFileOutputPaths("-typ " + $obj + "VertexColors -ext " + $ext);
		$esf = $filename[0];
	}
	
	/*
	string $artPaintVertex = "artAttrColorPerVertexContext";
	setToolTo $artPaintVertex;
	artAttrPaintVertexCtx -e -efm "luminance/rgb" -fsx $fsx -fsy $fsy -eef false -eft "tiff" -esf $esf $artPaintVertex;

	global string $gSelect; setToolTo $gSelect;
	select -r $obj;
	*/
	
	string $artPaintVertex = "artAttrColorPerVertexContext";
	if (`artAttrPaintVertexCtx -q -ex $artPaintVertex` == 0){
		PaintVertexColorToolOptions;
		artPaintVertexInitPaintableAttr;
	}
	setToolTo $artPaintVertex;
	artAttrPaintVertexCtx -e -efm "luminance/rgb" -fsx $fsx -fsy $fsy -eef false -eft $ext -esf $esf $artPaintVertex;
	
	return $esf;
	


}

//@ PROC NAME
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-fa, -fb
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-fa aString -fb anotherString");
	
	</code>
*********************************************************************/
global proc string[] createCurveProjector( string $flags )
{
	wizlog ("[@] createCurveProjector");
	string $type = "surfaceNormal";
	string $sel[];
	string $curve;
	string $mesh;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;
		
			case "-typ" : case "-type" :
			$type =	$tok[($i + 1)];
			break ;
			
		}
	}

	string $c[] = smartSelectObjectsOfType($sel, "nurbsCurve");
	string $m[] = smartSelectObjectsOfType($sel, "mesh");
	wizlog ("	[#] Curve : " + $curve + " Mesh : " + $mesh);
	if (`size $c` == 0 || `size $m` == 0){
		wizlog ("-w		[!] A Curve And A Mesh Must Be Selected [!]");
		return $sel;
		
	}
	string $tr[] = `listTransforms $c[0]`;	
	$curve = $tr[0];
	
	$tr = `listTransforms $m[0]`;
	$mesh = $tr[0];
	
	float $curvePos[] = `xform -q -ws -t $curve`;
	
	//string $sl[] = `spaceLocator -n "CurveProjectionLocator" -p $pos[0] $pos[1] $pos[2]`;
	//string $sl[] = `spaceLocator -n "CurveProjectionLocator"`;
	string $sl[] = `spaceLocator`;
	xform -ws -t $curvePos[0] $curvePos[1] $curvePos[2] $sl[0];
	string $nc[];
	if ($type == "surfaceNormal"){
		select -r $mesh;
		select -add $sl[0];
		geometryConstraint -weight 1;

		$nc = `normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0`;
		float $constVect[] = `getAttr ($nc[0] + ".constraintVector")`;			
	
	}
	
	if ($type == "aim"){
		float $meshPos[] = `xform -q -t $mesh`;
		string $msl[] = `spaceLocator -n ($mesh + "AimLocator")`;
		xform -ws -t $meshPos[0] $meshPos[1] $meshPos[2] $msl[0];
		select -r $msl[0];
		select -add $sl[0];
		$nc = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "scene"`;
		
		
		
	}

		select -r $sl[0];
		select -add $curve;
		parentConstraint -mo -weight 1;
		
		string $ppc[] = `polyProjectCurve -ch true $curve $mesh`;
		string $proj[] = smartSelectObjectsOfType($ppc, "polyProjectCurve");
		
		wizlog ("	[+] Poly Project Curve : " + $proj[0]);
		connectAttr -f ($nc[0] + ".constraintVector") ($proj[0] + ".direction");
	
	
	return $proj;
}

//@ NORMAL ALIGN CAMERA TO CLOSEST POINT ON POLY
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $sel[] = `ls -sl`;
	normalAlignCameraToClosestPointOnPoly("-cam " + $sel[1] + " -obj " + $sel[0] + " -fit");
	normalAlignCameraToClosestPointOnPoly(" -obj " + $sel[0] + " -fit");
	</code>
*********************************************************************/
global proc normalAlignCameraToClosestPointOnPoly( string $flags )
{
	string $obj, $cam;
	string $sel[];
	int $fiv = 1;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break ;
			
			case "-cam" : case "-camera" :
			$cam = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			$obj = $sel[0];
			break ;			
			
			case "-fit" : case "-fitIntoView" :
			$fiv = 1;
			break ;
			
		}
	}
	
	if (`size $cam` == 0){
		$cam = `getCurrentCamera`;
	}

	string $f[] = getClosestMeshComponents("-obj " + $obj + " -typ face -tr " + $cam );
	
	select -r $f;
	if ($fiv){
		viewFit -f 0.1;	
	}
	/*
	float $fNorm[] = getFaceNormals($f);
	
	string $sl[] = `spaceLocator`;
	transferTransforms($cam, $sl[0]);
	
	move -r -os -wd (0 - $fNorm[0]) (0 - $fNorm[1]) (0 - $fNorm[2]) $sl[0];
	
	select -r $sl[0];
	select -add $cam;
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "scene";
	*/
	
	AlignCameraToPolygon;
	if ($fiv){
		viewFit -f 0.1;	
	}

}

//@ PROC NAME
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = wizTerrainTileBlanket("-sl -xt 10 -yt 10 -xs 10 -ys 10 -n tTile");
	
	</code>
*********************************************************************/
global proc string[] wizTerrainTileBlanket( string $flags )
{
	string $obj;
	int $xt, $yt;
	float $xtl;
	float $ytl;
	float $xl, $yl;
	string $name = "TerrainTile";
	int $xs = 10;
	int $ys = 10;
	float $center[];	
	string $return[];
	string $sel[];
	int $lod;
	int $lodHigh;
	int $lodLow;
	int $dv = 1;
	int $smooth;
	int $tileUVs;
	
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			$obj = $sel[0];
			break ;
			
			case "-xt" : case "-xTiles" : case "-div" :
			$xt = int($tok[($i + 1)]);
			break ;
				
			case "-yt" : case "-yTiles" :
			$yt = int($tok[($i + 1)]);
			break ;

			case "-xs" : case "-xSubdivisions" : case "-sub" :
			$xs = int($tok[($i + 1)]);
			break ;
			
			case "-ys" : case "-ySubdivisions" :
			$ys = int($tok[($i + 1)]);
			break ;
			
			case "-c" : case "-center" :
			string $centerString[] = wizFlagArray($tok, $i);
			$center = stringArrayToFloatArray($centerString);
			break ;
			
			case "-n" : case "-name" :
			$name = $tok[($i + 1)];
			break ;		
			
			case "-lod" : case "-levelOfDetail" :
			$lod = int($tok[($i + 1)]);
			break ;
			
			case "-lodh" : case "-lodHigh" :
			$lodHigh = int($tok[($i + 1)]);
			break ;
			
			case "-lodl" : case "-lodLow" :
			$lodLow = int($tok[($i + 1)]);
			break ;
			
			case "-sm" : case "-smooth" :
			$smooth = 1;
			break ;
			
			case "-dv" : case "-smoothDivisions" :
			$dv = int($tok[($i + 1)]);
			break ;
			
			case "-wiz" : 
			$smooth = `checkBox -q -v terrainTileBlanketLayout_smooth_checkBox`;
			$dv = `intFieldGrp -q -v1 terrainTileBlanketLayout_smoothSubdivisions_intFieldGrp`;
			$tileUVs = `checkBox -q -v terrainTileBlanket_tileUVs_checkBox`;
			break ;
			
			
			
		}
	}
	
	if ($lod > 0){
		if ($lodHigh == 0){
			$lodHigh = $xs;
		}
	}
	if (`size $obj` == 0){
		wizlog ("[!] Error : A Terrain Mesh Needs To Be Selected");
		return {""};
	}
	
	float $bboxSize[] = `getAttr ($obj + ".boundingBoxSize")`;
	float $center[] = `getAttr ($obj + ".center")`;

	/*
	$xtl = $bboxSize[0] / $xt;
	$ytl = $xtl;
	*/
	$xl = $bboxSize[0];
	$yl = $bboxSize[2];
	
	wizlog ("[#] Terrain Object : " + $obj);
	//wizlog ("[#] X Tile Length : " + $xtl + " [#] Y Tile Length : " + $ytl);
	wizlog ("[#] X Length : " + $xl + " [#] Y Length : " + $yl);
	
	string $tileUVCom;
	if ($tileUVs){
		$tileUVCom = "-uvt";
	}

	string $ppg[] = wizPolyPlaneGrid($tileUVCom + " -xt " + $xt + " -yt " + $yt + " -xl " + $xl + " -yl " + $yl + " -xs " + $xs + " -ys " + $ys + " -c " + $center[0] + " " + $center[1] + " " + $center[2] + " -n " + $name);
		
	if ($smooth){
		for ($i=0;$i<`size $ppg`;$i++){
			polySmooth  -mth 0 -sdt 2 -ovb 1 -ofb 3 -ofc 0 -ost 1 -ocr 0 -dv $dv -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $ppg[$i];	
		}
	}
	
	select -r $ppg[0];
	select -add $obj;
	string $sw[] = `deformer -type shrinkWrap $ppg[0]`;
	
	
	// Add all the rest of the tiles to the shrinkWrap deformer
	for ($i=1;$i<`size $ppg`;$i++){
		//select -r $ppg[$i];
		//select -add $obj;
		deformer -e -g $ppg[$i] $sw[0];
	}
	
	// Set the terrain as the taget for the shrink wrap	
	select -r $sw[0];	
	select -add $obj;
	SetShrinkWrapTarget;
	
	// Set the shrink wrap attributes for doing terrain shrink wrap
	setAttr ($sw[0] + ".projection") 3;
	setAttr ($sw[0] + ".bidirectional") 1;
	
	string $parent[] = `listRelatives -p $ppg[0]`;
	
	if (`size $parent` > 0){
		//xform -a -ws -t $center[0] $center[1] $center[2] $parent;
		setAttr ($parent[0] + ".center") $center[0] $center[1] $center[2];
	}
	
	return $ppg;
}


//@ WIZ POLY PLANE GRID
//====================================================================
/*****************************************************************//**
	Creates a 2d grid of planes.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-xTiles(-xt) <br>
	-xTileLength(-xtl) <br>
	-xLength(-xl) <br>
	-xSubdivisions(-xs) <br>
	-center(-c) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = wizPolyPlaneGrid("-xt 10 -yt 10 -xtl 100 -ytl 100 -xs 10 -ys 10 -center 10 20 30 -n tTile");
	
	</code>
*********************************************************************/
global proc string[] wizPolyPlaneGrid( string $flags )
{
	string $obj, $type;
	int $xTiles, $yTiles;
	float $xTileLength;
	float $yTileLength;
	float $xlength, $ylength;
	string $name;
	int $xSub, $ySub;
	float $center[];
	int $lod;
	int $lodHigh;
	int $lodLow;
	int $uvt;
	
	string $return[];
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-xt" : case "-xTiles" :
			$xTiles = int($tok[($i + 1)]);
			break ;
				
			case "-yt" : case "-yTiles" :
			$yTiles = int($tok[($i + 1)]);
			break ;
			
			case "-xtl" : case "-xTileLength" :
			$xTileLength = float($tok[($i + 1)]);
			break ;
			
			case "-ytl" : case "-yTileLength" :
			$yTileLength = float($tok[($i + 1)]);
			break ;
			
			case "-xl" : case "-xLength" :
			$xlength = float($tok[($i + 1)]);
			break ;
			
			case "-yl" : case "-yLength" :
			$ylength = float($tok[($i + 1)]);
			break ;
			
			case "-xs" : case "-xSubdivisions" :
			$xSub = int($tok[($i + 1)]);
			break ;
			
			case "-ys" : case "-ySubdivisions" :
			$ySub = int($tok[($i + 1)]);
			break ;
			
			case "-c" : case "-center" :
			string $centerString[] = wizFlagArray($tok, $i);
			$center = stringArrayToFloatArray($centerString);
			break ;
			
			case "-n" : case "-name" :
			$name = $tok[($i + 1)];
			break ;		

			case "-lod" : case "-levelOfDetail" :
			$lod = int($tok[($i + 1)]);
			break ;
			
			case "-lodh" : case "-lodHigh" :
			$lodHigh = int($tok[($i + 1)]);
			break ;
			
			case "-lodl" : case "-lodLow" :
			$lodLow = int($tok[($i + 1)]);
			break ;	
			
			case "-uvt" : case "-uvTiles" :
			$uvt = 1;
			break ;
				
		}
	}
	if ($lod > 0){
		if ($lodHigh == 0){
			$lodHigh = $xSub;
		}
	}
	
	if ($xTileLength == 0){
		$xTileLength = $xlength / $xTiles;
	}

	if ($yTileLength == 0){
		$yTileLength = $ylength / $yTiles;
	}
	
	wizlog ("	[#] X Tiles : " + $xTiles + " [#] Y Tiles : " + $yTiles);
	wizlog ("	[#] X Tile Length : " + $xTileLength + " [#] Y Tile Length : " + $yTileLength);
	
	float $tileStartPos[] = { ($center[0] - ($xlength / 2)), $center[1], ($center[2] - ($ylength / 2)) };
	// Not sure this is the best way...
	$tileStartPos[0] = $tileStartPos[0] + ($xTileLength / 2);
	$tileStartPos[2] = $tileStartPos[2] - ($yTileLength / 2);
	
	wizlog ("	[#] Tile Start Position : " + $tileStartPos[0] + " " +  $tileStartPos[1] + " " + $tileStartPos[2]);
	float $tilePos[] = $tileStartPos;
	
	for ($xi=0;$xi<$xTiles;$xi++){
		for ($yi=0;$yi<$yTiles;$yi++){	
			string $tileName = $name + "_x" + $xi + "_y" + $yi;
			wizlog ("	[+] Tile : " + $tileName);
			$tilePos[2] = $tilePos[2] + $yTileLength;
			wizlog ("	[#] Tile Position Y : " + $tilePos[2]);
			//int $xSubDiv = $xSub / ($xi + 1);
			//int $ySubDiv = $ySub / ($yi + 1);
			string $pp[] = `polyPlane -w $xTileLength -h $yTileLength -sx $xSub -sy $ySub -cuv 2 -n $tileName`;
			
			xform -ws -t $tilePos[0] $tilePos[1] $tilePos[2] $pp[0];	
			
			if ($uvt){
				ConvertSelectionToUVs;			
				polyEditUV -u $xi -v $yi;
			}
			
			$return[`size $return`] = $pp[0];
			wizlog ("	[+] Tile : " + $pp[0]);
				
			/*
			string $lodPP[];
			for ($li=0;$li<$lod;$li++){	

				
				string $tileName = $name + "_x" + $xi + "_y" + $yi + "_lod" + $li;
				wizlog ("	[+] Tile : " + $tileName);
				$tilePos[2] = $tilePos[2] + $yTileLength;
				wizlog ("	[#] Tile Position Y : " + $tilePos[2]);
				int $xSubDiv = $xSub / ($li + 1);
				int $ySubDiv = $ySub / ($li + 1);
				string $pp[] = `polyPlane -w $xTileLength -h $yTileLength -sx $xSubDiv -sy $ySubDiv -cuv 2 -n $tileName`;
				xform -ws -t $tilePos[0] $tilePos[1] $tilePos[2] $pp[0];
				$lodPP[$li] = $pp[0];
				$return[`size $return`] = $pp[0];
				wizlog ("	[+] Tile : " + $pp[0]);
			
			}
			createBoundingBoxProxyLODGroupForSelected($lodPP);
			*/
		}
		wizlog ("	[#] Tile Position X : " + $tilePos[0]);
		$tilePos[0] = $tilePos[0] + $xTileLength;
		$tilePos[2] = $tileStartPos[2];
		
	}
	
	group -n ($name + "Group") $return;
	
	//string $ppGroup[] = `group -n ($name + "Group") $return`;	
	//$return[`size $return`] = $ppGroup[(`size $ppGroup` - 1)];
	
	return $return;

}



global proc wizExtrudeLength()
{

	string $selectedExtrude[] = `ls -sl`;
	//string $extrudedShape[] = smartSelectObjectsOfType(`ls -sl`, "-type extrude");
	
	string $extrudedShape[] = `pickWalk -d down`;

 		if (`attributeExists "create" $extrudedShape[0]`) 
		{
      		string $extrudNode[] = `listConnections ($extrudedShape[0] + ".create")`;
		string $pathCurve[] = `listConnections ($extrudNode[0] + ".path")`;
		select $pathCurve[0];
		string $pathShape[] = `pickWalk -d down`;
		string $newSubCurve = `createNode subCurve`;

		setAttr ($newSubCurve + ".relative") 1;

		connectAttr -f ($pathShape[0] + ".worldSpace[0]") ($newSubCurve + ".inputCurve");
		connectAttr -f ($newSubCurve + ".outputCurve") ($extrudNode[0] + ".path");

		addAttr -ln "extrudeLength" -at double  -min 0.000001 -max 1 -dv 1 $extrudNode[0];
		setAttr -e -keyable true ($extrudNode[0] + ".extrudeLength");

		setAttr ($extrudNode[0] + ".useProfileNormal") 1;
		setAttr ($extrudNode[0] + ".fixedPath") 1;
		setAttr ($extrudNode[0] + ".useComponentPivot") 1;
		setAttr ($extrudNode[0] + ".extrudeType") 2;

		connectAttr -f ($extrudNode[0] + ".extrudeLength") ($newSubCurve + ".maxValue");

		setAttr ($extrudNode[0] + ".subCurveSubSurface") 1;

		select $extrudNode[0];

		} 
		else 
		{
		string $extrudNode[] = `listConnections ($extrudedShape[0] + ".inMesh")`;
		string $pathCurve[] = `listConnections ($extrudNode[0] + ".pathCurve")`;
		select $pathCurve[0];
		string $pathShape[] = `pickWalk -d down`;
		string $newSubCurve = `createNode subCurve`;
		
		setAttr ($newSubCurve + ".relative") 1;

		connectAttr -f ($pathShape[0] + ".worldSpace[0]") ($newSubCurve + ".inputCurve");
		connectAttr -f ($newSubCurve + ".outputCurve") ($extrudNode[0] + ".inputProfile");

		addAttr -ln "extrudeLength" -at double  -min 0.000001 -max 1 -dv 1 $extrudNode[0];
		setAttr -e -keyable true ($extrudNode[0] + ".extrudeLength");


		connectAttr -f ($extrudNode[0] + ".extrudeLength") ($newSubCurve + ".maxValue");

		select $extrudNode[0];

		}

}


global proc wizToggleBoolBaseVisibility()
{
	string $history[];
	string $polyBoolInputNodes[];
	string $sel[] = `ls -dag -type "mesh" -sl`;
	string $polyBoolOutputNodes[] = `listConnections -type "polyBoolOp" -source 0 -destination 1 -plugs 0 $sel[0]`;
	if (`size $polyBoolOutputNodes`){
		setAttr ($sel[0] + ".intermediateObject") 1;
		string $parentTransform[] = `listRelatives -parent -fullPath $sel[0]`;
		setAttr ($parentTransform[0] + ".visibility") 0;
	} else {
		$history = `listHistory $sel`;
		$polyBoolInputNodes = {};
	
		
		for ($node in $history){
			if (`nodeType $node` == "polyBoolOp"){
				$polyBoolInputNodes[`size $polyBoolInputNodes`] = $node;
			}
			
			if (! `size $polyBoolInputNodes`){
				return;
			}
			
			$polyBoolInputNodes = `sort $polyBoolInputNodes`;
			string $baseShape[] = `listConnections -type "mesh" -shapes 1 -source 1 -destination 0 -plugs 0 ($polyBoolInputNodes[0] + ".inputPoly[0]")`;
			setAttr ($baseShape[0] + ".intermediateObject") 0;
			string $parentTransform[] = `listRelatives -parent -fullPath $baseShape[0]`;
			setAttr ($parentTransform[0] + ".visibility") 1;
			select $parentTransform[0];
		}
	}
}


global proc string[] wizPolySeparateAllFaces( string $flags )
{

	string $sel[];
	float $off;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){

			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			

			case "-off" : case "-offset" :
			$off = float($tok[($i + 1)]);
			break ;
			
		}
	}

	
	for ($i=0;$i<`size $sel`;$i++){
			ConvertSelectionToFaces;
			string $f[] = `ls -fl $sel[$i]`;
			select -r $sel[$i];
			//wizlog (niceArrayList("Faces : ", $f));
			for ($p=0;$p<`size $f`;$p++){
				//wizlog ("Chip Off : " + $f[$p]);
				polyChipOff -ch 1 -kft 0 -dup 0 -off $off $f[$p];

			}

			//select -cl;
			//select -r $sel[$i];
			//polySeparate -ch 0 $sel[$i];

		}
	

	select -cl;
	select -r $sel;	
		
	polySeparate -ch 1;	
	
	string $return[] = `ls -sl`;

	return $return;
	
}

//@ WIZ POLY PIECES
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc string[] wizPolyPieces( string $flags )
{
	string $sel[];
	float $dis;
	int $extrude;
	float $off;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-wiz" :
			$dis = `floatFieldGrp -q -v1 wiz_polyPiecesExtrudeDistance_floatFieldGrp`;
			$extrude = `checkBox -q -v wiz_polyPiecesExtrude_checkBox`;
			$off = `floatFieldGrp -q -v1 wiz_polyPiecesOffset_floatFieldGrp`;
			break ;
			
		}
	}
	
	string $return[];

	for ($i=0;$i<`size $sel`;$i++){
		string $f[] = wizPolySeparateAllFaces("-sl -off " + $off);
		if ($extrude){
			
			for ($p=0;$p<`size $f`;$p++){
				select -r $f[$p];
				polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -divisions 1 -twist 0 -taper 1 -off 0 -thickness 0 -smoothingAngle 30 -localTranslateZ $dis $f[$p];
		
			}
		
		}
		
		appendStringArray($return, $f, `size $f`);
	}

	return $return;
}


global proc wizProcessVoxelModel( string $flags )
{

	string $sel[];
	float $rp = 80;
	int $pr, $uvs, $cu, $c, $fn;
	int $s;
	float $sf;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-rp" : case "-rp" :
			$rp = float($tok[($i+1)]);
			break ;
			
			case "-pr" : case "-polyReduce" :
			$pr = 1;
			break ;
			
			case "-uvs" : 
			$uvs = 1;
			break ;
			
			case "-cu" : case "-cleanup" :
			$cu = 1;
			break ;
			
			case "-c" : case "-center" :
			$c = 1;
			break ;
			
			case "-s" : case "-scale" :
			$s = 1;
			break ;
			
			case "-sf" : case "-scaleFactor" :
			$sf = float($tok[($i + 1)]);
			break ;
			
			case "-fn" : case "-fixNormals" :
			$fn = 1;
			break ;
			
			case "-wiz" :
			$rp = `floatFieldGrp -q -v1 wizCraft_polyProcessReductionPercent_floatFieldGrp`;
			$pr = `checkBox -q -v wizPolyProcess_polyReduce_checkBox`;
			$fn = `checkBox -q -v wizPolyProcess_fixNormals_checkBox`;
			$cu = `checkBox -q -v wizPolyProcess_cleanup_checkBox`;
			$uvs = `checkBox -q -v wizPolyProcess_createUVs_checkBox`;
			$c = `checkBox -q -v wizPolyProcess_center_checkBox`;
			$s = `checkBox -q -v wizPolyProcess_scale_checkBox`;
			
			break ;
			
		}
			
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	
	if ($s){
		if ($sf == 0){
			$sf = `floatFieldGrp -q -v1 wizCraft_scaleFactor_floatFieldGrp`;
		}
		
		for ($i=0;$i<`size $sel`;$i++){
			setAttr ($sel[$i] + ".scale") $sf $sf $sf;	
		}
		
	}
	
	if ($fn){
		setNormalAngleOnSelected($sel);
	}
	
	select -r $sel;
	
	if ($cu){
		polyCleanupArgList 3 { "0","1","1","1","1","1","1","1","1","1e-005","1","1e-005","0","1e-005","0","1","1" };
		select -r $sel;
	}
	
	
	if ($pr){
		polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 1 -p $rp -vct 0 -tct 0 -replaceOriginal 1 $sel[0];

		delete -ch;
		select -r $sel;
	
		setNormalAngleOnSelected($sel);

		polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 1 -p ($rp * 0.5) -vct 0 -tct 0 -replaceOriginal 1 $sel[0];

	
		select -r $sel;
	
		setNormalAngleOnSelected($sel);
	}
	
	assignDefaultShaderToSelected(`ls -sl`);
	hyperShadePanelMenuCommand("hyperShadePanel1", "deleteUnusedNodes");
	
	select -r $sel;
	
	if ($uvs){
		ConvertSelectionToFaces;		
		
		string $f[] = `ls -fl -sl`;
		polyProjection -ch 1 -type Spherical -ibd on -sf on $f;
		
		select -r $sel;
		ConvertSelectionToUVs;
		
		Unfold3D -u -ite 1 -p 1 -bi 0 -tf 0 -ms 1024 -rs 2;
		
		select -r $sel;
		
	}
	
	if ($fn){
		polySetToFaceNormal;
		
	}
	
	select -r $sel;
	
	if ($fn){
		setNormalAngleOnSelected($sel);
	}
	
	select -r $sel;
	
	delete -ch;
	
	if ($c){
		alignObjectsToWorldCenter(`ls -sl`);
	}
	
}


global proc wizProcessPlanetaryTerrain( string $flags )
{

	string $sel[];
	float $rp = 80;
	int $subDir, $usdfi;
	int $export, $dhis;
	int $pr, $uvs, $cu, $cu2, $c, $fn, $pb, $psel, $sp, $uWS, $uLOD, $unFold, $rZero, $ads;
	int $lod0Count, $lod1Count, $lod2Count;
	int $s;
	float $sf;
	float $na = 90;
	string $importDir, $exportDir;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-rp" : case "-rp" :
			$rp = float($tok[($i+1)]);
			break ;
			
			case "-pr" : case "-polyReduce" :
			$pr = 1;
			break ;
			
			case "-uvs" : 
			$uvs = 1;
			break ;
			
			case "-cu" : case "-cleanup" :
			$cu = 1;
			break ;
			
			case "-cu2" : case "-cleanupTwice" :
			$cu2 = 1;
			break ;
			
			case "-c" : case "-center" :
			$c = 1;
			break ;
			
			case "-s" : case "-scale" :
			$s = 1;
			break ;
			
			case "-sf" : case "-scaleFactor" :
			$sf = float($tok[($i + 1)]);
			break ;
			
			case "-fn" : case "-fixNormals" :
			$fn = 1;
			break ;
			
			case "-isd" : case "-includeSubDirectories" :
			$subDir = 1;
			break ;
			
			case "-wiz" :
			$subDir = `checkBox -q -v wizPlanetaryTerrain_processSubDirectories_checkBox`;
			$rp = `floatFieldGrp -q -v1 wizPlanetaryTerrain_polyProcessReductionPercent_floatFieldGrp`;
			$pr = `checkBox -q -v wizPlanetaryTerrain_polyReduce_checkBox`;
			$fn = `checkBox -q -v wizPlanetaryTerrain_fixNormals_checkBox`;
			$na = `floatFieldGrp -q -v1 wizPlanetaryTerrain_normalAngle_floatFieldGrp`;
			$cu = `checkBox -q -v wizPlanetaryTerrain_cleanup_checkBox`;
			$cu2 = `checkBox -q -v wizPlanetaryTerrain_cleanupTwice_checkBox`;
			$uvs = `checkBox -q -v wizPlanetaryTerrain_createUVs_checkBox`;
			$c = `checkBox -q -v wizPlanetaryTerrain_center_checkBox`;
			$s = `checkBox -q -v wizPlanetaryTerrain_scale_checkBox`;
			$pb = `checkBox -q -v wizPlanetaryTerrain_planetaryBend_checkBox`;
			$psel = `checkBox -q -v wizPlanetaryTerrain_processSelected_checkBox`;
			$sp = `checkBox -q -v wizPlanetaryTerrain_sphericalProjection_checkBox`;
			//$uWS = `checkBox -q -v wizPlanetaryTerrain_unityWorldSpaceFormat_checkBox`;
			$uLOD = `checkBox -q -v wizPlanetaryTerrain_unityLODExport_checkBox`;
			$unFold = `checkBox -q -v wizPlanetaryTerrain_unfoldUVs_checkBox`;
			$rZero = `checkBox -q -v wizPlanetaryTerrain_reduceLOD0_checkBox`;
			$ads = `checkBox -q -v wizPlanetaryTerrain_reduceLOD0_checkBox`;
			$lod0Count = `intFieldGrp -q -v1 wizPlanetaryTerrain_highCount_intFieldGrp`;
			$lod1Count = `intFieldGrp -q -v1 wizPlanetaryTerrain_medCount_intFieldGrp`;
			$lod2Count = `intFieldGrp -q -v1 wizPlanetaryTerrain_lowCount_intFieldGrp`;
			$dhis = `checkBox -q -v wizPlanetaryTerrain_deleteHistory_checkBox`;
			$importDir = `textFieldButtonGrp -q -tx wizPlanetaryTerrain_importDirectory_textFieldButtonGrp`;
			$exportDir = `textFieldButtonGrp -q -tx wizPlanetaryTerrain_exportDirectory_textFieldButtonGrp`;
			$export = `checkBox -q -v wizPlanetaryTerrain_exportFBX_checkBox`;
			$usdfi = `checkBox -q -v wizPlanetaryTerrain_usdfi_checkBox`;
			
			break ;
			
		}
			
	}
	
	string $inFiles[];
	if ($subDir){
		$inFiles = wizGetFiles("-isd -dir " + $importDir + " -typ fbx");
	} else {
		$inFiles = wizGetFiles("-dir " + $importDir + " -typ fbx");
	}

	if ($psel == 1){
		clear $inFiles;
		$inFiles[0] = "selected";
	}
	
	for ($if=0;$if<`size $inFiles`;$if++){
		string $fName;
		if ($psel == 0){
			//_________________________________________
			// Import
			file -f -i $inFiles[$if];
			
			string $filePathSplice[] = wizSpliceFilePath($inFiles[$if], "-fn");		
			$fName = $filePathSplice[0];
			
			//_________________________________________
			// Select
			string $visGeo[] = `ls -l -g -v`;
			select -r $visGeo;
			$sel = `listTransforms -sl`;
			
			if (`size $sel` == 0){
				$sel = wizFlagObjTrail($flags);
			}
		} else {
			$sel = `ls -sl`;
			$fName = $sel[0];
		}
					
		//_________________________________________
		// Scale
		if ($s){
			if ($sf == 0){
				$sf = `floatFieldGrp -q -v1 wizPlanetaryTerrain_scaleFactor_floatFieldGrp`;
			}
			
			for ($i=0;$i<`size $sel`;$i++){
				setAttr ($sel[$i] + ".scale") $sf $sf $sf;	
			}
			
		}

				
		//_________________________________________
		// Fix Normals
		if ($fn){
			polyNormalPerVertex -ufn true;
			//polySetToFaceNormal;
			
		}		
		select -r $sel;
		
		if ($fn){
			//setNormalAngleOnSelected($sel);
			polySoftEdge -angle $na $sel;
		}
		
		select -r $sel;
		
		//_________________________________________
		// Cleanup
		if ($cu){
			polyCleanupArgList 3 { "0","1","1","1","1","1","1","1","1","1e-005","1","1e-005","0","1e-005","0","1","1" };
			select -r $sel;
		}
		
		//_________________________________________
		// Cleanup 2
		if ($cu2){
			polyCleanupArgList 3 { "0","1","1","1","1","1","1","1","1","1e-005","1","1e-005","0","1e-005","0","1","1" };
			select -r $sel;
		}
		
		//_________________________________________
		// Reduce
		
		if ($pr){
			polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 1 -p $rp -vct 0 -tct 0 -replaceOriginal 1 $sel[0];

			if ($dhis){
				delete -ch;
			}
			select -r $sel;
		
			setNormalAngleOnSelected($sel);

			polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 1 -p ($rp * 0.5) -vct 0 -tct 0 -replaceOriginal 1 $sel[0];

		
			select -r $sel;
		
			setNormalAngleOnSelected($sel);
		}
		
		//_________________________________________
		// Deform
		if ($pb){
			if (`objExists bend1` == 0){
				wizLog("No Planetary Bend Deformers Exist - Creating Bend Deformers");
				select -r $sel;
				string $bend1[] = `nonLinear -type bend -lowBound -1 -highBound 1 -curvature 120`;
				wizlog ("Planetary Bend Deformer : " + $bend1[0] + " " + $bend1[1] + " Created");
				//xform -ws -t 0.0 0.0 0.0 $bend1[1];
				//xform -ro 0.0 0.0 0.0 $bend1[1];
				setAttr ($bend1[1] + ".translateX") 0;
				setAttr ($bend1[1] + ".translateY") 0;
				setAttr ($bend1[1] + ".translateZ") 0;
				setAttr ($bend1[1] + ".scaleZ") 25000;
				setAttr ($bend1[1] + ".scaleX") 25000;
				setAttr ($bend1[1] + ".scaleY") 25000;
				setAttr ($bend1[1] + ".rotateX") 90;
				setAttr ($bend1[1] + ".rotateZ") -90;
				
				select -r $sel;
				string $bend2[] = `nonLinear -type bend -lowBound -1 -highBound 1 -curvature 120`;
				wizlog ("Planetary Bend Deformer : " + $bend2[0] + " " + $bend2[1] + " Created");
				setAttr ($bend2[1] + ".translateX") 0;
				setAttr ($bend2[1] + ".translateY") 0;
				setAttr ($bend2[1] + ".translateZ") 0;
				setAttr ($bend2[1] + ".scaleZ") 25000;
				setAttr ($bend2[1] + ".scaleX") 25000;
				setAttr ($bend2[1] + ".scaleY") 25000;				
				setAttr ($bend2[1] + ".rotateZ") -90;
			} else {
				wizLog("Planetary Bend Deformers Exist");
				for ($i=0;$i<`size $sel`;$i++){
					deformer -e -g $sel[$i] bend1;
					deformer -e -g $sel[$i] bend2;
				}
			}
			select -r $sel;
		}
		
		//_________________________________________
		// Default Shader
		if ($ads){
			assignDefaultShaderToSelected(`ls -sl`);
			hyperShadePanelMenuCommand("hyperShadePanel1", "deleteUnusedNodes");
		
		}
		
		select -r $sel;
		
		//_________________________________________
		// UVs
		if ($uvs){
			ConvertSelectionToFaces;		
			
			string $f[] = `ls -fl -sl`;
			if ($sp){
				polyProjection -ch 1 -type Spherical -ibd on -sf on $f;
			} else {
				polyProjection -ch 1 -type Planar -ibd on -kir -md y $f;
			}
			
			select -r $sel;
			if ($dhis){
				delete -ch;
			}
			select -r $sel;
			
			
			if ($unFold){
				ConvertSelectionToUVs;
				Unfold3D -u -ite 1 -p 1 -bi 0 -tf 0 -ms 1024 -rs 2;
				select -r $sel;
			} else {
				untangleUV -r uniform -pb 0 -ps 0 -pu 0 -rt 0 -mri 5;
			}
			
			
			
		}
		
				
		select -r $sel;
		
		if ($dhis){
			delete -ch;
		}
		
		//_________________________________________
		// Align
		if ($c){
			alignObjectsToWorldCenter(`ls -sl`);
			select -r $sel;
			makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
		}
		
		if ($uWS){
			string $wpFilename;
			float $c[] = `getAttr ($sel[$if] + ".center")`;
			$wpFilename = $fName + "x_" + $c[0] + "y_" + $c[1] + "z_" + $c[2];
			
			//Move the object to the center of the world
			move -rpr 0 0 0 $sel[$if];
			makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
	
			$fName = $wpFilename;
			
		}
		
		string $exportFile;
		if ($usdfi){
			string $filePathSpliceDir[] = wizSpliceFilePath($inFiles[$if], "-dir");
			$exportFile = $filePathSpliceDir[0] + $fName + ".fbx";
			$exportDir = $filePathSpliceDir[0];
		} else {		
			$exportFile = $exportDir + $fName + ".fbx";
		}
		
		if ($uLOD){
			//polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 1 -p $rp -vct 0 -tct 0 -replaceOriginal 1 $sel[0];
			// Make sure the object doesn't already have a lod suffix
			string $fTok[] = tokenizeString($fName, "_");
			if (`size $fTok` > 1){
				if ((startsWith($fTok[1], "LOD"))){
					rename $sel[0] $fTok[0];
					$fName = $fTok[0];
					$sel[0] = $fTok[0];
				}
			}
			
			select -r $sel;
			
			if ($rZero == 1){
				// Export med and low res duplicates
				string $high[] = wizPolyResVersions("-sl -ls -high -hec " + $lod0Count);
				string $highExportFile = $exportDir + $fName + "_LOD0.fbx";
				refresh -f;
				select -r $high[0];
				wizlog ("Exporting Object : ");
				//wizlog ((`ls -sl`));
				
				if ($fn){
					setNormalAngleOnSelected($high);
				}
		
				if ($export){
					wizExportFBX($highExportFile);
				}
				select -r $sel;
			
			}
		
			// Export med and low res duplicates
			string $med[] = wizPolyResVersions("-sl -ls -med -mec " + $lod1Count);
			string $medExportFile = $exportDir + $fName + "_LOD1.fbx";
			refresh -f;		
			
			if ($fn){
				setNormalAngleOnSelected($med);
			}
			select -r $med[0];	
			
			if ($export){
				wizExportFBX($medExportFile);
			}
			
			select -r $sel;
			
			string $low[] = wizPolyResVersions("-sl -ls -low -lec " + $lod2Count);
			string $lowExportFile = $exportDir + $fName + "_LOD2.fbx";
			refresh -f;
						
			if ($fn){
				setNormalAngleOnSelected($low);
			}
			select -r $low[0];	
			
			if ($export){
				wizExportFBX($lowExportFile);
			}
			
			//
			select -r $sel;
		
			if ($rZero == 0){
				// Rename original LOD0
				$exportFile = $exportDir + $fName + "_LOD0.fbx";
				if (`objExists ($sel[0] + "_LOD0")` == 0){
					rename $sel[0] ($sel[0] + "_LOD0");
				}
			}
		}
		
		if ($dhis){
			delete -ch;
		}
		
		if ($export){
			wizExportFBX($exportFile);
		}
		
		if ($psel == 0){
			file -f -new;
		
		}
		
		/*
		if ($psel == 0){
			//_________________________________________
			// Export
			string $exportFile = $exportDir + $fName + ".abc";
			
			string $j;
			$j = $j + "-sl -dataFormat ogawa ";			
			for ($i=0;$i<`size $sel`;$i++){
					$j = $j + " -root " + $sel[$i];
			}
			$j = $j + " -wv ";
			$j = $j + "-frameRange 0 0 ";
			//$j = $j + "-uvWrite ";
			$j = $j + "-writeColorSets ";
			$j = $j + "-stripNamespaces ";
			$j = $j + "-file " + $exportFile;
			wizlog ("AbcExport -j " + $j);
		
			wizlog ("[*] Exporting ABC File : \n" + "AbcExport -j " + $j);
			
			AbcExport -j $j;
			
			delete $sel;
		}
		*/
		
		refresh -f;
	}
	
}

global proc string[] wizPolyResVersions( string $flags )
{

	string $sel[] = `ls -sl`;
	int $med, $lo, $high;
	int $mec, $lec, $hec;
	float $medP = 50;
	float $lowP = 90;
	float $highP = 10;
	int $lodSuffix;
	int $vtxLimit;
	int $triLimit;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){					
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-med" : case "-medium" :
			$med = 1;
			break ;
			
			case "-hi" : case "-high" :
			$high = 1;
			break ;
			
			case "-lo" : case "-low" :
			$lo = 1;
			break ;
			
			case "-hec" : case "-highExactCount" :
			$hec = int($tok[$i + 1]);
			//$vtxLimit = 1;
			$triLimit = 1;
			$highP = wizGetPolyReductionPercentForTargetPolyCount("-sl -tc " + $hec);
			break ;
			
			case "-mec" : case "-medExactCount" :
			$mec = int($tok[$i + 1]);
			//$vtxLimit = 1;
			$triLimit = 1;
			$medP = wizGetPolyReductionPercentForTargetPolyCount("-sl -tc " + $mec);
			break ;
			
			case "-lec" : case "-lowExactCount" :
			$lec = int($tok[$i + 1]);
			//$vtxLimit = 1;
			$triLimit = 1;
			$lowP = wizGetPolyReductionPercentForTargetPolyCount("-sl -tc " + $lec);
			break ;
			
			case "-ls" : case "-lodSuffix" :
			$lodSuffix = 1;
			break ;
		}
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	
	string $return[];
	for ($i=0;$i<`size $sel`;$i++){		
		if ($high){
			select -r $sel[$i];
			string $highSuffix = "_hi";
			if ($lodSuffix){
				$highSuffix = "_LOD0";
			}
			string $dup[] = `duplicate -n ($sel[$i] + $highSuffix) -rr -renameChildren`;
			select -r $dup;		
			
			if ($triLimit){
				//polyReduce -tct $mec $dup[0];
				polyReduce  -ver 1 -trm 2 -shp 1 -keepBorder 1 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 0 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 0 -p 60 -vct 0 -tct $hec -replaceOriginal 1 $dup[0];

			} else {			
				polyReduce -p $highP $dup[0];
			}
			
			$return[`size $return`] = $dup[0];
			
			polySetToFaceNormal;
			
			select -r $dup[0];
			
			setNormalAngleOnSelected($dup);
			
			select -r $dup[0];
			
			delete -ch;
		}
		
		if ($med){
			select -r $sel[$i];
			string $medSuffix = "_med";
			if ($lodSuffix){
				$medSuffix = "_LOD1";
			}
			string $dup[] = `duplicate -n ($sel[$i] + $medSuffix) -rr -renameChildren`;
			select -r $dup;		
			
			if ($triLimit){
				//polyReduce -tct $mec $dup[0];
				polyReduce  -ver 1 -trm 2 -shp 1 -keepBorder 1 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 0 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 0 -p 60 -vct 0 -tct $mec -replaceOriginal 1 $dup[0];

			} else {			
				polyReduce -p $medP $dup[0];
			}
			
			$return[`size $return`] = $dup[0];
			
			polySetToFaceNormal;
			
			select -r $dup[0];
			
			setNormalAngleOnSelected($dup);
			
			select -r $dup[0];
			
			delete -ch;
		}
	
		if ($lo){
			select -r $sel[$i];
			string $lowSuffix = "_lo";
			if ($lodSuffix){
				$lowSuffix = "_LOD2";
			}
			string $dup[] = `duplicate -n ($sel[$i] + $lowSuffix) -rr -renameChildren`;
			select -r $dup;
			
			if ($triLimit){
				//polyReduce -tct $lec $dup[0];
				polyReduce  -ver 1 -trm 2 -shp 1 -keepBorder 1 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 0 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 0 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 0 -p 60 -vct 0 -tct $lec -replaceOriginal 1 $dup[0];
			} else {				
				polyReduce -p $lowP $dup[0];
			}
			
			$return[`size $return`] = $dup[0];
			
			polySetToFaceNormal;
			
			select -r $dup[0];
			
			setNormalAngleOnSelected($dup);
			
			select -r $dup[0];
			
			delete -ch;
		}
	}
	
	return $return;

}


global proc float wizGetPolyReductionPercentForTargetPolyCount( string $flags )
{

	string $sel[] = `ls -sl`;
	float $tc, $lo;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){					
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-tc" : case "-targetCount" :
			$tc = float($tok[($i + 1)]);
			break ;
			
		}
	}

	
	ConvertSelectionToFaces;
	//ConvertSelectionToVertices;
	string $f[] = `ls -fl -sl`;
	int $count = `size $f`;
	
	float $percent = 100.0 - (($tc / $count) * 100.0);
	wizlog ("Reduction Percent For Mesh : " + $sel[0] + " : Count : " + $count + " : Target Count : " + $tc + " : Percentage : " + $percent);
	
	return $percent;
}

global proc wizFixTerrainSeam()
{

	string $sel[] = `ls -sl`;
	
	select -r $sel[0];
	polySelectConstraint -m 3 -t 1 -w 1;
	string $vsA[] = `ls -fl -sl`;
	//wizlog (niceArrayList("Vertices A : ", $vsA));
	
	select -r $sel[1];
	polySelectConstraint -m 3 -t 1 -w 1;
	string $vsB[] = `ls -fl -sl`;
	
	wizSnapBorderVertices($vsA, $vsB);
	//wizSnapBorderVertices($vsB, $vsA);
	
}

global proc wizSnapBorderVertices( string $vsA[], string $vsB[])
{
	float $disTol = `floatFieldGrp -q -v1 wizPlanetaryTerrain_edgeVertexDistanceTolerance_floatFieldGrp`;
	string $snappedV[];
	string $closestB;
	float $closestDis = $disTol;
	float $vta[];
	float $vtb[];
	for ($a=0;$a<`size $vsA`;$a++){
		$clostestDis = $disTol;
		$closestB = "";
		for ($b=0;$b<`size $vsB`;$b++){
			if ((stringArrayContains($vsB[$b], $snappedV)) == 1){
				continue;
			}
			$vta = `xform -q -ws -t $vsA[$a]`;	
			$vtb = `xform -q -ws -t $vsB[$b]`;	
			float $dis = getDistanceBetweenPoints($vta, $vtb);
			//wizlog ("Distance : " + $dis);
			if ($dis < $disTol && $dis != 0.0){
				//$closestDis = $dis;
				//$closestB = $vsB[$b];
				xform -ws -t $vta[0] $vta[1] $vta[2] $vsB[$b];
				$snappedV[`size $snappedV`] = $vsB[$b];
			}
		}
		/*
		if ($closestB != ""){
			xform -ws -t $vta[0] $vta[1] $vta[2] $closestB;
			$snappedV[`size $snappedV`] = $closestB;
		} else {
			wizlog (" -No Close Vertices- " + $vsA[$a]);
		}
		*/
	}


}

global proc wizFixTerrainSeamCP( string $flags )
{

	string $sel[] = `ls -sl`;
	int $fo;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-fo" : case "-firstOnly" :
			$fo = 1;
			break ;
				
	
			
		}
	}

	if ($fo){
	
		wizSnapBorderVerticesWithCPConstraint({$sel[0], $sel[1]});
		return ;
	}
	
	
	//wizSnapBorderVerticesWithCPConstraint({$sel[0], $sel[1]});
	//wizSnapBorderVerticesWithCPConstraint({$sel[1], $sel[0]});
	
	for ($a=0;$a<`size $sel`;$a++){
		for ($b=(`size $sel` - 1);$b>-1;$b--){
			if (wizProgressCancelled() == 1) return;
			
			if ($sel[$a] == $sel[$b]){
				continue ;
			}
			int $intersects = doBoundingBoxesIntersect({$sel[$a], $sel[$b]});
			if ($intersects){
				wizSnapBorderVerticesWithCPConstraint({$sel[$a], $sel[$b]});
				wizlog (" [+] FIXED SEAM BETWEEN : " + $sel[$a] + " : " + $sel[$b]);
			} else {
				wizlog (" [-] NO INTERSECTION BETWEEN : " + $sel[$a] + " : " + $sel[$b]);
			}
			refresh -f;
			
			/*
			if ($intersects){
				wizSnapBorderVerticesWithCPConstraint({$sel[$b], $sel[$a]});
				wizlog (" [+] FIXED SEAM BETWEEN : " + $sel[$b] + " : " + $sel[$a]);
			} else {
				wizlog (" [-] NO INTERSECTION BETWEEN : " + $sel[$b] + " : " + $sel[$a]);
			}
			refresh -f;
			*/
		}
			
	}
	
	/*
	1,5
	2,4
	3,3
	4,2
	5,1
	
	*/
	
}

global proc wizSnapBorderVerticesWithCPConstraint( string $sel[] )
{
	// If a border vertice is within range of other mesh vertice
	// get closest point on mesh and snap vert
	
	select -r $sel[0];
	polySelectConstraint -m 3 -t 1 -w 1;
	string $vsA[] = `ls -fl -sl`;
	//wizlog (niceArrayList("Vertices A : ", $vsA));
	
	select -r $sel[1];
	polySelectConstraint -m 3 -t 1 -w 1;
	string $vsB[] = `ls -fl -sl`;
	
	wizProgressWindowStart("Fix Terrain Seams", "Fixing...", 1);
	wizProgressWindowMinMax(0,(`size $vsA` * `size $vsB`));
	
	select $sel[1];
	
	closestPointOn (1, 0);
	
	string $cp[] = `ls -sl`;
	string $cpom[] = `listConnections -type closestPointOnMesh $cp`;

	float $disTol = `floatFieldGrp -q -v1 wizPlanetaryTerrain_edgeVertexDistanceTolerance_floatFieldGrp`;
	string $snappedV[];
	string $closestB;
	float $closestDis = $disTol;
	float $vta[];
	float $vtb[];
	for ($a=0;$a<`size $vsA`;$a++){
		$clostestDis = $disTol;
		$closestB = "";
		for ($b=0;$b<`size $vsB`;$b++){
			$vta = `xform -q -ws -t $vsA[$a]`;	
			$vtb = `xform -q -ws -t $vsB[$b]`;	
			float $dis = getDistanceBetweenPoints($vta, $vtb);
			//wizlog ("Distance : " + $dis);
			if ($dis < $disTol && $dis > 0.000001){
				//$closestDis = $dis;
				//$closestB = $vsB[$b];
				//xform -ws -t $vta[0] $vta[1] $vta[2] $vsB[$b];
				//$snappedV[`size $snappedV`] = $vsB[$b];
				xform -ws -t $vta[0] $vta[1] $vta[2] $cp[0];
				float $sP[] = `getAttr ($cpom[0] + ".position")`;
				xform -ws -t $sP[0] $sP[1] $sP[2] $vsA[$a];
				//spaceLocator -p $sP[0] $sP[1] $sP[2];
				continue;
				wizProgressWindowStep((`size $vsB` - $b));
				
				if (wizProgressCancelled() == 1) return;	
			}
			wizProgressWindowStep(1);
		}

	}
	delete $cpom[0];
	delete $cp[0];
	select $sel;
	wizProgressWindowEnd();
}


global proc int doBoundingBoxesIntersect( string $sel[] )
{
/*

                //First bounding box, top left corner, bottom right corner
                var ATLx = bb1.TopLeftLatLong.Longitude;
                var ATLy = bb1.TopLeftLatLong.Latitude;
                var ABRx = bb1.BottomRightLatLong.Longitude;
                var ABRy = bb1.BottomRightLatLong.Latitude;

                //Second bounding box, top left corner, bottom right corner
                var BTLx = bb2.TopLeftLatLong.Longitude;
                var BTLy = bb2.TopLeftLatLong.Latitude;
                var BBRx = bb2.BottomRightLatLong.Longitude;
                var BBRy = bb2.BottomRightLatLong.Latitude;

                var rabx = Math.abs(ATLx + ABRx  BTLx  BBRx);
                var raby = Math.abs(ATLy + ABRy  BTLy  BBRy);

                //rAx + rBx
                var raxPrbx = ABRx  ATLx + BBRx  BTLx;

                //rAy + rBy
                var rayPrby = ATLy  ABRy + BTLy  BBRy;

                if(rabx <= raxPrbx && raby <= rayPrby)
                {
                                return true;
                }
                return false;


*/
	float $bb1[] =`exactWorldBoundingBox $sel[0]`;
	float $bb2[] =`exactWorldBoundingBox $sel[1]`;
	if (!( ($bb1[0]>$bb2[3]) || ($bb2[0]>$bb1[3]) 
		|| ($bb1[1]>$bb2[4]) || ($bb2[1]>$bb1[4]) 
		|| ($bb1[2]>$bb2[5]) || ($bb2[2]>$bb1[5]) )){
		//print ("intersects");
		return 1;
	}else{
		//print ("does not intersect");
		return 0;
	}
}


global proc float getDistanceBetweenVertices()
{
	string $v[] = `ls -fl -sl`;
	float $pA[] = `xform -q -ws -t $v[0]`;
	float $pB[] = `xform -q -ws -t $v[1]`;
	float $dis = getDistanceBetween($pA, $pB);
	print ("Distance : " + $dis);
	return $dis;


}

global proc unityPolyPrep()
{

	string $sel[];

	$sel = `ls -sl`;
	
	for ($i=0;$i<`size $sel`;$i++){
		unityPolyPrepObj($sel[$i]);
	}
	
	select -r $sel;
	wizAssignMaterialToSelected("-sl");
	
}

global proc unityPolyPrepObj( string $obj )
{
	float $rpercent = 75;
	select -r $obj;
	
	polyCleanupArgList 4 { "0","1","0","1","1","1","1","1","0","1e-005","1","1e-005","0","1e-005","0","1","1","0" };

	select -r $obj;
	
	polyReduce  -ver 1 -trm 0 -shp 1 -keepBorder 0 -keepMapBorder 0 -keepColorBorder 0 -keepFaceGroupBorder 0 -keepHardEdge 1 -keepCreaseEdge 0 -keepBorderWeight 0.5 -keepMapBorderWeight 0.5 -keepColorBorderWeight 0.5 -keepFaceGroupBorderWeight 0.5 -keepHardEdgeWeight 0.5 -keepCreaseEdgeWeight 0.5 -useVirtualSymmetry 2 -symmetryTolerance 0.01 -sx 0 -sy 1 -sz 0 -sw 0 -preserveTopology 1 -keepQuadsWeight 0 -vertexMapName "" -cachingReduce 1 -ch 0 -p $rpercent -vct 0 -tct 0 -replaceOriginal 1 ;

	select -r $obj;
	
	polySoftEdge -a 30 -ch 1 ;

	select -r $obj;
	
	polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.01 -ws 0 ;

	
}

global proc substancePolyPrep()
{

	string $sel[];

	$sel = `ls -sl`;
	
	for ($i=0;$i<`size $sel`;$i++){
		substancePolyPrepObj($sel[$i]);
	}
	
	//select -r $sel;
	//wizAssignMaterialToSelected("-sl");
	
}

global proc substancePolyPrepObj( string $obj )
{
	select -r $obj;
	
	polyCopyUV -uvSetNameInput "map1" -uvSetName "uvSet" -createNewMap 1 -ch 1 ;
	// polyCopyUV2 // 
	
	string $shape[] = `listRelatives -f -shapes $obj`;
	setAttr -type "string" ($shape[0] + ".currentUVSet") "map1";
	select -r $obj;
	polyAutoProjection -lm 1 -pb 0 -ibd 0 -cm 0 -l 2 -sc 1 -o 0 -p 6 -ps 0.1 -ws 0 ;

}

global proc prepMasterpieceVRMesh()
{
	string $sel[];

	$sel = `ls -sl`;
	xform -ws -t -90 -90 0 $sel;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -pn 1;
	alignObjectsToWorldCenter(`ls -sl`);
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -pn 1;
	removeAllNamespaces();
}