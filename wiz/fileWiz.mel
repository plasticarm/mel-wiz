//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//|||||||||||||||||||||||||:::WIZ:::||||||||||||||||||||||||||||||||||
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
/*====================================================================
Author: Glen Johnson
Email: plasticarm@gmail.com
Website: plasticarm.com / hrpictures.com
----------------------------------------------------------
Summary:

t679fi

====================================================================*/

//====================================================================
//			GLOBAL VARS

global string $WIZ_fileBrowserStartingDirectory;
$WIZ_fileBrowserStartingDirectory = `workspace -q -rd`;

global string $WIZ_sceneFileIconSuffix;
$WIZ_sceneFileIconSuffix = "ICON.png";

global string $WIZ_sceneFileRenderIconSuffix;
$WIZ_sceneFileRenderIconSuffix = "RICON.png";

global string $WIZ_sceneFilePosterSuffix;
$WIZ_sceneFilePosterSuffix = "POSTER.png";


global string $WIZ_lowResFolderName;
$WIZ_lowResFolderName = "lowRes";

global string $WIZ_sceneThumbnailType;
$WIZ_sceneThumbnailType = `optionVar -q WIZ_sceneThumbnailType`;

global string $WIZ_subFileFolderSuffix;
$WIZ_subFileFolderSuffix = "_files";

//====================================================================
global proc fileWiz()
{

}

//========================================================================================================
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
///////////////////                  /////////////////////////////////////////////////////////////////////
//			LAYOUTS
///////////////////                  /////////////////////////////////////////////////////////////////////
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//========================================================================================================
//FILE MENU
//-------------------------
global proc wizFileMenu()
{				
	menu -label "File" -to true;
		
		menuItem -l "Save And Archive" -c "wizSaveAndArchive()";
		menuItem -l "Save Render Copy" -c "wizSaveRenderCopy()";
		menuItem -l "Increment And Save" -c "incrementAndSaveWiz";	
		
		/*
		wizMenuItem("-l Save Thumbnail -cb 1 -c (\"saveSceneThumbnailImage();\") -n sceneThumbnailEnabled_checkBox");
			menuItem -ob true -c ("openCurrentOptionsLayout(\"sceneThumbnailOptions\");");
		*/
			
        menuItem -l "Save Thumbnail" -c ("saveSceneThumbnailImage();");
            menuItem -ob true -c ("openCurrentOptionsLayout(\"sceneThumbnailOptions\");");
		
		
		menuItem -sm true -l "File Copy" -to true;
			menuItem -l "Archive Files" -c ("wizArchiveSelectedFiles();");
			menuItem -l "Save MA Copy" -c ("wizExport(\"-cd -cfn -type mayaAscii -ext ma\");");
			menuItem -l "Create A Copy Of File"	-c ("string $sourceFile = `file -q -sn`;createACopy($sourceFile);");
			menuItem -l "Create Low Res No History Copy" -c ("makeLowResNoHistoryCopy();");
			menuItem -l "Re-Save File" -ann ("Use this to import files and re-save them using same name to fix version compatibility issues.") -c ("wizResaveFiles(\"-fp\");");
			menuItem -l "Re-Save Files In Directory" -ann ("Use this to import files and re-save them using same name to fix version compatibility issues.") -c ("wizResaveFiles(\"-dp\");");
			menuItem -l "Re-Save Files In All Sub-Directories" -ann ("Use this to import files and re-save them using same name to fix version compatibility issues.") -c ("wizResaveFiles(\"-dp -isd\");");
			menuItem -l "Remove Unknown Plugins" -c ("wizRemoveUnknownPlugins(\"\");");
			
		setParent -menu..;	
		
		menuItem -d true -dl "Reset";
		
		string $reloadC = (
		"if (wizInformationDialog(\"Reload Scene Without Saving?\", \"Are You sure you want to reload without saving?\", \"Yes\", \"Cancel\")){"+"\n"
		+"	string $curFile = `file -q -sn`;"+"\n"
		+"	file -f -o $curFile;"+"\n"
		+"};");
		
		menuItem -l "Reload Current File" -c $reloadC;
		menuItem -l "Reset and Save" -c "resetAndSave";
		menuItem -l "Rewind and Save" -c "remwindAndSave";			
		
		menuItem -d true -dl "Reference";
		
		menuItem -sm true -l "Reference Files" -to true;	
			
			menuItem -l "Open Selected Object Reference File" -c ("openSelectedObjectReferenceFile(`ls -sl`);");
			menuItem -d true;
            
			menuItem -sm true -l "Create" -to true;
				menuItem -l "Reference All Selected Files" -c ("referenceAllSelectedFiles();");
				menuItem -l "Reference All Files In Directory" -c ("referenceAllFilesInDirectory();");
				menuItem -l "Reference File With No Namespace" -c ("referenceFileNoNamespace();");
			setParent -menu..;
					
			menuItem -sm true -l "Duplicate" -to true;
				menuItem -l "Duplicate Reference Object" -c ("string $sel[] = `ls -sl`; string $obj = $sel[0]; duplicateReferenceObject($obj);");
				//menuItem -l "Duplicate Reference Object Options" -c ("openCurrentOptionsLayout(\"referenceFileOptions\"); print(\"Open Reference File Options\")");
				menuItem -ob true -c ("openCurrentOptionsLayout(\"referenceFileOptions\"); print(\"Open Reference File Options\")");
			
            setParent -menu..;
			
            menuItem -d true -dl "Import";
            
			menuItem -sm true -l "Import" -to true;
				menuItem -l "Import Selected Objects References" -c ("importSelectedObjectsReferences(`ls -sl`);");
				menuItem -l "Import All References" -c ("importAllReferences();");
				menuItem -l "Import All References Recursively" -c ("importAllReferencesRecursively();");
			setParent -menu..;
			
			menuItem -sm true -l "Proxies" -to true;
				menuItem -l "Load All Reference Originals" -c ("loadAllReferenceOriginals();");
				menuItem -l "Load All Reference Proxies" -c ("loadAllReferenceProxies();");
			setParent -menu..;           	
                     
            menuItem -d true;
            
			menuItem -sm true -l "Replace" -to true;
				menuItem -l "Replace All Selected References" -c ("wizReplaceAllSelectedReferences(\"-sl\");");
				menuItem -l "Replace All MB with MA" -c ("wizReplaceReferenceMBMA(\"-all -mbToMa\");");
				menuItem -l "Replace Selected MB with MA" -c ("wizReplaceReferenceMBMA(\"-sl -mbToMa\");");
				menuItem -l "Replace All MA with MB" -c ("wizReplaceReferenceMBMA(\"-all -maToMb\");");
				menuItem -l "Replace Selected MA with MB" -c ("wizReplaceReferenceMBMA(\"-sl -maToMb\");");
			setParent -menu..; 
			
			menuItem -sm true -l "Reload" -to true;
				menuItem -l "Reload Selected Referenced Objects" -c "refreshSelectedReferenceObjects";
				menuItem -l "Reload All References" -c ("refreshAllReferences();");
				menuItem -l "Load Child References Recursively" -c ("loadChildRefRecursively(\"\");");
			setParent -menu..;
            
			menuItem -sm true -l "Unload" -to true;
                menuItem -l "Unload Selected Referenced Objects" -c ("unloadSelectedReferenceObjects(`ls -sl`);");
				menuItem -l "Unload All References" -c ("unloadAllReferences();");
			setParent -menu..;
			
			menuItem -sm true -l "Remove" -to true;
				menuItem -l "Remove Selected Object Reference File" -c ("removeSelectedObjectReferenceFile(`ls -sl`);");
				menuItem -l "Remove Unloaded References" -c ("removeUnloadedReferences();");
				menuItem -l "Remove All References" -c ("removeAllReferences();");
			setParent -menu..;
			
			menuItem -sm true -l "Move" -to true;
				menuItem -l "Copy All References To Directory" -c ("wizMoveAllReferencesToDirectory(\"copy\");");
				menuItem -l "Move All References To Directory" -c ("wizMoveAllReferencesToDirectory(\"move\");");

			setParent -menu..;
			
            menuItem -d true -dl "Edits";
            
			menuItem -sm true -l "Edits" -to true;
				menuItem -l "Select Object's Reference Node" -c ("selecteObjectsReferenceNode(`ls -sl`);");
				menuItem -l "Copy Reference Edits" -c ("wizCopyReferenceEdits(\"-sl\");");
				menuItem -l "Remove Edits On Selected" -c ("wizRemoveReferenceEditsOnSelectedObjects(`ls -sl`);");
				menuItem -l "Remove All Failed Edits" -c ("wizRemoveAllFailedReferenceEditsOnSelectedObjectsReferences(`ls -sl`);");
				menuItem -l "Print All Failed Edits" -c ("wizPrintAllFailedReferenceEdits();");
			setParent -menu..;
			
			menuItem -sm true -l "Commands" -to true;
				menuItem -l "Clean All References" -c ("wizCleanAllReferences();");
				menuItem -l "Print Reference List" -c ("wizPrintReferenceList();");
				menuItem -l "Print Web Links" -c ("wizPrintReferenceListWebLinks();");
				menuItem -l "Print References List Recursive" -c ("findAllSceneReferences(\"\");");
				menuItem -l "Print Array References List Recursive" -c ("findAllSceneReferences(\"-al\");");
				menuItem -l "Print References List Recursive List Duplicates" -c ("findAllSceneReferences(\"-ldr\");");
				
				//setParent -menu..;
				
			setParent -menu..;
			
		setParent -menu..;
		
		
		menuItem -d true -dl "Import";
		menuItem -sm true -l "Import" -to true;
			menuItem -l "Import All Selected Files" -c ("importAllSelectedFiles();");		
		setParent -menu..;
		        
		menuItem -sm true -l "Export" -to true;
			//menuItem -l "Export Each Selection" -c ("exportEachSelectionToSeparetMayaFile(`ls -sl`, \"mayaBinary\", 0);");
			
			string $exportEachSelCommand = ("string $type = `optionMenuGrp -q -v wizExportEachSelAsFile_exportType_optionMenuGrp`;"+"\n"
			+"wizExportEachSelectionToFile(\"-sl -type \" + $type);");
	
			menuItem -l "Export Each Selection" -c $exportEachSelCommand;
				menuItem -ob true -c ("openCurrentOptionsLayout(\"wizExportEachSelectionToFileOptions\");");
				
			menuItem -l "Export Each Selection And Reference" -c ("exportEachSelectionToSeparetMayaFile(`ls -sl`, \"mayaBinary\", 1);");
			
			menuItem -sm true -l "Export Paths" -to true;
				menuItem -l "Add Export Path To Selected" -c ("addExportFilePathAttributeToSelected(`ls -sl`);");
				menuItem -l "Export Selected Objects With Export Paths" -c ("exportSelectedObjectsUsingExportPaths(`ls -sl`);");
				menuItem -l "Export All Objects With Export Paths" -c ("exportNodesWithExportPaths();");
                menuItem -l "Increment And Export All Objects With Export Paths" -c ("incrementAndExportObjectsUsingExportPath(\"all\");");
                menuItem -l "Increment And Export Selected Objects With Export Paths" -c ("incrementAndExportObjectsUsingExportPath(\"selected\");");
			
			setParent -menu..;
             
			menuItem -sm true -l "Export Sets" -to true;
				menuItem -l "Create Export Set From Selection" -c ("wizExportSet(\"-sl -ns\");");
					//menuItem -ob true -c ("openCurrentOptionsLayout(\"wizExportSetOptions\");");
				menuItem -l "Export Selected Sets" -c ("wizExportSet(\"-ess\");");	
				menuItem -l "Export All Sets" -c ("wizExportSet(\"-exportAll\");");
				menuItem -l "Increment And Export All Sets" -c ("wizExportSet(\"-exportAll -inc\");");
					//menuItem -ob true -c ("openCurrentOptionsLayout(\"wizExportSetOptions\");");
			setParent -menu..;
			
            menuItem -sm true -l "Other Exports" -to true;
				menuItem -l "Export MR Render Proxy" -c ("wizExportMRRenderProxy(\"-sl\");");
				
                menuItem -l "Export No History LOD Grouped Copy Of Selected" -c ("exportNoHistoryLODGroupedCopyOfSelected(`ls -sl`);");
			
		setParent -menu..;
        setParent -menu..;
        
		menuItem -d true -dl "Cache";
		
		menuItem -sm true -l "Cache" -to true;		
			menuItem -l "Import Cache File(s)" -c ("wizImportCacheFile(\"\");");
				menuItem -ob true -c ("openCurrentOptionsLayout(\"wizCacheFileOptions\");");
			menuItem -l "Export Cache File" -c ("wizExportCacheFile(\"\");");
				menuItem -ob true -c ("openCurrentOptionsLayout(\"wizCacheFileOptions\");");	
							
		setParent -menu..;
		menuItem -d true -dl "File Mgmt";
		
		menuItem -l "Map Directories";
			menuItem -ob true -c ("openCurrentOptionsLayout(\"wizDirmapLayout\");");
		
		menuItem -sm true -l "Copy-Move" -to true;
		
			menuItem -l "Move All Files Into Root" -ann "Moves All Files In Subfolder Of Specified Directory To That Directory" -c ("wizMoveAllFilesInSubfoldersIntoFolder(\"-dp\");");
			menuItem -l "Collect Files" -ann "Copies All External Files In Scene To Current File Directory" -c ("wizCollectFiles(\"-currentFileDirectory\");");
			menuItem -l "Collect Files To Directory" -ann "Copies All External Files In Scene To Specified Directory" -c ("wizCollectFiles(\"-dp\");");
	
		setParent -menu..;
		
		menuItem -sm true -l "Convert" -to true;
		menuItem -l "Convert STEP To FBX" -ann "Converts all STEP Files To FBX Files in Directory" -c ("convertAllSTEPFilesInDirToFBX();");
		menuItem -l "Convert FBX To OBJ" -ann "Converts all FBX Files To OBJ Files in Directory" -c ("convertAllFBXFilesInDirToOBJ();");
		
		setParent -menu..;
		
		menuItem -sm true -l "Data Files" -to true;
			menuItem -l "CSV File Formatting" -c ("openCurrentOptionsLayout(\"csvFormattingOptions\");");
		setParent -menu..;
		menuItem -d true;
		
		menuItem -sm true -l "Notes";			
			menuItem -l "Show All Notes" -c ("wizShowAllNotes();");			
			menuItem -l "Show All Notes On Open" -c ("showAllNotesOnOpen();");
		setParent -menu..;	
		menuItem -l "Find Missing Files In Sequence" -c ("wizFindMissingFilesInImageSequence(\"-fp\");");
		
		menuItem -l "Open New Maya Instance" -c ("openNewInstanceOfMaya();");		
		
		setParent -menu..;
		
		
		
}

global proc exportWizLayout( string $parent )
{

	string $layout = `frameLayout
		-l "Export Wiz"
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 0
		-mh 0			
		-cll true
		-cl true	
		-p $parent		
		exportWiz_frameLayout
		`;
		
		wizCheckBox(
		"-l Creat Low Poly Proxy "
		+"-ann Creates a low poly version of a model before exporting to use as the proxy container. If this is not checked a cube will be used if no other proxy mesh exists. "
		+"-v 1 "
		+"-n exportWiz_createLowPolyProxy_checkBox");

		button
		-l "Create Export Set From Selection"
		-c ("wizExportSet(\"-sl -ns\");")
		;
		
		button
		-l "Export All Export Sets"
		-c ("wizExportSet(\"-exportAll\");")
		;
		
		button
		-l "Render Mesh Thumbnail"
		-c ("wizMeshThumbnailImage(\"-wc\");")
		;
		

}
//@ WIZ DIRMAP LAYOUT
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
global proc wizDirmapLayout(string $parent)
{
	string $columnLayout = "wizDirmapColumnLayout";
	if(`columnLayout -q -ex $columnLayout` == 1){
		activateCurrentOptionsColumnLayout($columnLayout, "Wiz Directory Mapping", $parent);
		return;	
	}
	$columnLayout = wizOptionsColumnLayout($columnLayout, $parent);
	setParent $columnLayout;
	
	wizDirmapMenuBarLayout();
	
	string $addPath = `textFieldButtonGrp
		-l "Save Path:"		
		-ann "Double Click On Path To Map All Other Paths To Selected Path\nUse Delete Key To Remove A Path From List"
		-cal 1 "left"	
		-cw 1 50
		-adj 2
		-bl "Add"
		-bc ("string $path = `textFieldButtonGrp -q -tx wizDirmapAddPathTextFieldGrp`; addWizDirmapSavedPath($path);")
		wizDirmapAddPathTextFieldGrp
		`;
		
	text
		-l "Saved Directory Paths"	
		;
		
	string $tslAnn = ("EXAMPLE PATH: C:/Users/Default/Documents/maya/projects/ | or | /SharedDrive/projects/\n"
	+"- You Must Use All /'s\n"
	+"- Double Click On Path To Map All Other Paths To Selected Path\n"
	+"- Use Delete Key To Remove A Path From List"
	);
		
	textScrollList
		-h 100
		-ann $tslAnn
		-ams false
		-dkc ("doDirmapWizDeleteKeyCommand();")
		-dcc ("doDirmapWizDoubleClickCommand();")
		-sc ("doDirmapWizSelectCommand();")
		-dgc dragTextScrollListSelection
		-dpc dropTextScrollListSelection
		wizDirmapDirectoriesTextScrollList		
		;
	
	
		
	string $from = `textFieldGrp
		-l "Map From:"
		-ann "This Is The Directory That You Want To Change"
		-cal 1 "left"	
		-cw 1 50
		-adj 2
		wizDirmapFromTextFieldGrp
		`;
		
	string $to = `textFieldGrp
		-l "Onto:"
		-ann "This Is The Directory That You Want To Use"
		-cal 1 "left"	
		-cw 1 50
		-adj 2
		wizDirmapToTextFieldGrp
		`;

	button
		-l "Map Directory From - To Directory"
		-c ("doWizDirmap();")
		;
	setParent..;
	
	loadWizDirmapSavedPaths();
}

//========================================================================================================
//""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
///////////////////                  /////////////////////////////////////////////////////////////////////
//			MENUS
///////////////////                  /////////////////////////////////////////////////////////////////////
//""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
//========================================================================================================
global proc wizDirmapMenuBarLayout()
{
	string $menuBarLayout = `menuBarLayout wizDirmapMenuBarLayout`;
		menu -l "Dirmap";
		wizDirmapMenuItems();
}

global proc wizDirmapMenuItems()
{
	string $enableDirmapCommand = ("int $en = `menuItem -q -cb wizDirmapEnabledMenuItem`; dirmap -en $en;");
	menuItem -l "Dirmap Enabled" -cb false -c $enableDirmapCommand wizDirmapEnabledMenuItem;
	menuItem -l "Convert Directory" -cb true wizDirmapConvertDirectoryMenuItem;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//			DIRMAP
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
global proc loadWizDirmapSavedPaths()
{
	string $paths[] = getWizStringArrayVar("WIZ_dirmapSavedPaths");
	replaceTextScrollListWithSelectedObjects($paths, "wizDirmapDirectoriesTextScrollList");
	//print("WIZ| Loading Saved Paths: " + stringArrayToString($paths, " ") + "\n");
}

global proc addWizDirmapSavedPath(string $path)
{
	if($path == ""){
		return;	
	}
	
	addObjectToTextScrollList($path, "wizDirmapDirectoriesTextScrollList");
	appendWizStringArrayVar("WIZ_dirmapSavedPaths", $path);
	
	string $paths[] = getWizStringArrayVar("WIZ_dirmapSavedPaths");
	
	//print("WIZ| Add Path: " + $path + " - To Dirmap Saved Paths: " + stringArrayToString($paths, " ") + "\n");
	
}

global proc doDirmapWizSelectCommand()
{
	string $to[] = `textScrollList -q -si wizDirmapDirectoriesTextScrollList`;
	textFieldGrp -e -tx $to[0] wizDirmapToTextFieldGrp;
	
}

global proc doDirmapWizDeleteKeyCommand()
{
	string $del[] = `textScrollList -q -si wizDirmapDirectoriesTextScrollList`;
	int $sii[] = `textScrollList -q -sii wizDirmapDirectoriesTextScrollList`;	
	for($i=0;$i<`size $sii`;$i++){
		optionVar -rfa WIZ_dirmapSavedPaths ($sii[$i] - 1);
	}
	removeSelectedItemFromTextScrollList("wizDirmapDirectoriesTextScrollList");
	
	string $paths[] = getWizStringArrayVar("WIZ_dirmapSavedPaths");
	//print("WIZ| Remove Path: " + $del[0] + " - From Dirmap Saved Paths: " + stringArrayToString($paths, " ") + "\n");
		
}

global proc doDirmapWizDoubleClickCommand()
{
	string $from[] = `textScrollList -q -ai wizDirmapDirectoriesTextScrollList`;
	string $to[] = `textScrollList -q -si wizDirmapDirectoriesTextScrollList`;
	
	doWizDirmapArray($from, $to[0]);
	/*
	dirmap -en true;
	
	for($i=0;$i<`size $from`;$i++){
		dirmap -m $from[$i] $to[0];
		print("WIZ| Mapped Directory: " + $from[$i] + " Onto: " + $to[0] + "\n");
	}
	*/	
	menuItem -e -cb true wizDirmapEnabledMenuItem;
	
}


global proc doWizDirmap()
{
	string $from = `textFieldGrp -q -tx wizDirmapFromTextFieldGrp`;
	string $to = `textFieldGrp -q -tx wizDirmapToTextFieldGrp`;
	
	if(`size $from` == 0){
		string $fromAll[] = `textScrollList -q -ai wizDirmapDirectoriesTextScrollList`;	
		doWizDirmapArray($fromAll, $to);
		return;
	}
	dirmap -en true;
	if (`menuItem -q -cb wizDirmapConvertDirectoryMenuItem`){
		dirmap -m $from $to;
		dirmap -cd $from;
	} else {
		dirmap -m $from $to;
	}
	
	print("WIZ| Mapped Directory: " + $from + " Onto: " + $to + "\n");
	menuItem -e -cb true wizDirmapEnabledMenuItem;
}

global proc doWizDirmapArray(string $from[], string $to)
{
	dirmap -en true;
	for($i=0;$i<`size $from`;$i++){
		if($from[$i] == $to){ continue; }
		if (`menuItem -q -cb wizDirmapConvertDirectoryMenuItem`){
			dirmap -m $from[$i] $to;
			dirmap -cd $from[$i];
		} else {
			dirmap -m $from[$i] $to;
		}

		print("WIZ| Mapped Directory: " + $from[$i] + " Onto: " + $to + "\n");
	}
}

global proc wizDirmapMakePermanent()
{
	//string $userSetup[] = wizReadMelFile(
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			OPENING FILES
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//WIZ OPEN FILE
//=========================================================================================
global proc wizOpenFile( string $file )
{
	/*
	if(catchQuiet(file -o $file)){
		
	}
	*/
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//			REFERENCES
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			DUPLICATE REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//DUPLICATE REFERENCE OBJECT
//--------------------------------------------------------
global proc string[] duplicateReferenceObject( string $obj )
{	
	print ("@duplicateReferenceObject\n");
	
	string $nonsp = $obj;
	string $nonspTok[] = tokenizeString($obj, ":");
	wizlog ("	[#] Duplicate Object : " + $obj);
	if (`size $nonspTok` > 1){
		$nonsp = $nonspTok[(`size $nonspTok` - 1)];
		wizlog ("	[#] Duplicate Object No Namespace: " + $nonsp);
	}
	string $dbl = "-dmi DuplicateReferenceObjectDebugMenuItem -t Duplicate Reference Object"; string $dbm = "add"; int $dbc = 1;
	string $filePath;
	if (catchQuiet(`referenceQuery -f $obj`)){
		print ($obj + " Is Not From A Reference. Searching Relatives For Reference...\n");
		string $rel[] = `listRelatives -ad $obj`;
		for ($i=0;$i<`size $rel`;$i++){
			if (catchQuiet(`referenceQuery -f $rel[$i]`) == 0){
				$filePath = `referenceQuery -f $rel[$i]`;
			}	
		}		

	} else {
		$filePath = `referenceQuery -f $obj`;
	}
	
	
	if ($filePath == ""){
		warning ("WIZ| duplicateReferenceObject : Failed To Find Reference From Selected Object : " + $obj + "\n");
		return {""};
	}
	
	string $newRefFile = wizCreateReference($filePath);
	file -sa $newRefFile;
	string $newRefObj[] = `ls -sl`;
	printNiceArrayList(" - Duplicate Reference Object : ", $newRefObj);
	
	//_________________________________________
	// Transfer Transforms
	/*
	string $search = ("*" + $nonsp + "*");
	string $newObj[] = `ls -r true $search $newRefObj`;
	string $newObjs[] = stringArrayRemove({ $obj }, $newObj);
	
	if (`size $newObj` > 0){
		wizlog ("	[*] transferTransforms(\"" + $obj + "\", \"" + $newObj[0] + "\");");
		transferTransforms($obj, $newObj[0]);
		select -r $newObj[0];
	}
	*/
	
	/*
	string $refEdits = wizCopyReferenceEdits("-src " + $obj + " -dest " + $newRefObj[0]);
	*/
	
	
	debugListArray($dbl, " - Reference Object Copy: ", $newRefObj, $dbc, $dbm, "", 100);
	
	return $newRefObj;
	
}



//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			OPEN REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//OPEN SELECTED OBJECT REFERENCE FILE
//=============================================================
global proc openSelectedObjectReferenceFile(string $sel[])
{
	string $obj = $sel[0];
	string $filePath = `referenceQuery -f $obj`;
	
	string $typ[] = `file -q -typ $filePath`;
	file -f -options "v=0;" -typ $typ[0] -o $filePath;

	addRecentFile($filePath, $typ[0]);	
	
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			CREATE REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//WIZ REFERENCE FILE
//=============================================================
global proc string wizReferenceFile( string $filepath )
{
	string $ext = ("." + `fileExtension $filepath`);
	string $basename = basename($filepath, $ext);
	string $print = "WIZ| Reference File : ";
	string $ns;
	if ($ext == "mb"){
		$print = $print + "file -r -type \"mayaBinary\" -loadReferenceDepth \"all\" -mergeNamespacesOnClash false -namespace " + $basename + " -options \"v=0;\" " + $filepath;
		//file -r -type "mayaBinary" -gl -loadReferenceDepth "all" -mergeNamespacesOnClash false -namespace $basename -options "v=0;" $filepath;
		//file -r -gl -loadReferenceDepth "all" -mergeNamespacesOnClash false -namespace $basename -options "v=0;" $filepath;
		string $newRef = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash false -namespace $basename -options "v=0;" -pmt false $filepath`;
        print ("*************New Reference : " + $newRef + "\n");
        $ns = `referenceQuery -ns $newRef`;
        print ("*****************Namespace : " + $ns + "\n");
	} else {
		//file -r -gl -loadReferenceDepth "all" -mergeNamespacesOnClash false -namespace $basename $filepath;
		file -r -gl -mergeNamespacesOnClash false -namespace $basename -pmt false $filepath;
	}
	
	return $ns;
	
	//string $newRefFile = `file -r -gl -loadReferenceDepth "all" -options "v=0" -pmt false $filepath`;
	
	
}

//WIZ CREATE REFERENCE
//=============================================================
global proc string wizCreateReference( string $filepath )
{
	namespace -set ":";
	string $ext = ("." + `fileExtension $filepath`);
	string $basename = basename($filepath, $ext);
	string $ns = `namespace -vn $basename`;
	string $print = "WIZ| Reference File : ";
	string $ref;
	if ($ext == "mb"){		
		//$ref = `file -r -type "mayaBinary" -gr -mergeNamespacesOnClash false -namespace $ns -options "v=0;" $filepath`;
		//$ref = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash true -namespace ":" -options "v=0;p=17;f=0" $filepath`;
		//$ref = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash false -namespace $ns -options "v=0;p=17;f=0" -pmt false $filepath`;
		$ref = `file -r -type "mayaBinary" -gr -mergeNamespacesOnClash false -namespace $ns -options "v=0;p=17;f=0" -pmt false $filepath`;
		
	} else {
		//$ref = `file -r -gr -mergeNamespacesOnClash false -namespace $basename $filepath`;
		$ref = `file -r -mergeNamespacesOnClash false -namespace $basename $filepath`;
	}
	namespace -set ":";
	return $ref;
	
	
}

//@ WIZ REFERENCE FILE RETURN NEW NODES
//====================================================================
global proc string[] wizReferenceFileReturnNewNodes( string $filepath )
{
	namespace -set ":";
    string $ext = fileExtension($filepath);
	string $basename = basename($filepath, $ext);
	string $ns = `namespace -vn $basename`;
    string $rnn[];

	if ($ext == "mb"){
		//$rnn = `file -r -type "mayaBinary" -mergeNamespacesOnClash true -namespace $ns -options "v=0;" -rnn $filepath`;
		//$rnn = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash true -namespace ":" -options "v=0;p=17;f=0" -rnn $filepath`;
		//$rnn = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash false -namespace $ns -options "v=0;p=17;f=0" -rnn $filepath`;
		$rnn = `file -r -type "mayaBinary" -gl -mergeNamespacesOnClash false -namespace $ns -options "v=0;p=17;f=0" -pmt false -rnn $filepath`;
	} else {
		$rnn = `file -r -mergeNamespacesOnClash false -options "v=0;p=17;f=0" -pmt false -rnn $filepath`;
		//$rnn = `file -r -gl -mergeNamespacesOnClash false -namespace $basename -rnn $filepath`;
	}
	namespace -set ":";
    return $rnn;
}

//@ WIZ GET NAMESPACE FOR FILE
//====================================================================
/*****************************************************************//**
*	Pass a filename and get a validated basename in return.
*	More information.
*	USAGE : 
*
*********************************************************************/
global proc string wizGetNamespaceForFile( string $filepath )
{
	string $ext = `fileExtension $filepath`;
	string $addExt = ("." + `fileExtension $filepath`);
	string $basename = basename($filepath, $addExt);
	string $vn = `namespace -vn $basename`;
	return $vn;
	
}

//REFERENCE SELECTED FILES
//==========================================================
global proc referenceSelectedFiles( string $ref[] )
{
	for ($i=0;$i<`size $ref`;$i++){
		wizReferenceFile($ref[$i]);
	}
}

//REFERENCE ALL FILES IN DIRECTORY
//==========================================================
global proc referenceAllFilesInDirectory()
{
	string $dir = wizGetDirectory();	
		
	string $allFiles[];
	
	string $mb[] = getAllFilesOfTypeInDirectory($dir, "mb");
	print("WIZ|		- Found " + `size $mb` + " Maya Binary Files\n");
	
	string $ma[] = getAllFilesOfTypeInDirectory($dir, "ma");
	print("WIZ|		- Found " + `size $ma` + " Maya ASCII Files\n");
	
	string $fbx[] = getAllFilesOfTypeInDirectory($dir, "fbx");
	print("WIZ|		- Found " + `size $fbx` + " FBX Files\n");
	
	string $obj[] = getAllFilesOfTypeInDirectory($dir, "obj");
	print("WIZ|		- Found " + `size $obj` + " OBJ Files\n");

	appendStringArray($allFiles, $mb, `size $mb`);
	appendStringArray($allFiles, $ma, `size $ma`);
	appendStringArray($allFiles, $fbx, `size $fbx`);	
	appendStringArray($allFiles, $obj, `size $obj`);

	print("WIZ|		- Found " + `size $allFiles` + " To Reference\n");
	
	if(`size $allFiles` == 0){
		print("WIZ| - NO FILES TO REFERENCE - \n");
		return;	
	}
	
	string $m = ("Do You Want To Reference The " + `size $allFiles` + " Files Found In This Directory?\n");
	string $confirm =`confirmDialog 
		-t "Reference All Files In Current Directory"
		-m $m
		-ma "center"	
		-b "Yes" 
		-b "NO" 
		-db "Yes"
		-cb "No"
		`;
		
	if($confirm=="No"){
		print("WIZ| referenceAllFilesInSameDirectoryAsCurrent : CANCELED \n");
		return;
	} 
	
	print("WIZ| Referencing : " + `size $allFiles` + "\n");
	
	string $allRef[] = `file -q -reference`;
	
	for ($i=0;$i<`size $allFiles`; $i++){
		//print("WIZ|		File To Reference : " + $allFiles[$i] + "\n");
		int $skip;
		if ($allFiles[$i] == `file -q -sn`){
			//print("WIZ|		Cannot Reference Self\n");
			continue;
		}
		
		if (size($allRef)){
			for ($r=0;$r<`size $allRef`;$r++){
				if($allRef[$r] == $allFiles[$i]){
					$skip = 1;
				}
			}
		}
		if ($skip == 1){
			print("WIZ|		- File Already Referenced - SKIPPING - \n");
			continue;
		}
	
		//print("WIZ| Ref : " + $ref + " Size Ref: " + `size $ref` + "\n");

		print ("WIZ| Referencing File : " + $allFiles[$i] + "\n");
		
		string $ext = ("." + `fileExtension $allFiles[$i]`);
		string $basename = basename($allFiles[$i], $ext);	
		string $ns = `namespace -vn $basename`;
		string $eval = "file -r -gl -loadReferenceDepth \"all\" -mergeNamespacesOnClash false -pmt false -namespace " + "\"" + $ns + "\" \"" + $allFiles[$i] + "\"";
		eval ($eval);	

	}

	print ("WIZ| referenceAllFilesInSameDirectoryAsCurrent : COMPLETE\n");
}

//REFERENCE FILE NO NAMESPACE
//==========================================================
global proc referenceFileNoNamespace()
{
	string $filename = wizGetMayaFile();
	file -r -type "mayaBinary" -gl -loadReferenceDepth "all" -mergeNamespacesOnClash true -namespace ":" -options "v=0;" $filename;	
	
}

//REFERENCE ALL SELECTED FILES
//==========================================================
global proc referenceAllSelectedFiles()
{
	string $ref[] = `fileDialog2 -fileMode 4 -dialogStyle 1 -okCaption "OK"`;
	for ($i=0;$i<`size $ref`;$i++){
		wizReferenceFile($ref[$i]);
	}
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			QUERY REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//IS REFERENCE OBJECT
//-------------------------------------------------------
global proc int isReferenceObject(string $obj)
{
	int $isReference = `referenceQuery -inr $obj`;
	return $isReference;	
}


//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			REMOVE REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//REMOVE SELECTED OBJECT REFERENCE FILE
//=============================================================
global proc removeSelectedObjectReferenceFile(string $sel[])
{
	for ($i=0;$i<`size $sel`;$i++){
		//string $obj = $sel[0];
		string $filePath = `referenceQuery -f $sel[$i]`;
		
		//string $typ[] = `file -q -typ $filePath`;
		file -f -rr $filePath;

	}
	
}



//REMOVE UNLOADED REFERENCES
//-------------------------------------------------------
global proc removeUnloadedReferences()
{
	string $referencePresent[] = `file -q -reference`;
	if (`size $referencePresent` > 0){
		for ($i=0;$i<`size $referencePresent`;$i++){
			//if ref unloaded then remove.
			if (!`referenceQuery -isLoaded $referencePresent[$i]`){
				file -rr $referencePresent[$i];
			}
		}
	}
}


//REMOVE ALL REFERENCES
//-------------------------------------------------------
global proc removeAllReferences()
{
	string $referencePresent[] = `file -q -reference`;
	if (`size $referencePresent` > 0){
		for ($i=0;$i<`size $referencePresent`;$i++){
			file -rr $referencePresent[$i];
		}
	}
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			UNLOAD REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//UNLOAD ALL REFERENCES
//-------------------------------------------------------
global proc unloadAllReferences()
{
	string $referencePresent[] = `file -q -reference`;
	if (`size $referencePresent` > 0){
		for ($i=0;$i<`size $referencePresent`;$i++){
			file -ur $referencePresent[$i];
		}
	}
}


//REMOVE SELECTED OBJECT REFERENCE FILE
//=============================================================
global proc unloadSelectedReferenceObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		string $rfn = `referenceQuery -rfn $sel[$i]`;
        if (`size $rfn` > 0){
            file -ur $rfn;
        }
	}
	
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			REFRESH REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//REFRESH SELECTED REFERENCE OBJECTS
//---------------------------------------------------------
global proc refreshSelectedReferenceObjects()
{
	string $sel[] = `ls -sl`;
	int $i;
	for ($i=0;$i<`size $sel`;$i++){
		string $filePath = `referenceQuery -f $sel[$i]`;
		string $refNode = `file -q -rfn $filePath`;
		file -lr $refNode;
	}
}

//REFRESH SELECTED REFERENCE OBJECTS
//---------------------------------------------------------
global proc refreshAllReferences()
{
	string $references[] = `file -q -reference`;
		
	if (`size $references` > 0){
		for ($i=0;$i<size($references);$i++){
			file -lr $references[$i];
		}
	}
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			IMPORTING REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//IMPORT ALL REFERENCES
//-------------------------------------------------------
global proc importAllReferences()
{
	//for ($l=0;$l<3;$l++){
		string $referencePresent[] = `file -q -reference`;
		if (`size $referencePresent` > 0){
			for ($i=0;$i<`size $referencePresent`;$i++){
				//if ref loaded then  import ref
				if (`referenceQuery -isLoaded $referencePresent[$i]` ){
					file -importReference $referencePresent[$i];
				}
			}
		}
	//}
}


global proc importAllReferencesRecursively()
{
	string $referencePresent[] = `file -q -reference`;
	while (`size $referencePresent` > 0){
		$referencePresent = `file -q -reference`;
		wizlog (niceArrayList("[#] References [#]", $referencePresent));
		if (`size $referencePresent` > 0){
			for ($i=0;$i<`size $referencePresent`;$i++){
				//if ref loaded then  import ref
				if (`referenceQuery -isLoaded $referencePresent[$i]` ){
					wizlog (" [+] Importing Reference : " + $referencePresent[$i]);
					file -importReference $referencePresent[$i];
				} else {
					wizlog (" [-] Removing Unloaded Reference : " + $referencePresent[$i]);
					file -rr $referencePresent[$i];
					
				}
			}
		} else {
			wizlog ("[FINISHED IMPORTING REFERENCES]");
			return;	
		}
	}
	//}
}

global proc loadChildRefRecursively( string $flags )
{
	
	string $sel[] = `ls -type reference`;
	string $ch[];
	string $return[];
	for ($i=0;$i<`size $sel`;$i++){
		int $il = `referenceQuery -il $sel[$i]`;
		if ($il == 0){
			file -lr $sel[$i];
		}
		
		$ch = `referenceQuery -ch -rfn $sel[$i]`;
		wizlog (niceArrayList("[#] Child References", $ch));
		appendStringArray($return, $ch, `size $ch`);
		
		for ($c=0;$c<`size $ch`;$c++){
			file -lr $ch[$c];
			
		}
		
	}
	
	if (`size $return` > 0){
		select -r $ch;
		loadChildRefRecursively();	
	}
	
}

//IMPORT SELECTED OBJECTS REFERENCES
//-------------------------------------------------------
global proc importSelectedObjectsReferences( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		string $ref = `referenceQuery -f $sel[$i]`;
		if ($ref == ""){ continue; }
		file -importReference $ref;
	}
}



//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			LOAD REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//LOAD ALL REFERENCE ORIGINALS
//-------------------------------------------------------
global proc loadAllReferenceOriginals()
{
	string $ref[] = `ls -type reference`;
	for ($i = 0;$i < `size $ref`; $i++){
		string $tag = `getAttr ($ref[$i] + ".proxyTag")`;
		if ($tag == "original"){
			catchQuiet(`proxySwitch $ref[$i]`);
		}
	}

}

//LOAD ALL REFERENCE PROXIES
//-------------------------------------------------------
global proc loadAllReferenceProxies()
{
	string $ref[] = `ls -type reference`;
	for ($i = 0;$i < `size $ref`; $i++){
		if ($ref[$i] == "sharedReferenceNode"){ continue; }
		string $tag = `getAttr ($ref[$i] + ".proxyTag")`;
		if ($tag != "original"){
			catchQuiet(`proxySwitch $ref[$i]`);
		}
	}

}

//@ WIZ REPLACE ALL SELECTED REFERENCES
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc wizReplaceAllSelectedReferences( string $flags )
{
	wizlog ("[@] wizReplaceAllSelectedReferences");
	wizlog ("	[FLAGS] " + $flags );
	
	string $obj, $rf;
	string $sel[];
	int $edit;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-rf" : case "-replacementFile" :
			$rf = $tok[($i + 1)];
			break ;
			
		}
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	
	if (`size $rf` == 0){
		$rf = wizGetMayaFile();
	}
	
	for ($i=0;$i<`size $sel`;$i++){
		string $rfn = `referenceQuery -rfn $sel[$i]`;
        if (`size $rfn` > 0){
			wizlog ("	[*] file -loadReference " + $rfn + " -type \"mayaBinary\" -options \"v=0;\" \"" + $rf + "\";");
            //file -ur $rfn;
			int $fileTest = `filetest -e $rfn`;
			if ($fileTest == 1){
				file -loadReference $rfn -type "mayaBinary" -options "v=0;" $rf;
			} else {
				file -loadReference $rfn -type "mayaAscii" -options "v=0;" $rf;
			}
			
			
       }
	}

}


//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			MOVING REFERENCES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//@ WIZ MOVE ALL REFERENCES TO DIRECTORY
//==========================================================
global proc wizMoveAllReferencesToDirectory( string $action )
{
	string $dir = wizGetDirectory();

	string $ref[] = `file -q -reference`;
	string $newRef[];
	for ($i=0;$i<`size $ref`;$i++){
		$newRef[`size $newRef`] = wizMoveReferenceToDirectory($ref[$i], $dir, $action);
		
	}
	if (`size $newRef` != `size $ref`){
		print ("WIZ| wizMoveAllReferencesToDirectory : Could Not Move All Files!\n");
		return;
	}
	
	for ($i=0;$i<`size $newRef`;$i++){
		string $rn = `referenceQuery -rfn $ref[$i]`;
		//string $type[] = `file -q -type $ref[$i]`;
		if (`confirmStep(("Going To Replace Reference : " + $rn + "\n - Old : " + $ref[$i] + "\n - New : " + $newRef[$i]))` == 0){
			return;
		}
		file -loadReference $rn -type "mayaBinary" -options "v=0;" $newRef[$i];
		if (`confirmStep(("Replaced Reference : " + $rn + "\n - Old : " + $ref[$i] + "\n - New : " + $newRef[$i]))` == 0){
			return;
		}
	}
	
	
}

//@ WIZ MOVE REFERENCE TO DIRECTORY
//==========================================================
global proc string wizMoveReferenceToDirectory( string $ref, string $dir, string $action )
{
	string $newRef;

	string $bn = basename($ref, "");
	string $to = $dir + $bn;
	
	$newRef = $to;
	if ($action == "copy"){
		copyFileFromTo($ref, $to);
	} else if ($action == "move"){
		moveFileFromTo($ref, $to);
	}
	print ("WIZ| wizMoveAllReferenceToDirectory : " + $action + "\n"
	+" - From : " + $ref + " - To : " + $to + "\n");
	
	return $newRef;	

}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			REFERENCE EDITS
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//@ WIZ REMOVE REFERENCE EDITS ON SELECTED OBJECTS
//==============================================================	
global proc wizRemoveReferenceEditsOnSelectedObjects( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		wizRemoveReferenceEditsOnSelectedObject($sel[$i]);
	}

}

//@ WIZ REMOVE REFERENCE EDITS ON SELECTED OBJECT
//==============================================================	
global proc wizRemoveReferenceEditsOnSelectedObject( string $sel )
{
	//string $sel[] = `ls -sl`;
	string $selLong[] = `ls -l -sl`;
	string $rfn = `referenceQuery -rfn $sel`;
	print ("Reference Node : \n" + $rfn + "\n\n");

	string $es[] = `referenceQuery -es $sel`;
	print ("Edit Strings : \n" + stringArrayToString($es, "\n") + "\n\n");

	
	string $en[] = `referenceQuery -en $sel`;
	print ("Edit Nodes : \n" + stringArrayToString($en, "\n") + "\n\n");

	//string $sel[] = `ls -sl`;
	string $ea[] = `referenceQuery -ea $sel`;
	print ("Edit Attributes : \n" + stringArrayToString($ea, "\n") + "\n\n");
	
	string $pt = "Delete Edits";
	string $mes = ("There Are : " + (`size $ea`) + " On : " + $sel + " - Are You Sure You Want To Delete Edits?");
	
	string $confirm = wizConfirmDialog($pt, $mes, { "OK", "Cancel" }, "OK", "Cancel");
	if ($confirm == "Cancel"){		
		return ;		
	}
	
	string $ec[] = { "addAttr", "connectAttr", "deleteAttr", "disconnectAttr", "parent", "setAttr", "lock", "unlock" };
	for ($i=0;$i<`size $ec`;$i++){
		for ($a=0;$a<`size $ec`;$a++){
			referenceEdit -failedEdits true -successfulEdits true -ec $ec[$a] -removeEdits ($sel + "." + $ea[$i]);
			referenceEdit -failedEdits true -successfulEdits true -ec $ec[$a] -removeEdits $sel;
		}
		
	}
	print (" - Removed : " + `size $ec` + " : Edits On : " + $sel + "\n");
}

//@ WIZ REMOVE ALL FAILED REFERENCE EDITS ON SELECTED OBJECTS REFERENCES
//==============================================================	
global proc wizRemoveAllFailedReferenceEditsOnSelectedObjectsReferences( string $sel[] )
{
	for ($i=0;$i<`size $sel`;$i++){
		wizRemoveAllFailedReferenceEditsOnSelectedObjectReference($sel[$i]);
	}
}

global proc wizRemoveAllFailedReferenceEditsOnSelectedObjectReference( string $sel )
{
	//string $sel[] = `ls -sl`;
	string $rfn = `referenceQuery -rfn $sel`;
	//print ("Reference Node : \n" + $rfn + "\n\n");

	//referenceEdit -failedEdits true -successfulEdits true -ec $ec[$a] -removeEdits ($sel + "." + $ea[$i]);
	referenceEdit -failedEdits true -successfulEdits false -removeEdits $rfn;
	
}

//@ WIZ PRINT ALL FAILED REFERENCE EDITS
//==============================================================
global proc wizPrintAllFailedReferenceEdits()
{
	string $ref[] = `file -q -reference`;
	print ("FAILED REFERENCE EDITS : \n" + wizDiv("s") + "\n");
	for ($i=0;$i<`size $ref`;$i++){
		string $failed[] = `referenceEdit -failedEdits true -successfulEdits false $ref[$i]`;
		print (" - Reference : " + $ref[$i] + "\n" + wizDiv("se") + "\n");
		print (stringArrayToString($failed, "\n") + "\n");
		print (wizDiv("end") + "\n");
	}

}

//@ WIZ PRINT REFERENCE LIST
//=======================================================
global proc string[] wizPrintReferenceList()
{
	string $rn[] = `ls -type reference`;
	print("Reference Nodes : \n" + stringArrayToString($rn, "\n") + "\n");
	string $ref[];
	for ($i=0;$i<`size $rn`;$i++){
		if (catchQuiet(`referenceQuery -f $rn[$i]`)){
			continue;
		}
		string $rf = `referenceQuery -f $rn[$i]`;
		$rf = removeAllSpaces($rf);
		if (endsWith($rf, "}")){
			continue;
		}
		$ref[`size $ref`] = $rf;
		
	}
	stringArrayRemoveDuplicates($ref);	
	
	string $localPath = `getenv MAYA_APP_DIR`;
	$localPath = $localPath + "/projects";
	
	string $sceneFile = getCurrentFileNameNoPathNoExt();
	string $file = `file -q -sn`;
	$file = stringRemovePrefix($file, $localPath);	
	
	string $refFiles[] = stringArrayRemovePrefix($ref, $localPath);
	print ("File Name : " + $sceneFile + " Location : " + $file + "\n" + wizDiv("se") + "\n");
	print (" - Reference Files - \n" + wizDiv("startList") + stringArrayToString($refFiles, "\n") + "\n" + wizDiv("end"));
	
	return $ref;

/*
	string $references[] = `file -rdi 9999 -q -r`;
	string $sceneFile = getCurrentFileNameNoPathNoExt();
	string $localPath = `getenv MAYA_APP_DIR`;
	$localPath = $localPath + "/projects";
	string $refFiles[] = stringArrayRemovePrefix($references, $localPath);
	
	print("File Name : " + $sceneFile + "\n" + wizDiv("se") + "\n");
	print("Reference Files : \n" + wizDiv("startList") + stringArrayToString($refFiles, "\n") + "\n" + wizDiv("end"));
	
	string $allRef[];
	string $levRef[];
	int $maxLev = 10;
	int $il = 0;
	string $tab = "	";
	//print("Reference Files : \n" + wizDiv("startList") + stringArrayToString($references, "\n") + "\n" + wizDiv("end"));
	
	while( true ){

		for ($i=0;$i<`size $references`;$i++){
		//print ("file -q -r \"" + $references[$i] + "\";" + "/");
			string $checkRef = $localPath + $references[$i];
			//print ("file -q -r \"" + $references[$i] + "\";" + "/");
			if (catchQuiet(`file -q -r $checkRef`)){
				//print("	- Reference Not Found : " + $checkRef + "\n");
				continue;
			}
			
			string $refChild[] = `file -q -r $checkRef`;
			appendStringArray($allRef, $refChild, `size $refChild`);
			appendStringArray($levRef, $refChild, `size $refChild`);
		
		}
		string $pr[] = stringArrayRemovePrefix($levRef, $localPath);
		print (wizDiv("se") + "\n" + $tab + stringArrayToString($levRef, ("\n" + $tab)) + "\n");
		$tab = $tab + $tab;
		
		$il++;
		
		if (`size $levRef` == 0 || $il >= $maxLev){
			break;
		}
		$references = $levRef;
		
	}
	print(wizDiv("end"));
	
	//print("File Name : " + $sceneFile + "\n" + wizDiv("se") + "\n");
	//print("Reference Files : \n" + wizDiv("startList") + stringArrayToString($refFiles, "\n") + "\n" + wizDiv("end"));
	return $allRef;
	*/
}

//@ WIZ PRINT REFERENCE LIST WEB LINKS
//-------------------------------------------------------
global proc string[] wizPrintReferenceListWebLinks()
{
	string $sceneFile = getCurrentFileNameNoPathNoExt();
	string $file = `file -q -sn`;
	string $localPath = `getenv MAYA_APP_DIR`;
	$localPath = $localPath + "/projects";
	
	string $ref[] = wizPrintReferenceList();
	string $url = "wiz.plasticarm.com/projects/maya/projects";
	$ref = stringArrayAddPrefix($ref, $url);	
	
	$file = stringRemovePrefix($file, $localPath);
	$file = stringAddPrefix($file,$url);

	print ("File Name : " + $sceneFile + " Location : " + $file + "\n" + wizDiv("se") + "\n");
	print (" - Reference Files - \n" + wizDiv("startList") + stringArrayToString($ref, "\n") + "\n" + wizDiv("end"));
	
	return $ref;
	
}


//@ WIZ COPY REFERENCE EDITS
//====================================================================
/*****************************************************************//**
	Creates a temporary reference edit file for the source and applies
	the edits to the destination object.
	
	<hr>
	<b>Synopsis</b><br>
	wizCopyReferenceEdits [-fa string] [-fb linear] <br>
	
	<b>Return value</b><br>
	string the reference edit file.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-source(-src) <br>
	-destination(-dest) <br>
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $refEditFile = wizCopyReferenceEdits("-sl");
	
	</code>
*********************************************************************/
global proc string wizCopyReferenceEdits( string $flags )
{
	wizLog ("[@] wizTempExportEdits\n");
	string $src;
	string $dest;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$src = $tok[($i + 1)];
			break;
				
			case "-sl" : case "-selected" :
			string $sl[] = `ls -sl`;
			$src = $sl[0];
			$dest = $sl[1];
			break ;
	
			case "-src" : case "-source" :
			$src = $tok[($i + 1)];
			break;
			
			case "-dest" : case "-destination" :
			$dest = $tok[($i + 1)];
			break;
		}
	}
	if (`size $src` == 0){
		string $sel[] = `ls -sl`;
		$obj = $sel[0];
	}
	string $ws = `workspace -q -rd`;
	$ws = $ws + "scenes/edits/tempRefEdits.editMA";
	string $srcOrn = `referenceQuery -rfn $src`;
	exportEdits -f -type "editMA" -orn $srcOrn -includeNetwork -includeAnimation -includeShaders -includeSetAttrs 1 $ws;

	string $ns = `referenceQuery -rfn $dest`;
	
	file -r -type "editMB" -namespace "tempRefEdits" -applyTo $ns $ws;
	
	return $ws;
	
}

//REMOVE SELECTED OBJECT REFERENCE FILE
//=============================================================
global proc selecteObjectsReferenceNode( string $sel[] )
{
	select -cl;
	for ($i=0;$i<`size $sel`;$i++){
		string $rfn = `referenceQuery -rfn $sel[$i]`;
        if (`size $rfn` > 0){
            select -add $rfn;
        }
	}
	
}

//@ GET NAME SPACE FROM OBJECT
//====================================================================
/*======================| SUMMARY |===================================
	This just gets the namespace from the objects name
/*=======================| USAGE |===================================
string $sel[] = `ls -sl`;
getNameSpaceFromObject($sel[0]);
====================================================================*/
global proc string getNameSpaceFromObject( string $obj )
{
	string $tokNS[] = tokenizeString($obj, ":");
	string $nsPrefix;
	if (`size $tokNS` > 1){
		stringArrayRemoveAtIndex((`size $tokNS` - 1), $tokNS);
		if (`size $tokNS` == 1){
			$nsPrefix = $tokNS[0] + ":";
		} else {
			$nsPrefix = stringArrayToString($tokNS, ":");
			$nsPrefix = $nsPrefix + ":";
		}
		/*
		for ($i=0;$i<(`size $tokNS` - 1);$i++){
			$nsPrefix = $nsPrefix + ":" + $tokNS[$i];
		}
		*/
	}	
	return $nsPrefix;
}


//CLEAN ALL REFERENCES
//-------------------------------------------------------
global proc wizCleanAllReferences()
{
	//for ($l=0;$l<3;$l++){
		string $referencePresent[] = `file -q -reference`;
		if (`size $referencePresent` > 0){
			for ($i=0;$i<`size $referencePresent`;$i++){
				file -cr $referencePresent[$i];
				
			}
		}
	//}
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         IMPORTING
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//@ IMPORT ALL SELECTED FILES
//============================================
global proc importAllSelectedFiles()
{
    string $files[] = wizGetMultipleFiles();
    for ($i=0;$i<`size $files`;$i++){
        file -f -i $files[$i];
    }
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         SAVING
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//SAVE FUNCTIONS
//========================================================================================
//REWIND AND SAVE
//----------------------------------------------
global proc remwindAndSave()
{
	float $startTime = `playbackOptions -q -min`;
	currentTime -edit $startTime;	
	file -save;
}

//RESET AND SAVE
//----------------------------------------------
global proc resetAndSave()
{
	global int $tempDisabled;
	int $reDisable = 0;
	float $curTime = `currentTime -q`;
	float $startTime = `playbackOptions -q -min`;
	currentTime -edit $startTime;	
	if($tempDisabled == 1){
		enableExpressionsAndFluidEvaluations();
		$reDisable = 1;
	}
	file -save;
	if($reDisable == 1){
		disableExpressionsAndFluidEvaluations();	
	}
	currentTime -edit $curTime;	

}

//INCREMENT AND SAVE
//----------------------------------------------
//Increments A File Automatically
/*
<NAME> jgIncrementalSave.mel </NAME>
<VERSION> v1.0 </VERSION>
<AUTHORS> Jay Grenier (jay@jaygrenier.com) </AUTHORS>

<DESCRIPTION>

	Automatically increments your scene file.  Adds a number to the end of the filename if one
	does not exist already.

	Adds the previous file to your recently opened files list.

</DESCRIPTION>

<TO_USE>

	1. Source Script To Increment.  Adding a shelf button that calls it is the easiest and most convenient way.

<HISTORY>

	v1.0 (Thursday, September 16, 2010)
		o Release

</HISTORY>

*/

// **********************************************************   
// Automatically Increments A Saved Maya File
//@ PROC NAME
//====================================================================
/*****************************************************************//**
	Automatically Increments A Saved Maya File.
	<hr>
	<b>Synopsis</b><br>
	procName [-tag1 string] [-tag2 linear] <br>
	Just increments the filename and saves.
	
	<b>Return value</b><br>
	none.
	
	<b>Flags</b><br>
	
	<hr>
	<b>Examples</b><br>
	<code>
	incrementAndSaveWiz();
	
	</code>
*********************************************************************/
global proc incrementAndSaveWiz()
{
	wizLog("[@] incrementAndSaveWiz");
	// Scene File Name
	string $sceneFile = `file -q -sn` ;
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;
	if ($extension == "mb" || $extension ==  "ma") {
		// Tokenize Filename
		string $buffer[] ;
		tokenize $sceneFile "." $buffer ;
		
		// Recompile Scenename Without Extension
		for ($i=0;$i<(size($buffer)-1);$i++){
			$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
		}
	
	} else {	
		// Error Check
		error "Current file isn't .mb or .ma, please save before incrementing." ;
	
	}
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if ($currentVersion == "") $currentVersion = "00" ;
	
	// Increment Version
	int $int = $currentVersion ;
	$int++ ;
	
	// Pad Digits If Needed
	int $beforeCount = size($currentVersion) ;
	string $incVersion = $int ;
	int $afterCount = size($incVersion) ;
	if ($beforeCount > $afterCount) {
		while($beforeCount > $afterCount) {
			$incVersion = ("0"+$incVersion) ;
			$afterCount = size($incVersion) ;
		}
	}
	
	// Make New Filename
	string $newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
	
	// Save It
	file -rename $newFileName ;
	file -f -save ;
	
	// Add To Recent File List
	if ($extension == "mb") catch(`addRecentFile $newFileName "mayaBinary"`) ;
	if ($extension == "ma") catch(`addRecentFile $newFileName "mayaAscii"`) ;
	
	// Finish
	wizLog ("	[+] Saved as "+$newFileName+"\n") ;
    autoSaveSceneThumbnailImage();
}

global proc wizIncrementAndSave( string $flags )
{
	int $se;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-se" : case "-skipExisting" :
			$se = 1;
			break ;
		
		}
	}
	
	wizLog ("[@] wizIncrementAndSave");
	// Scene File Name
	string $sceneFile = `file -q -sn` ;
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;
	if ($extension == "mb" || $extension ==  "ma") {
		// Tokenize Filename
		string $buffer[] ;
		tokenize $sceneFile "." $buffer ;
		
		// Recompile Scenename Without Extension
		for ($i=0;$i<(size($buffer)-1);$i++){
			$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
		}
	
	} else {	
		// Error Check
		error "Current file isn't .mb or .ma, please save before incrementing." ;
	
	}
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if ($currentVersion == "") $currentVersion = "00" ;
	
	// Increment Version
	int $int = $currentVersion ;
	$int++ ;
	
	// Pad Digits If Needed
	int $beforeCount;
	string $incVersion;
	int $afterCount;
	string $newFileName;
	if ($se){

		while (true){
			
			// Pad Digits If Needed
			$beforeCount = size($currentVersion) ;
			$incVersion = $int ;
			$afterCount = size($incVersion) ;
			if ($beforeCount > $afterCount) {
				while ($beforeCount > $afterCount) {
					$incVersion = ("0"+$incVersion) ;
					$afterCount = size($incVersion) ;
				}
			}
		
			$newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
			int $exists = `filetest -e $newFileName`;
			if ($exists == 0){
				
				break ;
			}
			wizlog ("[FILE EXISTS] : " + $newFileName + " : [SKIPPING]");
			$int++;
			
		}
	} else {
		// Pad Digits If Needed
		$beforeCount = size($currentVersion) ;
		$incVersion = $int ;
		$afterCount = size($incVersion) ;
		if ($beforeCount > $afterCount) {
			while($beforeCount > $afterCount) {
				$incVersion = ("0"+$incVersion) ;
				$afterCount = size($incVersion) ;
			}
		}
	}
	
	
	// Make New Filename
	
	// Save It
	file -rename $newFileName ;
	file -f -save ;
	
	// Add To Recent File List
	if ($extension == "mb") catch(`addRecentFile $newFileName "mayaBinary"`) ;
	if ($extension == "ma") catch(`addRecentFile $newFileName "mayaAscii"`) ;
	
	// Finish
	wizLog ("	[+] Saved as "+$newFileName+"\n") ;
    autoSaveSceneThumbnailImage();
	
}

//@ WIZ SAVE AND ARCHIVE
//====================================================================
/*****************************************************************//**
	Creates a copy of file in the current directory in a new folder
	called Archive and then saves.
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-fa, -fb
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-fa aString -fb anotherString");
	
	</code>
*********************************************************************/
global proc wizSaveAndArchive()
{
	string $sceneFile = `file -q -sn`; 
	string $ext = `fileExtension $sceneFile`;
	string $splice[] = wizSpliceFilePath($sceneFile, "-dir -fn");
	string $archiveDir = $splice[0] + "Archive/";
	string $newDir = wizMakeDir($archiveDir);
    if ($newDir == ""){ return;}
	
    string $date = getFileNameDate();
    
    string $destFile = $archiveDir + $splice[1] + "_" + $date + "." + $ext;
	//string $destFile = getIncrementedFileVersionName(($archiveDir + $splice[1] + "." + $ext));
	
	sysFile -cp $destFile $sceneFile;
	
	wizlog ("	[*] sysFile -cp " + $destFile + " " + $sceneFile);
	
	file -f -save ;
	
	autoSaveSceneThumbnailImage();
	
}

global proc wizSaveRenderCopy()
{
	string $sceneFile = `file -q -sn`; 
	string $ext = `fileExtension $sceneFile`;
	string $splice[] = wizSpliceFilePath($sceneFile, "-dir -fn");
	string $archiveDir = $splice[0] + "Render/";
	string $newDir = wizMakeDir($archiveDir);
    if ($newDir == ""){ return;}
	
    string $date = getFileNameDate();
    
    string $destFile = $archiveDir + $splice[1] + "_Render_" + $date + "." + $ext;
	//string $destFile = getIncrementedFileVersionName(($archiveDir + $splice[1] + "." + $ext));
	
	sysFile -cp $destFile $sceneFile;
	
	wizlog ("	[*] sysFile -cp " + $destFile + " " + $sceneFile);
	
	//file -f -save ;
	
	//autoSaveSceneThumbnailImage();
	
}

//@ WIZ ARCHIVE SELECTED FILES
//====================================================================
/*****************************************************************//**
	Creates a copy of selected files in the current directory in a new folder
	called Archive.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc wizArchiveSelectedFiles()
{
	string $files[] = wizGetMultipleFiles();
	for ($i=0;$i<`size $files`;$i++){
		wizArchiveFile($files[$i]);	
	}
	

}

global proc wizArchiveFile( string $file )
{
	string $ext = `fileExtension $file`;
	string $splice[] = wizSpliceFilePath($file, "-dir -fnnv");
	string $archiveDir = $splice[0] + "Archive/";
	string $newDir = wizMakeDir($archiveDir);
    if ($newDir == ""){ return;}
	
    string $date = getFileNameDate();
    
    string $destFile = $archiveDir + $splice[1] + "_" + $date + "." + $ext;

	sysFile -cp $destFile $file;
	
	wizlog ("	[*] Archive File : sysFile -cp " + $destFile + " " + $file);

}


global proc string getFileNameDate()
{
	
	string $date = `date`;
	string $addDate = substituteAllString($date, "/", "");
	$addDate = substituteAllString($addDate, " ", "");
	$addDate = substituteAllString($addDate, ":", "");
	//print ($addDate + "\n");
	return $addDate;
	
}

//@ INCREMENT AND SAVE FILE BY NUMBER
//=======================================================
// **********************************************************   
// Automatically Increments A Saved Maya File
global proc incrementAndSaveFileByNumber( int $int )
{
	// Scene File Name
	string $sceneFile = `file -q -sn` ;
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;
	if($extension == "mb" || $extension ==  ".ma") {
		// Tokenize Filename
		string $buffer[] ;
		tokenize $sceneFile "." $buffer ;
		
		// Recompile Scenename Without Extension
		for($i=0;$i<(size($buffer)-1);$i++){
			$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
		}
	
	} else {	
		// Error Check
		error "Current file isn't .mb or .ma, please save before incrementing." ;
	
	}
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if($currentVersion == "") $currentVersion = "00" ;
	
	// Pad Digits If Needed
	int $beforeCount = size($currentVersion) ;
	string $incVersion = $int ;
	int $afterCount = size($incVersion) ;
	if($beforeCount > $afterCount) {
		while($beforeCount > $afterCount) {
			$incVersion = ("0"+$incVersion) ;
			$afterCount = size($incVersion) ;
		}
	}
	
	// Make New Filename
	string $newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
	
	// Save It
	file -rename $newFileName ;
	file -f -save ;
	
	// Add To Recent File List
	if($extension == "mb") catch(`addRecentFile $newFileName "mayaBinary"`) ;
	if($extension == "ma") catch(`addRecentFile $newFileName "mayaAscii"`) ;
	
	// Finish
	print ("Saved as "+$newFileName+"\n") ;
    saveSceneThumbnailImage();
}

//@ INCREMENT NEW FILE
//=======================================================
global proc string incrementNewFile()
{
	// Scene File Name
	string $sceneFile = `file -q -sn` ;
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;
	if($extension == "mb" || $extension ==  ".ma") {
		// Tokenize Filename
		string $buffer[] ;
		tokenize $sceneFile "." $buffer ;
		
		// Recompile Scenename Without Extension
		for($i=0;$i<(size($buffer)-1);$i++){
			$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
		}
	
	} else {	
		// Error Check
		error "Current file isn't .mb or .ma, please save before incrementing." ;
	
	}
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if($currentVersion == "") $currentVersion = "00" ;
	
	// Increment Version
	int $int = $currentVersion ;
	$int++ ;
	
	// Pad Digits If Needed
	int $beforeCount = size($currentVersion) ;
	string $incVersion = $int ;
	int $afterCount = size($incVersion) ;
	if($beforeCount > $afterCount) {
		while($beforeCount > $afterCount) {
			$incVersion = ("0"+$incVersion) ;
			$afterCount = size($incVersion) ;
		}
	}
	
	// Make New Filename
	string $newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
	
	// Make New File and Save It
	file -save;
	file -new;
	file -rename $newFileName;
	file -f -save;

	// Add To Recent File List
	if($extension == "mb") catch(`addRecentFile $newFileName "mayaBinary"`) ;
	if($extension == "ma") catch(`addRecentFile $newFileName "mayaAscii"`) ;
	
	// Finish
	print ("New File Saved as "+$newFileName+"\n") ;
	return $newFileName;
}

// GET FILE VERSION NUMBER
//=============================================================
global proc int getFileVersionNumber( string $filename )
{
	//string $dir = dirname($filename);
	//string $ext = `fileExtension $filename` ;
	if ($filename == ""){
		warning ("WIZ| getFileVersionNumber : Filename : " + $filename + "\n");
		print ("Check To See If The Current File Is Saved!\n");
	}
	print ("WIZ| getFileVersionNumber : Filename : " + $filename);
	string $bn = basenameEx($filename);
	print (" Basename : " + $bn);
	int $v = int(`match "[0-9]+" $bn`);
	
	print (" Version : " + $v + "\n");
	return $v;
}

// GET LATEST FILE VERSION
//=============================================================
/*======================| SUMMARY |===================================
This returns the last number in a series of numbered files.
/*======================| USAGE |=====================================
getLatestFileVersionNumber("/Volumes/Shared3/projects/Assets/scenes/Shaders/Terrain/Construction/TerrainShaderConstruction18.mb");
		
====================================================================*/
global proc int getLatestFileVersionNumber( string $filename )
{
	string $dir = dirname($filename);
	string $nameNoVersion = getFileNameNoPathNoExtNoNumber($filename);
	string $fileList[] = `getFileList -fld $dir -filespec ("*" + $nameNoVersion + "*")`;
	print ("Directory : " + $dir + "\n" + wizDiv("s") + " - " + stringArrayToString($fileList, "\n - ") + "\n");	
	
	int $versions[];
	for ($i=0;$i<`size $fileList`;$i++){
		$versions[`size $versions`] = int(`match "[0-9]+" $fileList[$i]`);
	}
	
	int $sorted[] = sort($versions);
	print ("Sorted : " + "\n" + wizDiv("s") + " - " + intArrayToString($sorted, "\n - ") + "\n");
	
    int $latest;
    if (`size $sorted` < 2 ){
        $latest = $sorted[0];
    } else {
        $latest = $sorted[(`size $sorted` - 1)];
    }
	return $latest;
}

//GET INCREMENTED FILE VERSION NAME
//=======================================================
/*
    Just returns the file name after finding the latest version number and incrementing it
    
*/
global proc string getIncrementedFileVersionName( string $filename )
{
	wizlog ("[@] getIncrementedFileVersionName");
	
	string $ext = fileExtension($filename);
	//string $filename = "/Volumes/Shared3/projects/Assets/scenes/Shaders/Terrain/Construction/TerrainShaderConstruction18.mb";
	string $dir = dirname($filename);
	string $nameNoVersion = getFileNameNoPathNoExtNoNumber($filename);
	string $fileList[] = `getFileList -fld $dir -filespec ("*" + $nameNoVersion + "*")`;
	print ("Directory : " + $dir + "\n" + wizDiv("s") + " - " + stringArrayToString($fileList, "\n - ") + "\n");	
	
	int $versions[];
	for ($i=0;$i<`size $fileList`;$i++){
		$versions[`size $versions`] = int(`match "[0-9]+" $fileList[$i]`);
	}
	
	int $sorted[] = sort($versions);
	int $latest;
	if (`size $sorted` == 0){
		$latest = 0;
	} else {
		$latest = $sorted[(`size $sorted` - 1)];
	}
	//print ("Sorted : " + "\n" + wizDiv("s") + " - " + intArrayToString($sorted, "\n - ") + "\n");
	wizlog ("	[-] Lastest File Version : " + $latest);
	
    $latest++;
    string $newFileName = $dir + "/" + $nameNoVersion + $latest + "." + $ext;
    
	return $newFileName;
}

//WIZ INCREMENT AND EXPORT SELECTED OBJECTS
//=============================================================
global proc wizIncrementAndExportSelectedObjects( string $file , string $sel[] )
{
    string $newFileName = getIncrementedFileVersionName($file);

    select -r $sel;

    wizExportMB($newFileName);
	       
	// Finish
	print ("New File Saved as "+$newFileName+"\n") ;
  
    
}
//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			COPY FILES
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//CREATE A COPY
//-------------------------------------------------
global proc createACopy( string $sourceFile )
{
	//string $sourceFile = `file -q -sn`;
	string $copySuffix = "_copy";
	string $destFile = addSuffixToFileName($sourceFile,$copySuffix);
	
	string $os = `about -os`;
	/*
	if($os == "mac"){
		$sourceFile = "'" + $sourceFile + "'";
		$destFile = "'" + $destFile + "'";
	} else if($os == "nt" || $os == "win64"){
		$sourceFile = "'" + $sourceFile + "'";
		$destFile = "'" + $destFile + "'";
	} else if($os == "linux" || $os == "linux64"){
		$sourceFile = "'" + $sourceFile + "'";
		$destFile = "'" + $destFile + "'";
	}
	*/
	
	// -cp Dest Source
	sysFile -cp $destFile $sourceFile;
	print("Created A Copy: "+ $destFile + "\n");
}



//SAVE A COPY
//-----------------------------------------------
global proc saveACopy()
{
	//ToDO: It would be good if we checked if the copy already existed and created incremented copies.
	
	// Scene File Name
	string $sceneFile = `file -q -sn` ;
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;
	if($extension == "mb" || $extension ==  ".ma") {
		// Tokenize Filename
		string $buffer[] ;
		tokenize $sceneFile "." $buffer ;
		
		// Recompile Scenename Without Extension
		for ($i=0;$i<(size($buffer)-1);$i++){
			$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
		}
	
	} else {	
		// Error Check
		error "Current file isn't .mb or .ma, please save before incrementing." ;
	
	}
	
	string $newFileName = $fileNameNoExt + "_Copy";
	/*
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if($currentVersion == "") $currentVersion = "00" ;
	
	// Increment Version
	int $int = $currentVersion ;
	$int++ ;
	
	// Pad Digits If Needed
	int $beforeCount = size($currentVersion) ;
	string $incVersion = $int ;
	int $afterCount = size($incVersion) ;
	if($beforeCount > $afterCount) {
		while($beforeCount > $afterCount) {
			$incVersion = ("0"+$incVersion) ;
			$afterCount = size($incVersion) ;
		}
	}
	
	// Make New Filename
	string $newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
	*/
	
	// Save It
	file -rename $newFileName ;
	file -f -save ;
	
	// Add To Recent File List
	if($extension == "mb") catch(`addRecentFile $newFileName "mayaBinary"`) ;
	if($extension == "ma") catch(`addRecentFile $newFileName "mayaAscii"`) ;
	
	// Finish
	print ("Saved as "+$newFileName+"\n") ;	
}


//@ COPY FILE FROM TO
//===============================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	copyFileFromTo($source, $dest);
	
	</code>
*********************************************************************/
global proc copyFileFromTo( string $source, string $dest)
{
	//Make sure that we are passed the complete directory and filename
	//If not... put it together.
	string $sourceExt = ("." + `fileExtension $source`);
	string $sourceBasename = basename($source, $sourceExt);
	
	string $destExt = ("." + `fileExtension $dest`);
	string $destBasename = basename($dest, $destExt);
	
	if ($sourceBasename != $destBasename){
	
	}
	
	if (`sysFile -cp $dest $source`){
		return;
	} else {
		print ("WIZ| copyFileFromTo : Could Not Copy File : " + $source + "\n");
	}
}

//@ MOVE FILE FROM TO
//===============================================================
global proc moveFileFromTo( string $source, string $dest)
{
	//Make sure that we are passed the complete directory and filename
	//If not... put it together.
	string $sourceExt = ("." + `fileExtension $source`);
	string $sourceBasename = basename($source, $sourceExt);
	
	string $destExt = ("." + `fileExtension $dest`);
	string $destBasename = basename($dest, $destExt);
	
	if ($sourceBasename != $destBasename){
	
	}
	
	//sysFile -mov $dest $source;
	if (`sysFile -move $dest $source`){
		return;
	} else {
		print ("WIZ| moveFileFromTo : Could Not Move File : " + $source + "\n");
	}
}

//COPY FOLDER FROM TO
//-----------------------------------------------------
global proc copyFolderFromTo(string $source, string $dest)
{
	string $sysCopyCommand;
	string $sysCommand;
	//Get what system we are on and use system specific commands
	string $os = `about -os`;
	if ($os == "mac"){
		//Mac system copy command. Must have entire path on both sides
		//cp -r -f '/Users/glen/Library/Preferences/Autodesk/maya/2013-x64/' '/Users/glen/Google Drive/Maya/2013-x64/'
		$source = "'" + $source + "'";
		$dest = "'" + $dest + "'";
		$sysCopyCommand = "cp -r -f ";
		$sysCommand = $sysCopyCommand + $source + " " + $dest;
	} else if($os == "nt" || $os == "win64"){
		//PC system copy command. Must convert to native path first. No slash at end.
		//http://commandwindows.com/xcopy.htm
		//xcopy C:\source C:\destination /E /Y /I
		//xcopy C:\Users\Glen\Documents\Projects\Wiz\test\testSource C:\Users\Glen\Documents\Projects\Wiz\test\SomeOtherPlace\testSource /E /Y /I
		//xcopy "C:\Users\Glen\Documents\Projects\Wiz\test\testSource" "C:\Users\Glen\Documents\Projects\Wiz\test\SomeOtherPlace\testSource" /E /Y /I
		//XCOPY /E /Y /I "C:\Users\Glen\Documents\Projects\Wiz\test\testSource" "C:\Users\Glen\Documents\Projects\Wiz\test\SomeOtherPlace\testSource"
		//string $source = "C:\Users\Glen\Documents\Projects\Wiz\test\testSource\"
		//Remove trailing slash/
		string $endString = endString($source, 1);
		if ($endString == "/"){
			$source = getDirectoryFromFullFilePath($source);
		}
		$endString = endString($dest, 1);
		if ($endString == "/"){
			$dest = getDirectoryFromFullFilePath($dest);
		}
		//Convert to native path
		$source = toNativePath($source);
		$dest = toNativePath($dest);
		
		//Add quotes for safety
		$source = "\"" + $source + "\"";
		$dest = "\"" + $dest + "\"";
		
		//Add the system copy commands
	$sysCopyCommand = "XCOPY /E /Y /I ";
	$sysCommand = $sysCopyCommand + $source + " " + $dest;
	} else if($os == "linux" || $os == "linux64"){
		print("WIZ| WHAT? LINUX? WHO THE FUCK ARE YOU? You cann't copy files untill fileWiz:copyFolderFromTo is modified." + "\n");
	}
	debugML3("CopyFolderFromTo SysCommand: " + $sysCommand + "\n");
	system($sysCommand);

}


//@ WIZ MAKE DIR
//====================================================================
global proc string wizMakeDir( string $dir )
{
	if (`filetest -e $dir` == 0){
		sysFile -makeDir $dir;	
        return $dir;
	}
	if (`filetest -e $dir` == 0){
        error ("WIZ| wizMakeDir : Could Not Make Directory : " + $dir + "\n");
		return "";
	} else {
    
		return $dir;
	}
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			FILE PATH STRINGS
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//GET FILE NAME NO PATH NO EXT
//===============================================================
global proc string getFileNameNoPathNoExt( string $fileName )
{

	string $ext = `fileExtension $fileName` ;
	string $bn = basename($fileName, $ext);
	$bn = substituteAllString($bn, ".", "");
	return $bn;
	
}

//GET CURRENT FILE NAME NO PATH NO EXT
//===============================================================
global proc string getCurrentFileNameNoPathNoExt()
{
	string $fileName = `file -q -sn` ;
	string $ext = `fileExtension $fileName` ;
	string $bn = basename($fileName, $ext);
	$bn = substituteAllString($bn, ".", "");
	return $bn;	
}

// GET FILE NAME NO PATH NO EXT NO NUMBER
//=============================================================
global proc string getFileNameNoPathNoExtNoNumber( string $filename )
{

	// Get File Extension
	string $bn = getFileNameNoPathNoExt($filename);
	
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $bn`;
	
	return $nameWithNoVersion;
	
}

//@ ADD SUFFIX TO FILE NAME
//=================================================
global proc string addSuffixToFileName(string $filename, string $suffix)
{
	//Get File Extension
	string $extension = `fileExtension $filename`;
	
	// Remove Extension
	/*
	string $removeEx = "." + $extension;
	string $basename = basename($filename, $removeEx);
	*/
	// Tokenize Filename
	string $buffer[] ;
	tokenize $filename "." $buffer ;
	
	// Recompile Scenename Without Extension
	string $fileNameNoExt;
	for($i=0;$i<(size($buffer)-1);$i++){
		$fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
	}
	//Add the suffix and the dot and the extension
	string $newFileName = $fileNameNoExt + $suffix + "." + $extension;
	return $newFileName;

}

//@ GET DIRECTORY FROM FULL FILE PATH
//=================================================

/*
string $dir = wizGetDirectory();
print ("Dir : " + $dir + "\n");
string $files[] = getAllFilesOfTypeInDirectory($dir, "obj");    
print ("File : " + $files[0] + "\n");
string $path = $files[0];
string $newPath = getDirectoryFromFullFilePath($path);

*/
global proc string getDirectoryFromFullFilePath( string $filename )
{
    string $ext = fileExtension($filename);
    string $bn = basename($filename, "" );
    string $dir = `substitute $bn $filename ""`;
   // print ("File : " + $filename + "\n");
   // print ("Directory : " + $dir + "\n");
    return $dir;
}


//@ WIZ INCREMENT FILE NAME
//==============================================================
global proc string wizIncrementFileName( string $filename )
{    
	// Get File Extension
	string $extension = `fileExtension $filename` ;
	
	// Remove Extension
	string $fileNameNoExt ;

    // Tokenize Filename
    string $buffer[] ;
    tokenize $filename "." $buffer ;
    
    // Recompile Scenename Without Extension
    for ($i=0;$i<(size($buffer)-1);$i++){
        $fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
    }
	
	// Extract Name And Current Version Using Regex
	string $nameWithNoVersion = `match ".*[^0-9]" $fileNameNoExt` ;
	string $currentVersion = `match "[0-9]+$" $fileNameNoExt` ;
	
	// Check For Integer, Add One If None
	if ($currentVersion == "") $currentVersion = "00" ;
	
	// Increment Version
	int $int = $currentVersion ;
	$int++ ;
	
	// Pad Digits If Needed
	int $beforeCount = size($currentVersion) ;
	string $incVersion = $int ;
	int $afterCount = size($incVersion) ;
	if ($beforeCount > $afterCount) {
		while($beforeCount > $afterCount) {
			$incVersion = ("0"+$incVersion) ;
			$afterCount = size($incVersion) ;
		}
	}
	
	// Make New Filename
	string $newFileName = ($nameWithNoVersion+$incVersion+"."+$extension) ;
    return $newFileName;
}

//@ REMOVE EXTENSION
//=======================================================
global proc string removeExtension( string $filename )
{
    // Get File Extension
	string $extension = `fileExtension $filename` ;
	
	// Remove Extension
	string $noExt[] = tokenizeString($filename, ".");
    return $noExt[0];

}

//@ WIZ GET LOCAL PROJECT DIRECTORY
//=======================================================
global proc string wizGetLocalProjectDirectory()
{
	string $lpd;
	string $wizProjectDir = `optionVar -q WIZ_wizProjectDirectory`;
	if ($wizProjectDir != ""){
		$lpd = $wizProjectDir;	
		return $lpd;
	}
}

//@ WIZ SPLICE FILE PATH
//====================================================================
/*****************************************************************//**
	Use flags to specify what part of a file path you want returned.
	
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	Returns a string array with the requested parts ordered in which
    they were requested.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-localProjectDirectory(-lpd) : Local Project Directory -lpd ("C:/Users/Someone/Maya/") <br>
	-projectPath(-pp) : Project Path -pp ("/ProjectName/scenes/someScene/") <br>
	-directory(-dir) : Directory -dir ("C:/Users/Someone/Maya/projects/ProjectName/scenes/SomeFolder/") <br>
	-fullFileName(-ffn) : Full File Name/ File Name Extension -ffn, -fne ("SomeFileName1.mb") <br>
	-fileName(-fn) : File Name -fn, -fnne ("SomeFileName1") <br>
	-fileNameNoVersion(-fnnv) : File Name No Version -fnnv ("SomeFileName") <br>
	-fileVersion(-fv) : File Version -fv -v ("1") <br>
	-sequenceNumber(-sn) : Sequence Number -sn -v ("0001") <br>
	-extension(-ex) : Extension -ex, -ext ("mb") <br>
	-rootDirectory(-rd) : ("C:/Users/Someone/Maya/projects/ProjectName/") <br>
	-sceneFile(-sf) : ("C:/Users/Someone/Maya/projects/ProjectName/scenes/currentlyOpenedFilename.mb") <br>
	
	<hr>
	
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $filePath = wizGetAnyFile();
	//string $filePath = "/Volumes/Shared3/projects/Assets/scenes/Shaders/Terrain/Construction/TerrainShaderConstruction18.mb";
	string $filePathSplice[] = wizSpliceFilePath($filePath, "-lpd -pp -dir -pn -fn -ex -ffn -fnnv -fv");
	
	</code>
*********************************************************************/
global proc string[] wizSpliceFilePath( string $filePath , string $tags )
{
	//wizlog ("[@] wizSpliceFilePath");
	//wizlog ("	[*] wizSpliceFilePath(\"" + $filePath + "\", \"" + $tags + "\");");
	
	string $return[];
	string $tok[] = tokenizeString($tags, " ");
	
	string $lpd = wizGetLocalProjectDirectory();
	string $dir = getDirectoryFromFullFilePath($filePath);
	string $pn = `workspace -q -act`;
	$pn = `substitute $lpd $pn ""`;
	
	string $pp = `substitute $lpd $filePath ""`;
	$pp = `substitute "/Volumes" $pp ""`;
	
	
	string $fn = getFileNameNoPathNoExt($filePath);
	string $ffn = basename($filePath, "");
	$pp = `substitute $ffn $pp ""`;
	$pp = `substitute $pn $pp ""`;
	
	string $seqNumTok[] = tokenizeString($filePath, ".");
	int $sn;
	if (`size $seqNumTok` == 3){
		$sn = $seqNumTok[1];
	}
	
	string $fnnv = getFileNameNoPathNoExtNoNumber($filePath);
	string $ext = `fileExtension $filePath` ;
	int $fv = getFileVersionNumber($filePath);
	//print ("WIZ| wizSpliceFilePath : " + $filePath + " : Tags : " + $tags + "\n" + wizDiv("s"));
	
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-lpd" : case "-localProjectDirectory" :
			$return[$i] = $lpd;
			//print ("Local Project Directory : " + $lpd + "\n");
			break;
			
			case "-pp" : case "-projectPath" :
			$return[$i] = $pp;
			//print ("Project Path : " + $pp + "\n");
			break;
			
			case "-dir" : case "-directory" :
			$return[$i] = $dir;
			//print ("Directory : " + $dir + "\n");
			break;
			
			case "-rd" : case "-rootDirectory" :
			$return[$i] = `workspace -q -rd`;
			//print ("Directory : " + $dir + "\n");
			break;
			
			case "-pn" : case "-projectName" :
			$return[$i] = $pn;
			//print ("Project Name: " + $pn + "\n");
			break;
			
			case "-fn" : case "-fileName" : case "-fnne" : case "-fileNameNoExt" :
			$return[$i] = $fn;
			//print ("File Name : " + $fn + "\n");
			break;
			
			case "-ffn" : case "-fullFileName" :
			$return[$i] = $ffn;
			//print ("Full File Name : " + $ffn + "\n");
			break;
			
			case "-fnnv" : case "-fileNameNoVersion" :
			$return[$i] = $fnnv;
			//print ("File Name No Version : " + $fnnv + "\n");
			break;
			
			case "-fv" : case "-fileVersion" : case "-v" : case "-version" :
			$return[$i] = $fv;
			//print ("File Version : " + $fv + "\n");
			break;
			
			case "-ex" : case "-extension" : case "-ext" : 
			$return[$i] = $ext;
			//print ("Extension : " + $ext + "\n");
			break;
			
			case "-sn" : case "-sequenceNumber" :
			$return[$i] = $sn;
			//print ("Extension : " + $ext + "\n");
			break;
			
			
		}
	}
	//wizlog ("	[#] Splice : " + stringArrayToString($return, " "));
	
	//print (wizDiv("end"));
	return $return;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			EXPORTING
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//EXPORT EACH SELECTION TO SEPARET MAYA FILE
//================================================================================
global proc exportEachSelectionToSeparetMayaFile( string $sel[] , string $type, int $ref )
{
	string $dir = wizGetDirectory();
	string $ext = ".mb";
	/*
	string $ext;
	switch($type){
		case "mayaBinary" :
		$ext = ".mb";
		break;
		
		case "mayaAscii" :
		$ext = ".ma";
		break;
	}
	*/
	for ($i=0;$i<`size $sel`;$i++){
		select -r $sel[$i];
		string $filename = removeIllegalCharactersFromName($sel[$i]);
		string $exportFile = ($dir + $filename + $ext);
		if ($ref == 1){
			file -f -type "mayaBinary" -namespace $sel[$i] -options "v=0;" -er $exportFile;
		} else {
			file -force -options "v=0;" -typ "mayaBinary" -pr -es $exportFile;
		}
	}
}


//EXPORT EACH SELECTION TO SEPARET MAYA FILE
//================================================================================
global proc wizExportEachSelectionToFile( string $flags )
{
	string $dir;
	string $ext = ".mb";
	string $typ = "mayaBinary";
	string $obj, $type;
	int $pfn = 0; // prefix file name
	string $sel[] = `ls -sl`;
	int $ref;
	int $edit;
	int $genThumb = 0;
	string $prefixFileName = "";
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;		
				
			case "-typ" : case "-type" :
			$type = $tok[($i + 1)];
			break ;
			
			case "-mb" :
			$ext = ".mb";
			break ;
			
			case "-ma" :
			$ext = ".ma";
			break ;
			
			case "-obj" :
			$ext = ".obj";
			$typ = "obj";
			break ;
			
			case "-dir" :
			$dir = $tok[($i + 1)];
			break ;
			
			case "-pfn" :
			$pfn = 1;
			break ;
			
			case "-wc" : 
			global string $WIZ_subFileFolderSuffix;
			string $curFile = `file -q -sn`;
			string $filePathSplice[] = wizSpliceFilePath($curFile, "-fn -dir -ex");
			$prefixFileName = $filePathSplice[0] + "_";
			string $newDir = wizMakeDir(($filePathSplice[1] + $filePathSplice[0] + $WIZ_subFileFolderSuffix + "/"));			
			$dir = $newDir;
			$genThumb = 1;
			wizlog ("[#] Wizcraft Directory : " + $dir);
			break ;
		}
	}
	
	if ($dir == ""){
		wizlog ("[#] No Directory Specified : Prompt For Directory ");
		$dir = wizGetDirectory();
	}
	
	switch ($type){
		case "mayaAscii" :
		$ext = ".ma";
		break ;
		case "mayaBinary" :
		$ext = ".mb";
		break ;
		case "obj" :
		$ext = ".obj";
		break ;
		case "fbx" :
		$ext = ".fbx";
		break ;
		case "abc" :
		$ext = ".abc";
		break ;
		
		
	}
	
	wizlog ("[wizExportEachSelectionToFile] : File Type : " + $type);
	
	for ($i=0;$i<`size $sel`;$i++){
		select -r $sel[$i];
		
		// Skip meshes that are hidden
		string $visSel[] = `ls -v -sl`;
		if (`size $visSel` == 0){
			continue ;
		}
		
		string $filename = removeIllegalCharactersFromName($sel[$i]);
		
		if ($pfn){
			$filename = $prefixFileName + $filename;
		}
		string $exportFile = ($dir + $filename + $ext);
		wizlog ("[wizExportEachSelectionToFile] : FileName : " + $exportFile);
				
		if ($type == "mayaBinary"){
			if ($ref == 1){
				file -f -type "mayaBinary" -namespace $sel[$i] -options "v=0;" -er $exportFile;
			} else {
				file -force -options "v=0;" -typ "mayaBinary" -pr -es $exportFile;
			}
		}
		if ($type == "mayaAscii"){
			if ($ref == 1){
				file -f -type "mayaAscii" -namespace $sel[$i] -options "v=0;" -er $exportFile;
			} else {
				file -force -options "v=0;" -typ "mayaAscii" -pr -es $exportFile;
			}
		}
		
		if ($type == "obj"){
			wizExportOBJ($exportFile);
		}
		if ($type == "fbx"){
			wizExportFBX($exportFile);
		}
		if ($type == "abc"){
			select -r $sel[$i];
			wizExportCacheFile("-sl -f " + $exportFile);

		}
		
		if ($genThumb){
			wizMeshThumbnailImage($exportFile);
		}
		
		
	}
	
	
}


//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			EXPORT PATH ATTRIBUTE
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//@ ADD EXPORT FILE PATH ATTRIBUTE TO SELECTED
//=============================================================================
/*====================== SUMMARY =====================================

	This adds a new attribute to the selected node that can
	contain a file path.
	You can then use :  : to 
	update the file specified in the exportPath attribute.
	The file does not have to exist yet to use this.
	
====================================================================*/
global proc addExportFilePathAttributeToSelected( string $sel[] )
{
	for($i=0;$i<`size $sel`;$i++){
		string $obj = $sel[$i];	
		string $file = wizGetAnyFile();
		print ("New File Export Path : " + $file + "\n");
	
		addAttr -dt "string" -ln "exportPath" -uaf $obj;	
		setAttr -type "string" ($obj + ".exportPath") $file;
	}
		
}

//@ EXPORT NODES WITH EXPORT PATH
//=============================================================================
/*====================== SUMMARY =====================================

	This will export files for any objects that have a
	exportPath attribute created from the above proc

====================================================================*/
global proc exportNodesWithExportPaths()
{

	string $return[];
	string $all[] = `ls`;
	string $epNodes[];
	for ($i=0;$i<`size $all`;$i++){
		if(`attributeExists "exportPath" $all[$i]`){
			string $ep = `getAttr ($all[$i] + ".exportPath")`;
			print ("WIZ| Exporting : " + $all[$i] + " : To File : " + $ep + "\n");
			string $ext = `fileExtension $ep`;
			select -r $all[$i];
			
			switch ($ext){
				case "fbx" :
				wizExportFBX($ep);
				break;
				case "obj" :
				wizExportOBJ($ep);
				break;
				case "mb" :
				wizExportMB($ep);
				break;
				case "ma" :
				wizExportMB($ep);
				break;
				
			}
			
		}
	}
		
}

//@ EXPORT SELECTED OBJECTS USING EXPORT PATHS
//=============================================================================
global proc exportSelectedObjectsUsingExportPaths( string $sel[])
{
	for ($i=0;$i<`size $sel`;$i++){
		exportSelectedObjectUsingExportPath($sel[$i]);
		
	}
}

global proc int exportSelectedObjectUsingExportPath( string $sel)
{
	if (`attributeExists "exportPath" $sel` == 0){
		return 0;
	}
	string $ep = `getAttr ($sel + ".exportPath")`;
	print ("WIZ| Exporting : " + $sel + " : To File : " + $ep + "\n");
	string $ext = `fileExtension $ep`;
	select -r $sel;
	
	switch ($ext){
		case "fbx" :
		wizExportFBX($ep);
		break;
		case "obj" :
		wizExportOBJ($ep);
		break;
		case "mb" :
		wizExportMB($ep);
		break;
		case "ma" :
		wizExportMA($ep);
		break;
		
	}
	return 1;
		
}

global proc incrementAndExportObjectsUsingExportPath( string $type )
{
    string $export[];
    if ($type == "all"){
        $export = getAllObjectsWithExportPath();
    
    } else {
        $export = `ls -sl`;
    }

    for ($i=0;$i<`size $export`;$i++){
        string $ep = `getAttr ($export[$i] + ".exportPath")`;
        string $incName = getIncrementedFileVersionName($ep);
        setAttr ($export[$i] + ".exportPath") -type "string" $incName;
        exportSelectedObjectUsingExportPath($export[$i]);
    }

		
}

global proc string[] getAllObjectsWithExportPath()
{
    string $return[];
	string $all[] = `ls`;
	string $epNodes[];
	for ($i=0;$i<`size $all`;$i++){
		if (`attributeExists "exportPath" $all[$i]`){
            $epNodes[`size $epNodes`] = $all[$i];			
		}
	}
    return $epNodes;
}
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			EXPORT FILE TYPES
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////////////
//
//		Description: 	This just exports fbx files
//				
//
/////////////////////////////////////////////////////////////////////////////////////	
global proc string wizExportFBX( string $filename )
{
	if ($filename == ""){
		print("WIZ| Cannot Export FBX : No File Name Provided\n");
		return $filename;	
	}
	if (endsWith($filename, ".fbx") == 0){
		string $extension = `fileExtension $filename`;
		if (`size $extension` > 0){
			string $bn;
			if (endsWith($filename, "*") == 1){
				$bn = basename($filename, "*");
			} else {
				$bn = basename($filename, $extension);
			}
				string $path = getPathPart($filename);
				
				$filename = $path + "/" + $bn;
		}
		$filename = $filename + ".fbx";
		
	}
	print("FBX Filename: " + $filename + "\n");

	//file -force -options -typ "FBX export" -es $filename;
	//FBXExport -f $filename -caller FBXMayaTranslator  -exportFormat "fbx;v=0";
	//file -force -options "v=0;" -typ "FBX export" -es $filename;
	//file -force -typ "FBX export" -es $filename;
	
	//FBXExport Add FBX_Root node -v FBX201300 -f $filename -s;
	
	//FBXExport Add FBX_Root node -v FBX201300 -f $filename -caller FBXMayaTranslator -exportFormat "fbx;v=0" -s;

	file -force -options "v=0;" -typ "FBX export" -es $filename;

	return $filename;
		
}

/////////////////////////////////////////////////////////////////////////////////////
//
//		WIZ EXPORT OBJ
//		Description: 	This just exports OBJ files
//				
//
/////////////////////////////////////////////////////////////////////////////////////	
global proc string wizExportOBJ( string $filename )
{
	if ($filename == ""){
		print("WIZ| Cannot Export OBJ : No File Name Provided\n");
		return $filename;	
	}
	if (endsWith($filename, ".obj") == 0){
		string $extension = `fileExtension $filename`;
		if (`size $extension` > 0){
			string $bn;
			if (endsWith($filename, "*") == 1){
				$bn = basename($filename, "*");
			} else {
				$bn = basename($filename, $extension);
			}
				string $spliceFile[] = wizSpliceFilePath($filename, "-dir");
				//string $path = getPathPart($filename);
				string $path = $spliceFile[0];
				
				$filename = $path + "/" + $bn;
		}
		$filename = $filename + ".obj";
		wizlog ("[FILENAME] + .OBJ : " + $filename);
	}
	print ("OBJ Filename: " + $filename + "\n");
	
	//file -force -options "v=0;" -typ "OBJ" -es $filename;
	file -force -options "groups=1;ptgroups=1;materials=1;smoothing=1;normals=1" -type "OBJexport" -pr -es $filename;
	
	return $filename;
		
}

/////////////////////////////////////////////////////////////////////////////////////
//
//		Description: 	This just exports mb files
//				
//
/////////////////////////////////////////////////////////////////////////////////////	

global proc string wizExportMB( string $filename )
{
	//string $ns = getFileNameNoPathNoExt($filename);
	//string $exported = `file -f -type "mayaBinary" $ns -options "v=0;" -pr -es $filename`;
	string $exported = `file -f -type "mayaBinary" -options "v=0;" -pr -es $filename`;
	//file -force -options "v=0;" -typ "mayaBinary" -pr -es $exportFile;
	return $exported;
			
}

/////////////////////////////////////////////////////////////////////////////////////
//
//		Description: 	This just exports ma files
//				
//
/////////////////////////////////////////////////////////////////////////////////////	

global proc string wizExportMA( string $filename )
{
	//string $ns = getFileNameNoPathNoExt($filename);
	if (`size $filename` == 0){
		$filename = `file -q -sn`; 
	}
	string $sel[] = `ls -sl`;
	string $exported;
	
	if (`size $sel` == 0){
		$exported = `file -f -type "mayaAscii" -options "v=0;" -pr -ea $filename`;
	} else {
		$exported = `file -f -type "mayaAscii" -options "v=0;" -es $filename`;
	}
	//file -force -options "v=0;" -typ "mayaBinary" -pr -es $exportFile;
	return $exported;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			COMMA SEPARATED VALUE FILES - CSV
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//READ CSV DATA FILE
//===============================================================
global proc string[] readCSVDataFile(string $file)
{
	int $fileId =`fopen $file "r"`;
	string $s;
	$s = `fread $fileId $s`;
	string $ss[] = {$s};
	fclose $fileId;
	return $ss;
}

//WIZ READ CSV TEXT FILE
//===================================================================
global proc string[] wizReadCSVTextFile( string $file )
{
	$fileId=`fopen $file "r"`;
	string $data[];
	int $lineCount = 0;
	int $colCount;
	while ( !`feof $fileId` ){
		string $nextLine = `fgetline $fileId`;
		if($nextLine == ""){ continue;}
		
		//replace commas with comma space so we don't end up skipping cells
		$nextLine = substituteAllString($nextLine, ",", ", ");
		
		string $tok[] = tokenizeString($nextLine, ",");		
		$colCount = `size $tok`;	

		appendStringArray($data,$tok,`size $tok`);

		$lineCount++;
	}
	fclose $fileId;

	return $data;	
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			TEXT FILES
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//WIZ READ TEXT FILE BY LINE
//===============================================================
global proc string[] wizReadTextFileByLine( string $file )
{
	$fileId = `fopen $file "r"`;
	string $data[];
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 ) {
		$data[`size $data`] = $nextLine;
		$nextLine = `fgetline $fileId`;
	}
	fclose $fileId;
		
	return $data;
}

//WIZ WRITE TEXT FILE BY LINE
//==============================================================
global proc string wizWriteTextFileByLine( string $file , string $data[] )
{
	int $fileId = `fopen $file "w"`;
	for ($i=0;$i<`size $data`;$i++){
			fprint $fileId ($data[$i] + "\n");

	}
	
	fclose $fileId;
	return $file;	
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			MEL FILES
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//WIZ READ MEL FILE
//===============================================================
global proc string[] wizReadMelFile(string $file)
{
	int $fileId =`fopen $file "r"`;
	string $s;
	$s = `fread $fileId $s`;
	string $ss[] = tokenizeString($s, " ");;
	fclose $fileId;
	return $ss;
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			GET FILES/DIRECTORIES FROM FILE DIALOG
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			WIZ GET FILES DIALOG
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//WIZ GET MAYA FILE
//==========================================================
//@ PROC NAME
//====================================================================
/*****************************************************************//**
	Opens a file dialog to select an existing file and returns the name
	of the file.
	<hr>
	<b>Examples</b><br>
	<code>
	string $myFile = wizGetMayaFile();
	
	</code>
*********************************************************************/
global proc string wizGetMayaFile()
{
	global string $WIZ_fileBrowserStartingDirectory;	
	string $sel[] = `fileDialog2 -fileMode 1 -dialogStyle 2 -startingDirectory $WIZ_fileBrowserStartingDirectory -okCaption "OK"`;
	string $splice[] = wizSpliceFilePath($sel[0], "-dir");
	$WIZ_fileBrowserStartingDirectory = $splice[0];
		
	return $sel[0];
}

//WIZ GET ANY FILE
//==========================================================
global proc string wizGetAnyFile()
{
	global string $WIZ_fileBrowserStartingDirectory;
	string $sel[] = `fileDialog2 -fileMode 0 -dialogStyle 2 -startingDirectory $WIZ_fileBrowserStartingDirectory -okCaption "OK"`;
	string $splice[] = wizSpliceFilePath($sel[0], "-dir");
	$WIZ_fileBrowserStartingDirectory = $splice[0];
	
	return $sel[0];
}

//WIZ GET MULTIPLE FILES
//==========================================================
global proc string[] wizGetMultipleFiles()
{
	global string $WIZ_fileBrowserStartingDirectory;	
	string $sel[] = `fileDialog2 -fileMode 4 -dialogStyle 1 -startingDirectory $WIZ_fileBrowserStartingDirectory -okCaption "OK"`;
	string $splice[] = wizSpliceFilePath($sel[0], "-dir");
	$WIZ_fileBrowserStartingDirectory = $splice[0];
	
	return $sel;
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			GET ALL FILES OF TYPE
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//GET ALL FILES OF TYPE IN DIRECTORY
//================================================================================
global proc string[] getAllFilesOfTypeInDirectory( string $dir, string $type )
{
	string $types[] = tokenizeString($type, " ");	
	
	string $return[];
	for ($i=0;$i<`size $types`;$i++){	
		string $files[];
		if ($type == ""){
			$files = `getFileList -folder $dir -filespec ("*.*")`;
		} else {
			$files = `getFileList -folder $dir -filespec ("*." + $types[$i])`;
		}
		
		if (`size $files` > 0){
			addPrefixToStringArray($files, $dir);
			appendStringArray($return, $files, `size $files`);
		}
	
	}
	return $return;
	
}

global proc string[] wizGetFiles( string $flags )
{
	
	string $filename;
	string $files[];
	string $dir;
	string $dirs[];
	string $return[];
	string $type[];
	string $sel[];
	int $isd;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-dir" : case "-directory" :
			$dir = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type[`size $type`] = $tok[($i + 1)];
			break ;
				
			case "-isd" : case "-includeSubDirectory" :
			$isd = 1;
			break ;
			
		}
	}
	
	if ($isd){
		$dirs = wizGetAllSubFoldersOfDirectory($dir);
		wizlog (niceArrayList("[#] Include All Sub Directories[#]", $dirs));
	} else {
		wizlog ("[#] Get Files From Directory : " + $dir);
		$dirs[0] = $dir;	
	}
	
	
	for ($i=0;$i<`size $dirs`;$i++){	
	
		for ($t=0;$t<`size $type`;$t++){	
			string $files[];
			if ($type[$t] == ""){
				$files = `getFileList -folder $dirs[$i] -filespec ("*.*")`;
			} else {
				$files = `getFileList -folder $dirs[$i] -filespec ("*." + $type[$t])`;
			}
			
			wizlog (niceArrayList(("Files In Directory : " + $dirs[$i]), $files));
			if (`size $files` > 0){
				addPrefixToStringArray($files, $dirs[$i]);
				appendStringArray($return, $files, `size $files`);
			}
		
		}
	}
	
	return $return;
		
	
	
}

//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
//			WIZ GET DIRECTORIES DIALOG
//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------

//GET DIRECTORY FILE DIALOG
//==========================================================

global proc string wizGetDirectory()
{
	global string $WIZ_fileBrowserStartingDirectory;
	string $sel[] = `fileDialog2 -fileMode 2 -dialogStyle 2 -startingDirectory $WIZ_fileBrowserStartingDirectory -okCaption "OK"`;
	$sel[0] = $sel[0] + "/";
	
	$WIZ_fileBrowserStartingDirectory = $sel[0];
	
	return $sel[0];
}


//@ WIZ GET ALL SUB FOLDERS OF DIRECTORY
//================================================================================
/*
wizGetAllSubFoldersOfDirectory("/Shared3/projects/FutureSpace-GJ/scenes/Planets/Europa/");
*/
/*
global proc string[] wizGetAllSubFoldersOfDirectory( string $dir )
{
	string $fl[] = `getFileList -fld $dir`;
	string $singleTab = "-";
	string $tab = "-";
	string $sf[];
	$sf[0] = $dir;
	string $allsfld[];
	print (wizDiv("se") + "\n" + "All Sub-Folders Of Directory: " + $dir + "\n" + wizDiv("s"));
	while (true){	
		string $levsf[];
		for ($i=0;$i<`size $sf`;$i++){
			string $sfld[] = getSubfoldersInDirectory($sf[$i]);
			addPrefixToStringArray($sfld, $searchDirs[$i]);
			if (`size $sfld` > 0){
				print ($tab + stringArrayToString($sfld, ("\n" + $tab)) + "\n");
				$levsf = stringArrayCatenate($levsf, $sfld);
				$allsfld = stringArrayCatenate($allsfld, $sfld);
			}
			print ("Sub Folder In : " + $sf[$i] + "\n - " + stringArrayToString($levsf, "\n - ") + "\n");
			
		}
		print ("LevSF : \n - " + stringArrayToString($levsf, "\n - ") + "\n");
		$tab = $tab + $singleTab;
		if (`size $levsf` == 0){
			break;
		}
		clear $sf;
		$sf = $levsf;
		clear $levsf;
	}
	print (wizDiv("end") + "\n");
	return $allsfld;
}
*/

//@ WIZ GET ALL SUB FOLDERS OF DIRECTORY
//================================================================================	
global proc string[] wizGetAllSubFoldersOfDirectory(string $dir)
{
	string $subFolder[];
	string $allsfld[];
	
	string $singleTab = "-";
	string $tab = "-";
	
	string $searchDirs[] = { $dir };
	string $remove[];
	string $subFolderDown[]; //This will contain all the folders that are a level down from the current directory
	//print (wizDiv("se") + "\n" + "All Sub-Folders Of Directory: " + $dir + "\n" + wizDiv("s"));
	
	int $ok = 1;
	int $stopCount = 0;

	while ($ok == 1){

		for ($i=0;$i<`size $searchDirs`;$i++){	
			string $newSubFolder[] = getSubfoldersInDirectory($searchDirs[$i]);	
			
			if (`size $newSubFolder` > 0){
				$newSubFolder = addPathToSubFolders($newSubFolder,$searchDirs[$i]);
				appendStringArray($subFolderDown,$newSubFolder,`size $newSubFolder`);			
			} 
			$remove[`size $remove`] = $searchDirs[$i];
				
			//Put the current directory name into the scripts list with a separator
			//This is so when we create a menu we can group scripts by their containing folders
			string $searchDirBasename = basename($searchDirs[$i], "");
			$allsfld = stringArrayCatenate($allsfld, $newSubFolder);
			$newSubFolder = stringArrayRemoveEmptyIndices($newSubFolder);
			//print ($tab + " : " + stringArrayToString($newSubFolder, ("\n" + $tab + " : ")) + "\n");
			
		}
		
		$searchDirs = stringArrayRemove($remove,$searchDirs);
	
		//Add folders that did have sub directorys to our search directory list
		appendStringArray($searchDirs, $subFolderDown, `size $subFolderDown`);

		//Clear the subfolderDown list
		clear $subFolderDown;
		clear $remove;
		$tab = $tab + $singleTab;
		if (`size $searchDirs` == 0){
			$ok = 0;
			
		}
				
	}
	//print (wizDiv("end") + "\n");
	return $allsfld;

}


//@ WIZ GET ALL FILES OF TYPE IN ALL SUBFOLDERS OF DIRECTORY
//================================================================================
/*
	string $dir = wizGetDirectory();
	
	string $files[] = wizGetAllFilesOfTypeInAllSubfoldersOfDirectory($dir, "atm");
	//printBracketedArrayList($files);
	for ($i=0;$i<`size $files`;$i++){
		print ("'" + $files[$i] + "', \n");
	}

*/
global proc string[] wizGetAllFilesOfTypeInAllSubfoldersOfDirectory( string $dir, string $type)
{
	wizlog ("[@] wizGetAllFilesOfTypeInAllSubfoldersOfDirectory");
	string $ext = $type;
	string $allSubDir[] = wizGetAllSubFoldersOfDirectory($dir);
	wizlog (niceArrayList("[#] All Sub Directories[#]", $allSubDir));
	
	string $all[];
	//$all = stringArrayCatenate($all, $dir);
	
	
	// Get files in the dir first
	string $ofType[] = `getFileList -fld $dir -fs ("*." + $ext)`;
	wizlog ("[#] Directory : " + $dir + " Extension : " + $ext);
	wizlog (niceArrayList("[#] Files Of Type In Directory[#]", $ofType));
	stringArrayAddPrefix($ofType, $dir);
	$all = stringArrayCatenate($all, $ofType);
		

	for ($i=0;$i<`size $allSubDir`;$i++){
		string $ofType[] = `getFileList -fld $allSubDir[$i] -fs ("*." + $ext)`;
		wizlog ("[#] Directory : " + $allSubDir[$i] + " Extension : " + $ext);
		wizlog (niceArrayList("[#] Files Of Type In Directory[#]", $ofType));
		stringArrayAddPrefix($ofType, $allSubDir[$i]);
		$all = stringArrayCatenate($all, $ofType);
	}
	
	return $all;
}

// Creation Date:  Feb 17 1998
// Author:         rns
//
//  Procedure Name:
//      confirmProjChange
//
//  Description:
//	A script job that runs when a file is opened. If the file is in
//	a new project directory, it confirms if the user should change
//	the current project to the new one. 
//
//  Version 1.3: Sep 10 1999
//    No longer requires osTest.mel, but now requires maya 2.0!
//    Fixed NT temp directory opening bug
//
//  Version 1.2:  Aug 17 1999
//    if you're loading a crash file from the temp directory it doesn't
//    ask you
//
//  Version 1.1:  Aug 6 1999
//    works with both IRIX and NT
//    requires the osTest.mel script
//
//  Use and Modify at your own risk.

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CHANGE PROJECTS
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
global proc confirmProjChange()
{
	string $sceneName = `file -q -sceneName`;
	string $curWorkspace = `workspace -q -rd`;
	string $snBuf[];
	string $wsBuf[];
	int $lastSN;
	int $lastWS;

	int $usingNT = (`about -os` == "nt") ;
	// not necessary, but nice
	string $sep = ($usingNT ? "\\" : "/");
	
	$lastSN = tokenize($sceneName, "/\\", $snBuf);
	$lastWS = tokenize($curWorkspace, "/\\", $wsBuf);
	
	if ($lastSN>1) // assume we're starting up with a blank scene
	{
		// this is the check for loading a crash file from the temp dir
		if ($usingNT)
		{
			int $return = true;
			// on NT, the environment variable is "TEMP" (or "TMP" but who cares?)
			string $tmpDir = `getenv "TEMP"`;
			// have to use this sort of test cuz file -q uses / and $TEMP stores \
			string $tmpBuf[];
			int $lastTmp = tokenize($tmpDir, "/\\", $tmpBuf);
			for ($n=0; $n<$lastTmp; $n++)
				if ($tmpBuf[$n]!=$snBuf[$n])
				{
					$return = false;
					break;
				}
			if ($return) return;
		}
		else
		{
			// on IRIX we're hoping for "TMPDIR"
			string $tmpDir;
			$tmpDir = `getenv "TMPDIR"`;
			if (!size($tmpDir))
				$tmpDir = "/usr/tmp"; // reasonable default value
			
			if (substring ($sceneName,1,size($tmpDir)) == $tmpDir)
				return;
		}
		// otherwise check for opening in a different directory
		if ($snBuf[$lastSN-3] != $wsBuf[$lastWS-1])
		{
			// ask the user. woo hoo!
			string $msg = "The file '"+$snBuf[$lastSN-1]+
				"' is not in the current project '"+$wsBuf[$lastWS-1]+
				"'.\nChange to project '"+$snBuf[$lastSN-3]+"'?";
			string $return = `confirmDialog 
				-t Warning 
				-m $msg 
				-button "Yes" 
				-button "No" 
				-defaultButton "Yes"
				-cancelButton "No"
				-dismissString "No"`;
			
			if (!strcmp($return, "Yes"))
			{
				// build the path
				string $path;
				if (!$usingNT)
					$path += "/";
				$path += $snBuf[0];
				for ($i = 1; $i <= $lastSN-3; $i++)
				{
					$path += $sep + $snBuf[$i];
				}
				print ("// Setting project to " + $path + "\n");
				
				// this sets the project. this is ripped from the maya 
				// scripts and is amazingly more difficult than it should be.
				workspace -o $path;
				np_resetBrowserPrefs;
				if (`window -ex projectViewerWindow`) {
					pv_resetWorkspace;	// Force the layout to be redone.
				}
				workspace -dir `workspace -q -rd`;
			}
		}
	}
}

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//			PROMPTS
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================
//WIZ SAVE PROMPT
//================================================================================
/*=======================| USAGE |====================================	
    if (catchQuiet(`file -o $file`)){
        int $save = wizSavePrompt();
        if ($save == 0){ return; }
    }
====================================================================*/

global proc int wizSavePrompt()
{    
	int $ok = wizInformationDialog("File Is Not Saved!", "Press Continue To Proceed Without Saving", "CONTINUE", "CANCEL");
	return $ok;
	
}

/*****************************************************************//**
*	Use this to check if the file is saved or not and prompt the user to save.
*	More information.
*	USAGE : 
*
*********************************************************************/
global proc string wizSaveFile()
{
	string $newFile;
	string $file = `file -q -sn`;
	if (catchQuiet(`file -o $file`)){
		int $ok = wizInformationDialog("File Is Not Saved", "Save Before Continuing?", "Save", "Continue");
		
		if ($ok == 0){ return ""; }
		
		$newFile = wizSaveFileDialog();
	
	}
	return $newFile;
}

/*****************************************************************//**
*	This will open a prompt to select a file that may not exist and return the file that is chosen.
*	More information.
*	USAGE : 
*
*********************************************************************/
global proc string wizSaveFileDialog()
{
	string $file = wizGetAnyFile();
	return $file;

}




/*
	editMenuUpdate MayaWindow|mainEditMenu;
referenceEditsWindowRemoveSelectedEdits "C:/Users/Glen/Documents/maya/projects/PNCCashFlow/scenes/Testing/RefEditTest/RefSourceFile1.mb" RefSourceFile1RN refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_textScrollList {} 0;
referenceEdit -failedEdits true -successfulEdits true -editCommand setAttr -removeEdits |pCube1.translate;
referenceEditsWindowBuildListCmd "RefSourceFile1RN" "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_textScrollList" "" 0 "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_filterWidget";
{optionVar -iv "refEditsShowNamespaces" `checkBox -q -v refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|checkBox6`; referenceEditsWindowBuildListCmd "RefSourceFile1RN" "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_textScrollList" "" 0 "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_filterWidget";};
{ optionVar -iv "refEditsShowPath" `checkBox -q -v refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|checkBox5`; referenceEditsWindowBuildListCmd "RefSourceFile1RN" "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_textScrollList" "" 0 "refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_filterWidget";};
referenceEditsWindowRemoveSelectedEdits "C:/Users/Glen/Documents/maya/projects/PNCCashFlow/scenes/Testing/RefEditTest/RefSourceFile1.mb" RefSourceFile1RN refEditsWin_RefSourceFile1RN|refEditsWin_RefSourceFile1RN_formLayout|refEditsWin_RefSourceFile1RN_textScrollList {} 0;
referenceEdit -failedEdits true -successfulEdits true -editCommand setAttr -removeEdits |RefSourceFile1:pCube1.translate;


	
string $sel[] = `ls -sl`;
string $rfn = `referenceQuery -rfn $sel[0]`;
print ("Reference Node : \n" + $rfn + "\n\n");

string $es[] = `referenceQuery -es $sel[0]`;
print ("Edit Strings : \n" + stringArrayToString($es, "\n") + "\n\n");

string $en[] = `referenceQuery -en $sel[0]`;
print ("Edit Nodes : \n" + stringArrayToString($en, "\n") + "\n\n");

string $ea[] = `referenceQuery -ea $sel[0]`;
print ("Edit Attributes : \n" + stringArrayToString($ea, "\n") + "\n\n");


string $ec[] = { "addAttr", "connectAttr", "deleteAttr", "disconnectAttr", "parent", "setAttr", "lock", "unlock" };
for ($i=0;$i<`size $ec`;$i++){
	for ($a=0;$a<`size $ec`;$a++){
		referenceEdit -failedEdits true -successfulEdits true -ec $ec[$a] -removeEdits ($sel[0] + "." + $ea[$i]);
	}
}

//string $ec[] = `referenceQuery -ec $sel[0] -rfn $rfn`;
//print ("Edit Commands : \n" + stringArrayToString($ec, "\n") + "\n");
	
string $sel[] = `ls -sl`;
string $ec[] = `referenceQuery -q -ec $sel[0]`;
print ("Edit Commands : \n" + $rfn + "\n\n");

 "addAttr", "connectAttr", "deleteAttr", "disconnectAttr", "parent", "setAttr", "lock" and "unlock"
 
*/


/*

referenceAllFilesInSameDirectoryAsCurrent();

//REFERENCE ALL FILES IN SAME DIRECOTORY AS CURRENT
//==========================================================
global proc referenceAllFilesInSameDirectoryAsCurrent()
{
	string $sceneFile = `file -q -sn`;
	string $dir = getPathPart($sceneFile);
	$dir = $dir + "/";
	print("WIZ| referenceAllFilesInSameDirectoryAsCurrent :\n	Current File : " + $sceneFile + "\n	Current Dir : " + $dir + "\n");
		
	string $allFiles[];
	
	string $mb[] = getAllFilesOfTypeInDirectory($dir, "mb");
	print("WIZ|		- Found " + `size $mb` + " Maya Binary Files\n");
	
	string $ma[] = getAllFilesOfTypeInDirectory($dir, "ma");
	print("WIZ|		- Found " + `size $ma` + " Maya ASCII Files\n");
	
	string $fbx[] = getAllFilesOfTypeInDirectory($dir, "fbx");
	print("WIZ|		- Found " + `size $fbx` + " FBX Files\n");
	
	string $obj[] = getAllFilesOfTypeInDirectory($dir, "obj");
	print("WIZ|		- Found " + `size $obj` + " OBJ Files\n");

	appendStringArray($allFiles, $mb, `size $mb`);
	appendStringArray($allFiles, $ma, `size $ma`);
	appendStringArray($allFiles, $fbx, `size $fbx`);	
	appendStringArray($allFiles, $obj, `size $obj`);

	print("WIZ|		- Found " + `size $allFiles` + " To Reference\n");
	
	if(`size $allFiles` == 0){
		print("WIZ| - NO FILES TO REFERENCE - \n");
		return;	
	}
	
	string $m = ("Do You Want To Reference The " + `size $allFiles` + " Files Found In This Directory?\n");
	string $confirm =`confirmDialog 
		-t "Reference All Files In Current Directory"
		-m $m
		-ma "center"	
		-b "Yes" 
		-b "NO" 
		-db "Yes"
		-cb "No"
		`;
		
	if($confirm=="No"){
		print("WIZ| referenceAllFilesInSameDirectoryAsCurrent : CANCELED \n");
		return;
	} 
	
	print("WIZ| Referencing : " + `size $allFiles` + "\n");
	
	string $allRef[] = `file -q -reference`;
	
	for ($i=0;$i<`size $allFiles`; $i++){
		//print("WIZ|		File To Reference : " + $allFiles[$i] + "\n");
		int $skip;
		if($allFiles[$i] == `file -q -sn`){
			//print("WIZ|		Cannot Reference Self\n");
			continue;
		}
		
		if (size($allRef)){
			for ($r=0;$r<`size $allRef`;$r++){
				if($allRef[$r] == $allFiles[$i]){
					$skip = 1;
				}
			}
		}
		if($skip == 1){
			print("WIZ|		- File Already Referenced - SKIPPING - \n");
			continue;
		}
	
		//print("WIZ| Ref : " + $ref + " Size Ref: " + `size $ref` + "\n");

		print("WIZ| Referencing File : " + $allFiles[$i] + "\n");
		
		string $ext = ("." + `fileExtension $allFiles[$i]`);
		string $basename = basename($allFiles[$i], $ext);	
		string $eval = "file -r -gl -loadReferenceDepth \"all\" -mergeNamespacesOnClash false -namespace " + "\"" + $basename + "\" \"" + $allFiles[$i] + "\"";
		eval($eval);	

	}

	print("WIZ| referenceAllFilesInSameDirectoryAsCurrent : COMPLETE\n");
	
}

//GET ALL FILES OF TYPE IN DIRECTORY
//================================================================================
global proc string[] getAllFilesOfTypeInDirectory( string $dir, string $type )
{
	string $files[] = `getFileList -folder $dir -filespec ("*." + $type)`;
	if(`size $files` > 0){
		addPrefixToStringArray($files, $dir);				
	}
	return $files;
	
}


*/

//========================================================================================================
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
///////////////////                                 //////////////////////////////////////////////////////
//                         THUMBNAILS
///////////////////                                 //////////////////////////////////////////////////////
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//========================================================================================================

//@ SAVE SCENE THUMBNAIL IMAGE
//=======================================================
/*======================| SUMMARY |===================================
    This saves a thumbnail image of the current scene 
/*=======================| USAGE |====================================	

====================================================================*/
global proc autoSaveSceneThumbnailImage()
{
	if (`checkBox -q -v sceneAutoThumbnailEnabled_checkBox` == 0){
		return;	
	} else {
		saveSceneThumbnailImage();
	}


}

global proc string getWizThumbnailImage( string $flags )
{
	int $s;
	int $ex;
	int $xg;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-s" : case "-scene" :
			$s = 1;
			break ;

			case "-xg" : case "-xGen" :
			$xg = 1;
			break ;
			
			case "-ex" : case "-exists" :
			$ex = 1;
			break ;
			
		}
	}

	global string $WIZ_sceneFileIconSuffix;
	global string $WIZ_sceneFileRenderIconSuffix;
	
	//_________________________________________
	// Scene File Thumbnail
	if ($s){
		
		string $sceneFile = `file -q -sn` ;

		string $sceneDir = getDirectoryFromFullFilePath($sceneFile);
		string $filePathSplice[] = wizSpliceFilePath($sceneFile, "-dir -fn");

		// Get File Extension
		string $extension = `fileExtension $sceneFile` ;

		// Remove Extension
		string $fileNameNoExt = $filePathSplice[0] + $filePathSplice[1];
		
		string $thumbName = $fileNameNoExt + $WIZ_sceneFileRenderIconSuffix;
		
		if ($ex){
			int $fileExists = `filetest -e $thumbName`;
			if ($fileExists == 1){
				return $thumbName;
			} else {
				$thumbName = $fileNameNoExt + $WIZ_sceneFileIconSuffix;
				if ($fileExists == 1){
					return $thumbName;
				} else {			
					return "";
				}
			}
		} else {
			return $thumbName;
		}
			
	}
	
	//_________________________________________
	// xg
	if ($xg){
		string $sceneFile = `file -q -sn`;
		string $sfSplice[] = wizSpliceFilePath($sceneFile, "-fn");
		string $name = $sfSplice[0];
					
		string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + " -ext ma -xga");

		wizlog ("xGen Filename : " + $filename[0]);
		string $xgtSplice[] = wizSpliceFilePath($filename[0], "-dir -fn");
		string $xgThumbName = $xgtSplice[0] + $xgtSplice[1] + ".png";
		if ($ex){
			int $fileExists = `filetest -e $xgThumbName`;
			if ($fileExists == 1){
				return $xgThumbName;
			} else {		
				return "";
			}
		} else {
			return $xgThumbName;
		}
	
	}

}

global proc string saveFileThumbnailImage( string $filename )
{
wizLog("[@] saveFileThumbnailImage");
	
	
    global string $WIZ_sceneFileIconSuffix;
    global string $WIZ_sceneFileRenderIconSuffix;

    string $filePathSplice[] = wizSpliceFilePath($filename, "-dir -fn");
    
	string $thumbName = $filePathSplice[0] + $filePathSplice[1] + ".png";
    //Temporarily set the image format to png so we are always rendering png files
    int $curImageFormat = `getAttr "defaultRenderGlobals.imageFormat"`;    
    setAttr "defaultRenderGlobals.imageFormat" 32;
    
	if (`checkBox -q -v sceneThumbnailFitVisibleInView_checkBox`){
		string $camAngle = `optionMenuGrp -q sceneThumbnailCameraAngleOptionMenuGrp`;
		wizFitVisibleObjectsInView("-ca " + $camAngle);
		select -cl;
	}
	
	//_________________________________________
	// Focal Length
	string $curCam = getCurrentCamera();	
	float $fl = `getAttr ($curCam + ".focalLength")`;
	if (`checkBox -q -v sceneThumbnailUseFocalLength_checkBox`){			
		float $thumbFl = `floatSliderGrp -q -v sceneThumbnailCameraFocalLength_floatSliderGrp`;
		setAttr ($curCam + ".focalLength") $thumbFl;
	}
	
    //Do a single image playblast to get a thumbnail image
    int $currentFrame = `currentTime -q`;
    //int $tnType = `optionMenuGrp -q -v sceneThumbnailTypeOptionMenuGrp`;
	string $tnType = `optionMenuGrp -q -v sceneThumbnailTypeOptionMenuGrp`;
    //int $tnType = `optionVar -q WIZ_sceneThumbnailType`;
    wizLog("	[#] Thumbnail Type : " + $tnType);
	

		// Check if we want to write over existing thumbnail
		if (`checkBox -q -v sceneThumbnailAutoReplace_checkBox` == 0){
			int $fileExists = `filetest -e $thumbName`;
			if ($fileExists == 1){
				return $thumbName;
			}
		}
	
        //playblast a single image
        playblast
            -frame $currentFrame 
            -format image
            -completeFilename $thumbName 
            -clearCache 1 
            -viewer 0 
            -showOrnaments 0 
            -os 
            -percent 100 
            -widthHeight 256 256
            ;
    
   
    //Return render globals to previous state
    setAttr "defaultRenderGlobals.imageFormat" $curImageFormat;
    setAttr ($curCam + ".focalLength") $fl;
	
    return $thumbName;
}

global proc string saveSceneThumbnailImage()
{
	wizLog("[@] saveSceneThumbnailImage");
	
	
    global string $WIZ_sceneFileIconSuffix;
    global string $WIZ_sceneFileRenderIconSuffix;
    string $sceneFile = `file -q -sn` ;
    
    string $sceneDir = getDirectoryFromFullFilePath($sceneFile);
    string $filePathSplice[] = wizSpliceFilePath($sceneFile, "-dir -fn");
    
	
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt = $filePathSplice[0] + $filePathSplice[1];
	/*
	string $fileNameNoExtArr[] = wizSpliceFilePath($sceneFile, "-fnnv");
	string $fileNameNoExt = $fileNameNoExtArr[0];
	*/
/*
    // Tokenize Filename
    
    string $buffer[] ;
    tokenize $sceneFile "." $buffer ;
		
    if (`size $buffer` == 1){
    	$fileNameNoExt	
    }
    // Recompile Scenename Without Extension
    for ($i=0;$i<(size($buffer)-1);$i++){
        $fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
    }
*/
	//setCurrentRenderer mentalRay;
	
	if (`checkBox -q -v sceneThumbnailUseDefaultPreset_checkBox`){
		loadPreferredRenderGlobalsPreset("mentalRay");
    
    } else {
		//loadNodePresets "thumbnail";
	}
    
    //Temporarily set the image format to png so we are always rendering png files
    int $curImageFormat = `getAttr "defaultRenderGlobals.imageFormat"`;    
    setAttr "defaultRenderGlobals.imageFormat" 32;
    
	if (`checkBox -q -v sceneThumbnailFitVisibleInView_checkBox`){
		string $camAngle = `optionMenuGrp -q sceneThumbnailCameraAngleOptionMenuGrp`;
		wizFitVisibleObjectsInView("-ca " + $camAngle);
		select -cl;
	}
	
	//_________________________________________
	// Focal Length
	string $curCam = getCurrentCamera();	
	float $fl = `getAttr ($curCam + ".focalLength")`;
	if (`checkBox -q -v sceneThumbnailUseFocalLength_checkBox`){			
		float $thumbFl = `floatSliderGrp -q -v sceneThumbnailCameraFocalLength_floatSliderGrp`;
		setAttr ($curCam + ".focalLength") $thumbFl;
	}
	
    string $thumbName = $fileNameNoExt + $WIZ_sceneFileIconSuffix;
    //string $thumbName = $filePathSplice[0] + "icons/" + $filePathSplice[1] + $WIZ_sceneFileIconSuffix;
    	
    wizlog ("	[#] Thumbnail Image : " + $thumbName);
    
    //Do a single image playblast to get a thumbnail image
    int $currentFrame = `currentTime -q`;
    //int $tnType = `optionMenuGrp -q -v sceneThumbnailTypeOptionMenuGrp`;
	string $tnType = `optionMenuGrp -q -v sceneThumbnailTypeOptionMenuGrp`;
    //int $tnType = `optionVar -q WIZ_sceneThumbnailType`;
    wizLog("	[#] Thumbnail Type : " + $tnType);
	
	/*
	if (`checkBox -q -v sceneThumbnailLoadDefaultRenderEnv_checkBox` == 1){
		// Load the default render environment - will only load if there are no ligths in scene.
		wizLog("	[+] Load Default Render Environment [+]");		
		wizLoadDefaultRenderEnv("-rar");
	}
	*/
	
    if ($tnType == "Draft"){
		// Check if we want to write over existing thumbnail
		if (`checkBox -q -v sceneThumbnailAutoReplace_checkBox` == 0){
			int $fileExists = `filetest -e $thumbName`;
			if ($fileExists == 1){
				return $thumbName;
			}
		}
	
        //playblast a single image
        playblast
            -frame $currentFrame 
            -format image
            -completeFilename $thumbName 
            -clearCache 1 
            -viewer 0 
            -showOrnaments 0 
            -os 
            -percent 100 
            -widthHeight 256 256
            ;
    
    } else if ($tnType == "Render"){
		// set render globals to render large sq image
        int $h = `getAttr "defaultResolution.height"`;
        int $w = `getAttr "defaultResolution.width"`;
		int $al = `getAttr "defaultResolution.aspectLock"`;
        setAttr "defaultResolution.height" 256;
        setAttr "defaultResolution.width" 256;
		setAttr "defaultResolution.aspectLock" 1;
		
        setTestResolutionVar(1);
        print ("Rendering Icon : " + $fileNameNoExt + $WIZ_sceneFileRenderIconSuffix + "\n");
        $thumbName = $fileNameNoExt + $WIZ_sceneFileRenderIconSuffix;
		
		// Check if we want to write over existing thumbnail
		if (`checkBox -q -v sceneThumbnailAutoReplace_checkBox` == 0){
			int $fileExists = `filetest -e $thumbName`;
			if ($fileExists == 1){
				// reset render settings to where they were
				setAttr "defaultResolution.height" $h;
				setAttr "defaultResolution.width" $w;
				setAttr "defaultResolution.aspectLock" $al;
				  //Return render globals to previous state
				setAttr "defaultRenderGlobals.imageFormat" $curImageFormat;
				setAttr ($curCam + ".focalLength") $fl;
				return $thumbName;
			}
		}
	
        RenderIntoNewWindow;
        if (`checkBox -q -v sceneThumbnail_colorManage_checkBox`){
        	renderWindowEditor -edit -writeImage $thumbName -com renderView;
        } else {
        	renderWindowEditor -edit -writeImage $thumbName renderView;
        }
        
		// reset render settings to where they were
        setAttr "defaultResolution.height" $h;
        setAttr "defaultResolution.width" $w;
		setAttr "defaultResolution.aspectLock" $al;
		
        setTestResolutionVar(4);
    }
    //Return render globals to previous state
    setAttr "defaultRenderGlobals.imageFormat" $curImageFormat;
    setAttr ($curCam + ".focalLength") $fl;
	
	/*
	// Remove the render env
	wizLog("	[-] Remove Default Render Environment [-]");	
	if (`checkBox -q -v sceneThumbnailLoadDefaultRenderEnv_checkBox` == 1){
		wizMGMT("-ex removeRenEnv","");
	}
	*/
	
    return $thumbName;
}


global proc string wizXgenThumbnailImage( string $flags )
{
	wizLog ("[@] wizXgenThumbnailImage");
	string $filename;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-f" : case "-filename" :
			$filename = $tok[($i + 1)];
			break ;
			
			
		}
	}
	
	string $sceneThumb = getWizThumbnailImage("-s -ex");
	
	if (`size $sceneThumb` > 0){
		string $xgThumb = getWizThumbnailImage("-xg");
		copyFileFromTo($sceneThumb, $xgThumb);
		return $xgThumb;
	}
	
	if (`size $filename` == 0){
		// Thumb should be named same as file
		string $filename = `file -q -sn`;
		
	}


    string $filePathSplice[] = wizSpliceFilePath($filename, "-dir -fn");
    	
	// Render PNGs
	string $extension = "png";
	
	setCurrentRenderer mentalRay;
	if (`checkBox -q -v xgenArchiveThumbnailUseDefaultPreset_checkBox`){
		loadPreferredRenderGlobalsPreset("mentalRay");
    
    } 
	
    //Temporarily set the image format to png so we are always rendering png files
    int $curImageFormat = `getAttr "defaultRenderGlobals.imageFormat"`;    
    setAttr "defaultRenderGlobals.imageFormat" 32;
    
	if (`checkBox -q -v xgenArchiveThumbnailFitVisibleInView_checkBox`){
		string $camAngle = `optionMenuGrp -q xgenArchiveThumbnailCameraAngleOptionMenuGrp`;
		wizFitVisibleObjectsInView("-ca " + $camAngle);
		select -cl;
	}
	
	//_________________________________________
	// Focal Length
	string $curCam = getCurrentCamera();	
	float $fl = `getAttr ($curCam + ".focalLength")`;
	if (`checkBox -q -v xgenArchiveThumbnailUseFocalLength_checkBox`){			
		float $thumbFl = `floatSliderGrp -q -v xgenArchiveThumbnail_cameraFocalLength_floatSliderGrp`;
		setAttr ($curCam + ".focalLength") $thumbFl;
	}

    wizlog ("	[#] Thumbnail Image : " + $filename);
    
    //Do a single image playblast to get a thumbnail image
    int $currentFrame = `currentTime -q`;
	string $tnType = `optionMenuGrp -q -v xgenArchiveThumbnailTypeOptionMenuGrp`;
    wizLog ("	[#] Thumbnail Type : " + $tnType);

    if ($tnType == "Draft"){
		
        //playblast a single image
        playblast
            -frame $currentFrame 
            -format image
            -completeFilename $filename 
            -clearCache 1 
            -viewer 0 
            -showOrnaments 0 
            -os 
            -percent 100 
            -widthHeight 256 256
            ;
    
    } else if ($tnType == "Render"){
		// set render globals to render large sq image
        int $h = `getAttr "defaultResolution.height"`;
        int $w = `getAttr "defaultResolution.width"`;
		int $al = `getAttr "defaultResolution.aspectLock"`;
        setAttr "defaultResolution.height" 256;
        setAttr "defaultResolution.width" 256;
		setAttr "defaultResolution.aspectLock" 1;
		
        setTestResolutionVar(1);
		
        print ("Rendering Icon : " + $filename + "\n");
			
        RenderIntoNewWindow;
        if (`checkBox -q -v xgenArchiveThumbnail_colorManage_checkBox`){
        	renderWindowEditor -edit -writeImage $filename -com renderView;
        } else {
        	renderWindowEditor -edit -writeImage $filename renderView;
        }
        
		// reset render settings to where they were
        setAttr "defaultResolution.height" $h;
        setAttr "defaultResolution.width" $w;
		setAttr "defaultResolution.aspectLock" $al;
		
        setTestResolutionVar(4);
    }
    //Return render globals to previous state
    setAttr "defaultRenderGlobals.imageFormat" $curImageFormat;
    setAttr ($curCam + ".focalLength") $fl;
	
    return $filename;
	
}

global proc string saveScenePosterImage()
{
	wizLog ("[@] saveScenePosterImage");
    global string $WIZ_sceneFilePosterSuffix;
    string $sceneFile = `file -q -sn` ;
    
    string $sceneDir = getDirectoryFromFullFilePath($sceneFile);
    string $filePathSplice[] = wizSpliceFilePath($sceneFile, "-dir -fn");
    
	// Get File Extension
	string $extension = `fileExtension $sceneFile` ;
	
	// Remove Extension
	string $fileNameNoExt ;

    // Tokenize Filename
    string $buffer[] ;
    tokenize $sceneFile "." $buffer ;
		
    // Recompile Scenename Without Extension
    for ($i=0;$i<(size($buffer)-1);$i++){
        $fileNameNoExt = $fileNameNoExt + $buffer[$i] ;
    }

	//_________________________________________
	// Change Render Settings
	
    //Temporarily set the image format to png so we are always rendering png files
    int $curImageFormat = `getAttr "defaultRenderGlobals.imageFormat"`;    
    setAttr "defaultRenderGlobals.imageFormat" 32;
    
    string $posterName = $fileNameNoExt + $WIZ_sceneFilePosterSuffix;
    //string $thumbName = $filePathSplice[0] + "icons/" + $filePathSplice[1] + $WIZ_sceneFileIconSuffix;

	// set render globals to render large sq image
    int $h = `getAttr "defaultResolution.height"`;
    int $w = `getAttr "defaultResolution.width"`;
	int $al = `getAttr "defaultResolution.aspectLock"`;
	
	int $posH = `intFieldGrp -q -v1 posterImageSize_intFieldGrp`;
	int $posW = `intFieldGrp -q -v2 posterImageSize_intFieldGrp`;
	
    setAttr "defaultResolution.height" $posH;
    setAttr "defaultResolution.width" $posW;
	setAttr "defaultResolution.aspectLock" 1;
    setTestResolutionVar(1);
	
	//_________________________________________
	// Get Renderable Cameras
	string $renderCameras[];
	if (`checkBox -q -v posterImageUseRenderableCameras_checkBox`){
		string $allCam[] = `ls -ca`;
		for ($i=0;$i<`size $allCam`;$i++){
			int $renderable = `getAttr ($allCam[$i] + ".renderable")`;
			if ($renderable){
				$renderCameras[`size $renderCameras`] = $allCam[$i];
			}
		}
		
	} else {
		$renderCameras[0] = "persp";
	}
	
	// Load the default render environment - will only load if there are no ligths in scene.
	if (`checkBox -q -v posterImageLoadDefaultRenderEnv_checkBox` == 1){		
		wizLog("	[+] Load Default Render Environment [+]");		
		wizLoadDefaultRenderEnv("-rar");
	}
	
	int $tnType = `optionVar -q WIZ_sceneThumbnailType`;
	wizLog ("	[#] Thumbnail Type : " + $tnType);
	string $pType = `optionMenuGrp -q -v posterImageTypeOptionMenuGrp`;
		
	for ($i=0;$i<`size $renderCameras`;$i++){
		if (`checkBox -q -v posterImageUseRenderableCameras_checkBox`){
			lookThru $renderCameras[$i];
		}
		
		//_________________________________________
		// Focal Length
		string $curCam = getCurrentCamera();	
		float $fl = `getAttr ($curCam + ".focalLength")`;
		if (`checkBox -q -v posterImageUseFocalLength_checkBox`){			
			float $pfl = `floatSliderGrp -q -v posterImageCameraFocalLength_floatSliderGrp`;
			setAttr ($curCam + ".focalLength") $pfl;
		}	
		
		if (`checkBox -q -v posterImageFitVisibleInView_checkBox`){
			string $camAngle = `optionMenuGrp -q posterImageCameraAngleOptionMenuGrp`;
			wizFitVisibleObjectsInView("-ca " + $camAngle);
			//fitVisibleObjectsInView();
			select -cl;
		}	
		
		//_________________________________________
		// Add Camera Name?
		if (`size $renderCameras` < 2 && $renderCameras[0] == "persp"){
			wizLog ("	[+] Rendering Poster Image : " + $fileNameNoExt + $WIZ_sceneFilePosterSuffix);
			$posterName = $fileNameNoExt + $WIZ_sceneFilePosterSuffix;
		} else {
			string $camNames[] = `listTransforms $renderCameras[$i]`;
			wizLog ("	[+] Rendering Poster Image : " + $fileNameNoExt + "_" + $camNames[0] + "_" + $WIZ_sceneFilePosterSuffix);
			$posterName = $fileNameNoExt + "_" + $camNames[0] + "_" + $WIZ_sceneFilePosterSuffix;
		}
			
		//_________________________________________
		// Render Draft	
		if ($pType == "Draft"){
			/*
			// Check if we want to write over existing thumbnail
			if (`checkBox -q -v sceneThumbnailAutoReplace_checkBox` == 0){
				int $fileExists = `filetest -e $posterName`;
				if ($fileExists == 1){
					return $thumbName;
				}
			}
			*/
			int $currentFrame = `currentTime -q`;
			//playblast a single image
			playblast
				-frame $currentFrame 
				-format image
				-completeFilename $posterName 
				-clearCache 1 
				-viewer 0 
				-showOrnaments 0 
				-os 
				-percent 100 
				-widthHeight $posH $posW
				;

		} else {
			
		//_________________________________________
		// Render Full		
			
			RenderIntoNewWindow;
			
			if (`checkBox -q -v posterImage_colorManage_checkBox`){
				renderWindowEditor -edit -writeImage $posterName -com renderView;
			} else {
				renderWindowEditor -edit -writeImage $posterName renderView;
			}
			
		}
		
		//_________________________________________
		// Copy To Another Directory
		if (`checkBox -q -v posterImage_copyPostersToDir_checkBox`){
			string $copyDir = `textFieldButtonGrp -q -tx posterImage_copyDirectory_textFieldButtonGrp`;
			string $fSplice[] = wizSpliceFilePath($posterName, "-ffn");
			string $dest = $copyDir + $fSplice[0];
			if ($copyDir == ""){
				
			} else {
				wizlog ("	[+] Copy Poster To : " + $dest);
				copyFileFromTo($posterName, $dest);
			}
			
		}
		
		setAttr ($curCam + ".focalLength") $fl;

	}
	
	//_________________________________________
	// Reset
	// reset render settings to previous state
	setAttr "defaultResolution.height" $h;
	setAttr "defaultResolution.width" $w;
	setAttr "defaultResolution.aspectLock" $al;
	setTestResolutionVar(4);
	setAttr "defaultRenderGlobals.imageFormat" $curImageFormat;
	
	
	// Remove the render env
	wizLog("	[-] Remove Default Render Environment [-]");	
	wizMGMT("-ex removeRenEnv","");
		
    return $posterName;
}


// pass name of file, not name of thumbnail image file
global proc string wizMeshThumbnailImage( string $flags )
{
	setCurrentRenderer mayaSoftware;
	
	// This seems to be outdated
	//loadNodePresets "thumbnail1";
	
	python "import maya.app.renderSetup.views.renderSetupPreferences as prefs ; prefs.loadUserPreset(\"thumbnail1\")";
	
	wizLog ("[@] wizMeshThumbnailImage");
	string $sel[] = `ls -sl`;
	string $filename;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-f" : case "-filename" :
			$filename = $tok[($i + 1)];
			break ;
			
			case "-wc" :
			
			string $selMesh[] = `ls -sl`;
			string $newName = removeIllegalCharacters($selMesh[0]);
			string $ep[] = wizCraftGetFileOutputPaths("-n " + $newName + " -ext obj");
			$filename = $ep[0];
			break ;
		}
	}	
	
	if ($filename == "" && $flags != ""){
		$filename = $flags;
	}
	
	if (`size $filename` == 0){
		// Thumb should be named same as file
		string $filename = `file -q -sn`;
		
	}


    string $filePathSplice[] = wizSpliceFilePath($filename, "-dir -fn");
	string $thumbName = $filePathSplice[0] + $filePathSplice[1] + ".jpg";
	
	//string $camAngle = `optionMenuGrp -q sceneThumbnailCameraAngleOptionMenuGrp`;
	//wizFitVisibleObjectsInView("-ca " + $camAngle);
	//wizFitVisibleObjectsInView();
	viewFit -an false;	
	toggleWizIsolateView();
	
	select -cl;
	
    wizlog ("	[#] Thumbnail Image : " + $thumbName);
    
    //Do a single image playblast to get a thumbnail image
    int $currentFrame = `currentTime -q`;

	//playblast a single image
	playblast
		-frame $currentFrame 
		-format image
		-completeFilename $thumbName 
		-clearCache 1 
		-viewer 0 
		-showOrnaments 0 
		-os 
		-percent 100 
		-widthHeight 256 256
		;
    
 

	select -r $sel;
	
    return $thumbName;
	
}

//@ CONVERT ALL FILES IN DIRECTORY
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $newFiles[] = convertAllFilesInDirectory("-dirPrompt -com someProcedure -typ fbx");
	
	</code>
*********************************************************************/
global proc string[] convertAllFilesInDirectory( string $flags )
{
	wizlog ("[@] convertAllFilesInDirectory");
	string $dir, $type;
	string $com;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-dir" : case "-directory" :
			$dir = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = $tok[($i + 1)];
			break ;
			
			case "-com" : case "-command" :
			$com = wizFlagString($tok, $i);
			break ;			
			
			case "-dpr" : case "-dirPrompt" :
			$dir = wizGetDirectory();
			break ;
			
		}
	}
	string $files[] = getAllFilesOfTypeInDirectory($dir, $type);
	wizlog ((niceArrayList("	[+] Process " + (capitalizeString($type)) + " Files [+]", $files)));
	
	string $newFiles[];
	for ($i=0;$i<`size $files`;$i++){
		// make a new file
		file -f -new;		
		string $splice[] = wizSpliceFilePath($files[$i], "-dir -fn");
		string $nn = $splice[0] + $splice[1] + ".mb";
		wizlog ("	[#] New File Name : " + $nn + " [#]");
		wizlog ("	[*] Eval Command : " + $com + " [*]");
		
		// import the file
		file -f -i $files[$i];
		// evaluate some command
		eval($com);
		// rename the file and save
		file -rename $nn ;
		
		$newFiles[`size $newFiles`] = $nn;
		
		saveSceneThumbnailImage();
		
		file -f -save ;
		
	}
	
	wizlog ("[*] FINISHED PROCESSING FILES [*]");
	return $newFiles;
		

}

//@ WIZ REPLACE REFERENCE MB MA
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc wizReplaceReferenceMBMA( string $flags )
{
	string $obj, $type;
	string $sel[];
	int $mamb, $mbma, $all;
	string $ref[];
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break ;
				
			case "-ba" : case "-mbToMa" :
			$mbma = 1;
			break ;
			
			case "-ab" : case "-maToMb" :
			$mamb = 1;
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-a" : case "-all" :
			$all = 1;
			break ;
			
		}
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	string $allRef[];
	if ($all){
		$allRef = `ls -type reference`;	
		wizlog ((niceArrayList("[All Reference Nodes]", $ref)));
		
				
	// remove any reference that isn't a top level reference
	for ($i=0;$i<`size $allRef`;$i++){
		int $n = catchQuiet(`referenceQuery -f $allRef[$i]`);
		if ($n == 1){
			wizlog ("[!] " + $allRef[$i] + " Has No File Association");
			continue;
		}
		
		string $pns[] = `referenceQuery -pns $allRef[$i]`;

		if (`size $pns` == 0){
			$ref[`size $ref`] = $allRef[$i];
		}
	}
	} else {
		$allRef = $sel;
		$ref = $allRef;
		wizlog ((niceArrayList("[Selected Reference Nodes]", $ref)));
	}

		

	for ($i=0;$i<`size $ref`;$i++){
		string $f = `referenceQuery -f $ref[$i]`;
		wizlog ("	[#] Ref Node : " + $ref[$i] + " Ref File : " + $f);
		string $convertF = substring($f, 1, (`size $f` - 1));
		
		if ($mamb){
			$convertF = $convertF + "b";
			$type = "mayaBinary";
		} else {
			$convertF = $convertF + "a";
			$type = "mayaAscii";
		}
		wizlog ("	[#] Converted File Path : " + $convertF);
		file -loadReference $ref[$i] -type $type -options "v=0;" $convertF;
		
	}

}

global proc loadWizRenderSettings()
{
	loadNodePresets "TestRender1024";

}

//@ WIZ EXPORT SET
//====================================================================
/*****************************************************************//**
	Creates sets that can be configured for automatic exporting.
	<hr>
	<b>Synopsis</b><br>
	wizExportSet [-obj string] [-typ linear] <br>
	Using "all" in set name will export the objects in set in all supported formats. <br>
	Warning : Using underscores in reference files will mess up file naming. <br>
	A export set should be named as follows: <br>
		wiz_(name)_(fileType)_exportSet <br>
		e.g. wiz_sphere1_all_exportSet <br>
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-newSet(-ns) <br>
	-export(-ex) <br>
	-exportAll(-ea) <br>
	-name(-n) <br>
	-extension(-ext) <br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	wizExportCacheFile(),
	
	<b>Examples</b><br>
	<code>
	string $newExportSet[] = wizExportSet("-ns -sl");
	wizExportSet("-exportAll");
	
	</code>
*********************************************************************/
global proc string[] wizExportSet( string $flags )
{
	wizlog ("[@] wizExportSet... Yes this is treue");
	
	string $obj, $type;
	string $name;
	string $ext = `optionMenuGrp -q -v wizExportSets_exportType_optionMenuGrp`;
	string $sel[];
	int $edit;
	int $ns;
	int $abc;
	int $exportAll;
	int $export;
	int $renderProxySet;
	int $ess;
	int $deo;
	int $inc;
	int $no;
	int $useExportObjectName;
	int $renderThumbnail;
	int $prefixFileName = 0;
	
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
		
			case "-ns" : case "-newSet" :
			$ns = 1;
			break ;
			
			case "-ex" : case "-export" :
			$export = 1;
			break ;
			
			case "-ea" : case "-exportAll" :
			$exportAll = 1;
			break ;
			
			case "-n" : case "-name" :
			$name = $tok[($i + 1)];
			break ;
			
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			$sel[`size $sel`] = $obj;
			break ;
				
			case "-typ" : case "-type" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-e" : case "-edit" :
			$edit = 1;
			break ;
					
			case "-ext" : case "-extension" :
			$ext = $tok[($i + 1)];
			break ;
			
			case "-rps" : case "-renderProxySet" :
			$renderProxySet = 1;
			break ;
			
			case "-ess" : case "-exportSelectedSet" :
			$ess = 1;
			break ;
			
			case "-deo" : case "-deleteExportObjects" :
			$deo = 1;
			break ;
			
			case "-inc" : case "-increment" :
			$inc = 1;			
			break ;
			
			case "-no" : case "-noOverwrite" :
			$no = 1;
			break ;
		}
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	
	
	if ($exportAll){
		
		string $all[];
		if ($ess){
		
			wizlog ("	[#] Exporting Selected Export Sets [#]");
			$all = `ls -sl`;
		} else {
			wizlog ("	[#] Exporting All Export Sets [#]");
			$all = `ls -r true ("*exportSet")`;
			wizlog (niceArrayList("Export Sets :", $all));
		}
		
		string $allRPSet[] = `ls -r true ("*renderProxySet")`;
		for ($i=0;$i<`size $all`;$i++){
		
			wizlog ("==================== EXPORT SET : " + $all[$i] + " ==================");
				
			string $tok[] = tokenizeString($all[$i], "_");						
			$name = $tok[1];
			
			string $exSel[] = `sets -q $all[$i]`;
			$exSel = `ls -v $exSel`;
			
			//_________________________________________
			// Remove any object with 0 bbox size
			string $remove[];
			for ($p=0;$p<`size $exSel`;$p++){
					float $bBoxSize[] = `getAttr ($exSel[$p] + ".boundingBoxSize")`;
					if ($bBoxSize[0] == 0 && $bBoxSize[1] == 0 && $bBoxSize[2] == 0){
						$remove[`size $remove`] = $exSel[$p];
					}
			}			
			if (`size $remove` > 0){
				$exSel = stringArrayRemove($remove, $exSel);
			}
			
			if (`size $exSel` == 0){
				wizlog ("[!] Nothing Is Selected For Exporting. Skipping.");
				continue ;
			}
			wizlog (niceArrayList("[#] Exporting Objects : ", $exSel));
						
			select -r $exSel;
			string $eSl[] = `ls -sl`;
			
			if (`attributeExists "deleteHistory" $all[$i]` == 1){
				int $delHistory = `getAttr ($all[$i] + ".deleteHistory")`;
				if ($delHistory == 1){
					select -r $all[$i];
					wizSelectSetMembers();
					delete -ch;
				}
			}
			
			wizlog (niceArrayList("	[#] Exporting Object(s) [#]", $exSel));
			//wizlog ("	[#] File Name : " + $filename[0]);
			
			int $exmb = `getAttr ($all[$i] + ".mb")`;
			
			if (`attributeExists "useFileName" $all[$i]` == 1){
				int $useFileName = `getAttr ($all[$i] + ".useFileName")`;
				if ($useFileName == 1){
					string $sceneFile = `file -q -sn`;
					string $sfSplice[] = wizSpliceFilePath($sceneFile, "-fn");
					$name = $sfSplice[0];
				}
				$prefixFileName = 1;
			}
			
			//_________________________________________
			// Skip Exporting If File Exists Already
			if ($no){
				global string $WIZ_subFileFolderSuffix;
				string $sceneFile = `file -q -sn`;
				string $filePathSplice[] = wizSpliceFilePath($sceneFile, "-fn -dir -ex");
				//string $newDir = wizMakeDir(($filePathSplice[1] + $filePathSplice[0] + $WIZ_subFileFolderSuffix + "/"));
				string $testDir = ($filePathSplice[1] + $filePathSplice[0] + $WIZ_subFileFolderSuffix + "/");
				int $fileTest = `filetest -e $testDir`;
				if ($fileTest == 1){
					wizlog ("[!] wizExportSet :  File Already Exists :  Skipping [!]");
					return {""};
				}
			}
			
			string $opCom;
			
			//_________________________________________
			// Get Export Settings
			int $usd = `getAttr ($all[$i] + ".useSameDirectory")`;
			int $ucd = `getAttr ($all[$i] + ".useCustomDirectory")`;
			if (`attributeExists "useSameDirectory" $all[$i]` == 1){
				int $useSameDirectory = `getAttr ($all[$i] + ".useSameDirectory")`;
				if ($useSameDirectory == 1){
					$opCom = " -usd";
				}
			}
			if (`attributeExists "useCustomDirectory" $all[$i]` == 1){
				int $useCustomDirectory = `getAttr ($all[$i] + ".useCustomDirectory")`;
				if ($useCustomDirectory == 1){
					string $useDir = `getAttr -as ($all[$i] + ".exportDirectory")`;
					$opCom = " -dir " + $useDir;
				}
			}
			if (`attributeExists "useExportObjectName" $all[$i]` == 1){
				$useExportObjectName = `getAttr ($all[$i] + ".useExportObjectName")`;
				//if ($useExportObjectName == 1){
					///
				//	$name = $sfSplice[0];
				//}
			}
			int $exma = `getAttr ($all[$i] + ".ma")`;
			int $exfbx = `getAttr ($all[$i] + ".fbx")`;
			int $exobj = `getAttr ($all[$i] + ".obj")`;
			int $exabc = `getAttr ($all[$i] + ".abc")`;
			
			int $exxga;
			if (`attributeExists "exportXGenArchive" $all[$i]` == 1){
				$exxga = `getAttr ($all[$i] + ".exportXGenArchive")`;
			}
			
			int $exmi;
			if (`attributeExists "mi" $all[$i]`){
				 $exmi = `getAttr ($all[$i] + ".mi")`;
				
			}
			int $em = 1;
			if (`attributeExists "exportMaterial" $all[$i]`){
				 $em = `getAttr ($all[$i] + ".exportMaterial")`;				
			}
			
			int $pfp;
			if (`attributeExists "prepForPainting" $all[$i]`){
				$pfp = `getAttr ($all[$i] + ".prepForPainting")`;
			}
			
			int $eem;
			if (`attributeExists "exportEachMesh" $all[$i]`){
				$eem = `getAttr ($all[$i] + ".exportEachMesh")`;
			}
			
			if (`attributeExists "renderThumbnail" $all[$i]`){
				$renderThumbnail = `getAttr ($all[$i] + ".renderThumbnail")`;
			}
			//_________________________________________
			// Create No History Copy
			string $exSelCopy[];
			for ($ic=0;$ic<`size $exSel`;$ic++){
				select -r $exSel[$ic];
				
				ConvertSelectionToVertices;
				string $v[] = `ls -fl -sl`;
				if (`size $v` < 2){					
					wizlog ("[OBJECT HAS NO VERTICES - SKIPPING]");
					continue ;
				}
				
				select -cl;
				select -r $exSel[$ic];
				
				string $dupName = $exSel[$ic];
				string $dup[];
				if ($eem){
					// If we are exporting each mesh... remove the "Mesh" suffix from object name
					//$dupName = substituteAllString($exSel[$ic], "Mesh", "");
					//wizLog("+++++----------Renaming Object : " + $exSel[$ic] + " To : " + $dupName);
					$dup = `duplicate -rr -renameChildren $exSel[$ic]`;					
				} else {				
					$dup = `duplicate -rr -renameChildren -n $dupName $exSel[$ic]`;
				}
				
				wizlog ("[+] Duplicate : " + $exSel[$ic]);
				
				string $parent[] = `listRelatives -p`;
				if (`size $parent` > 0){
					parent -w $dup[0];
				}
				
				delete -ch $dup[0];	
				
				
				
				$exSelCopy[`size $exSelCopy`] = $dup[0];
				
				
	
			}
			
			// If we are using the name of the exported object instead of the filename
			if ($useExportObjectName == 1){
				$name = $exSelCopy[0];
			}
			//_________________________________________
			// Prep For Painting
			if ($pfp){
				select -r $exSelCopy;
				//makeSelectMasterSelection("selectMasterListA","replace");
				wizCraftAutoTileUVLayout("-sl");
			}
			
			select -r $exSelCopy;
			/*
			deleteExtraMeshNodesOnSelectedObjects(`ls -sl`);
			wizFlattenUVSetsOnSelectedObjects(`ls -sl`);
			*/
			
			
			
			//_________________________________________
			// MB
			select -r $exSel;
			string $outInc;
			if ($inc){
				$outInc = " -inc";
			}
			if ($exmb){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext mb" + $opCom);
				wizlog ("[#] Exporting MB File : " + $filename[0]);
				wizExportMB($filename[0]);
			}
			
			//_________________________________________
			// MA
			select -r $exSel;			
			if ($exma){			
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext ma" + $opCom);
				wizlog ("[#] Exporting MA File : " + $filename[0]);
				wizExportMA($filename[0]);
			}
					
			//_________________________________________
			// FBX
			select -r $exSelCopy;			
			
			if ($exfbx){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext fbx" + $opCom);
				wizlog ("[#] Exporting FBX File : " + $filename[0]);
				wizExportFBX($filename[0]);
			}
			
			//_________________________________________
			// OBJ
			select -r $exSelCopy;			
			
			if ($exobj){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext obj" + $opCom);
				wizlog ("[#] Exporting OBJ File : " + $filename[0]);
				wizExportOBJ($filename[0]);
			}
			
			//_________________________________________
			// xGen Archive
			select -r $exSelCopy;			
			
			if ($exxga){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext ma" + $opCom + " -xga");
				wizlog ("[#] Exporting xGen Archive File : " + $filename[0]);
				wizExportXGenArchive("-sl -f " + $filename[0]);
			}	
				
			//_________________________________________
			// MI
			select -r $exSelCopy;		
			
			if ($exmi){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext mi" + $opCom);
				wizlog ("[#] Exporting MI File : " + $filename[0]);
				string $delString;
				string $exMatString;
				if ($deo){
					$delString = "-deo ";
				}
				if ($em){
					$exMatString = "-em ";
				}
				wizExportMRRenderProxy("-sl " + $delString + $exMatString + "-osl " + (stringArrayToString($exSel, " ")));
			}

			
			//_________________________________________
			// ABC
			select -r $exSelCopy;			
			
			if ($exabc){
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + $outInc + " -ext abc" + $opCom);
				wizlog ("[#] Exporting ABC File : " + $filename[0]);
				wizExportCacheFile("-sl -f " + $filename[0]);
			}
			
			//_________________________________________
			// EXPORT EACH MESH
			if ($eem){
				select -r -hi $exSelCopy;
				
				string $gTrans[] = `listTransforms "-g -sl"`;
				//string $geo[] = `ls -g -sl`;
				select -r $gTrans;
				string $eG[] = `ls -sl`;
				for ($ni=0;$ni<`size $eG`;$ni++){				
					string $dupName = substituteAllString($eG[$ni], "Mesh", "");
					$eG[$ni] = `rename $eG[$ni] $dupName`;
					wizLog("+++++----------Renaming Object : " + $eG[$ni] + " To : " + $dupName);
				}
				
				select -r $eG;
				
				parent -w;
				
				//alignObjectsToWorldCenter(`ls -sl`);
				
				select -r $eG;
				
				
				string $ft = "fbx";
				if ($exobj){
					$ft = "obj";
				}
				/*
				global string $WIZ_subFileFolderSuffix;
				string $curFile = `file -q -sn`;
				string $filePathSplice[] = wizSpliceFilePath($curFile, "-fn -dir -ex");
				string $newDir = wizMakeDir(($filePathSplice[1] + $filePathSplice[0] + $WIZ_subFileFolderSuffix + "/"));				
				wizlog ("[#] Exporting Each Mesh To Directory : " + $newDir);			
				
				wizExportEachSelectionToFile("-sl -typ " + $ft + " -dir " + $newDir);
				*/				
				string $eesArg = "-wc -sl -typ ";
				if ($prefixFileName == 1){
					$eesArg = "-pfn " + $eesArg ;
				}
				wizExportEachSelectionToFile($eesArg + $ft);
				return {""};;
			}
			
			if ($renderThumbnail){
				select -r $exSelCopy;
				string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + " -ext jpg" + $opCom);
				wizMeshThumbnailImage($filename[0]);
			}
			
			//_________________________________________
			// Delete Export Objects
			if ($deo){
				delete $exSelCopy;
			}
			/*
			if ($deo){
				evalDeferred ("delete " + (stringArrayToString($exSelCopy, " ")) + ";");
			}
			*/
		}
		
	}
	
	string $setName;
	
	//_________________________________________
	// Create Render Proxy Set
	if ($ns && $renderProxySet){
		$setName = "wiz";
		if (`size $name` > 0){
			$setName = $setName + "_" + $name;
		} else {
			$setName = $setName + "_ObjectName";
		}
		$setName = $setName + "_renderProxySet";
		string $newSet = addSelectedObjectsToSet($sel, $setName);
		
		if (`attributeExists "polyReduce" $newSet` == 0){
			addAttr -ln "polyReduce" -at bool $newSet;
			setAttr ($newSet + ".polyReduce") 0;				
		}
		
		if (`attributeExists "useFileName" $newSet` == 0){
			addAttr -ln "useFileName" -at bool $newSet;
			setAttr ($newSet + ".useFileName") 1;				
		}
		if (`attributeExists "useSameDirectory" $newSet` == 0){
			addAttr -ln "useSameDirectory" -at bool $newSet;
			setAttr ($newSet + ".useSameDirectory") 0;				
		}
		
		if (`attributeExists "useCustomDirectory" $newSet` == 0){
			addAttr -ln "useCustomDirectory" -at bool $newSet;
			setAttr ($newSet + ".useCustomDirectory") 0;				
		}
		if (`attributeExists "exportDirectory" $newSet` == 0){
			addAttr -dt "string" -ln "exportDirectory" -uaf $newSet;
		}
		return {$setName};
	}
	
	//_________________________________________
	// Create New Export Set
	if ($ns){	
		$setName = "wiz";
		if (`size $name` > 0){
			$setName = $setName + "_" + $name;
		} else {
			$setName = $setName + "_base";
		}
		/*
		if (`size $type` > 0){
			$setName = "_" + $type;
		}
		*/
		/*
		if (`size $ext` > 0){
			$setName = $setName + "_" + $ext;
		}
		*/
		$setName = $setName + "_exportSet";
		
		string $newSet = addSelectedObjectsToSet($sel, $setName);	
		
		//string $filename[] = wizCraftGetFileOutputPaths("-n " + $name + " -typ " + $type + " -ext " + $ext);
	
		string $fileType[] = { "mb", "ma", "fbx", "obj", "abc", "mi" };
		
		for ($i=0;$i<`size $fileType`;$i++){				
			if (`attributeExists $fileType[$i] $newSet` == 0){
				addAttr -ln $fileType[$i] -at bool $newSet;
				if ($fileType[$i] == "fbx" || $fileType[$i] == "abc" || $fileType[$i] == "mi" ){
					setAttr ($newSet + "." + $fileType[$i]) 1;
				}
			} else {
				if ($fileType[$i] == "fbx" || $fileType[$i] == "abc" || $fileType[$i] == "mi" ){
					setAttr ($obj + "." + $fileType[$i]) 1;
				}
			}
				
		}
		
		if (`attributeExists "all" $newSet` == 0){
			addAttr -ln "all" -at bool $newSet;
			setAttr ($newSet + ".all") 0;				
		}
		
		if (`attributeExists "deleteHistory" $newSet` == 0){
			addAttr -ln "deleteHistory" -at bool $newSet;
			setAttr ($newSet + ".deleteHistory") 0;				
		}
		
		if (`attributeExists "polyReduce" $newSet` == 0){
			addAttr -ln "polyReduce" -at bool $newSet;
			setAttr ($newSet + ".polyReduce") 0;				
		}
		
		if (`attributeExists "exportMaterial" $newSet` == 0){
			addAttr -ln "exportMaterial" -at bool $newSet;
			setAttr ($newSet + ".exportMaterial") 0;				
		}
		
		if (`attributeExists "prepForPainting" $newSet` == 0){
			addAttr -ln "prepForPainting" -at bool $newSet;
			setAttr ($newSet + ".prepForPainting") 0;				
		}
		
		if (`attributeExists "bakeShading" $newSet` == 0){
			addAttr -ln "bakeShading" -at bool $newSet;
			setAttr ($newSet + ".bakeShading") 0;				
		}
		
		if (`attributeExists "exportXGenArchive" $newSet` == 0){
			addAttr -ln "exportXGenArchive" -at bool $newSet;
			setAttr ($newSet + ".exportXGenArchive") 0;				
		}
		
		if (`attributeExists "exportEachMesh" $newSet` == 0){
			addAttr -ln "exportEachMesh" -at bool $newSet;
			setAttr ($newSet + ".exportEachMesh") 0;				
		}
		
		wizlog ("export each Mesh attribute added");
		
		if (`attributeExists "useFileName" $newSet` == 0){
			addAttr -ln "useFileName" -at bool $newSet;
			setAttr ($newSet + ".useFileName") 1;				
		}
		
		if (`attributeExists "useExportObjectName" $newSet` == 0){
			addAttr -ln "useExportObjectName" -at bool $newSet;
			setAttr ($newSet + ".useExportObjectName") 0;				
		}
		
		if (`attributeExists "useSameDirectory" $newSet` == 0){
			addAttr -ln "useSameDirectory" -at bool $newSet;
			setAttr ($newSet + ".useSameDirectory") 0;				
		}
		
		if (`attributeExists "useCustomDirectory" $newSet` == 0){
			addAttr -ln "useCustomDirectory" -at bool $newSet;
			setAttr ($newSet + ".useCustomDirectory") 0;				
		}
		if (`attributeExists "exportDirectory" $newSet` == 0){
			addAttr -dt "string" -ln "exportDirectory" -uaf $newSet;
		}
		
		if (`attributeExists "renderThumbnail" $newSet` == 0){
			addAttr -ln "renderThumbnail" -at bool $newSet;
			setAttr ($newSet + ".renderThumbnail") 1;				
		}
	}
	
	
	
	return {$setName};
	
	
}

//@ WIZ EXPORT
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = procName("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc string[] wizExport( string $flags )
{
	wizlog ("[@] wizExport");
	string $sceneFile = `file -q -sn` ;
	string $dir;
	string $type = "mayaBinary";
	string $ext = "mb";
	string $name;
	string $com;
	string $filename;
	string $splice[];
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-dir" : case "-directory" :
			$dir = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = $tok[($i + 1)];
			break ;
			
			case "-com" : case "-command" :
			$com = wizFlagString($tok, $i);
			break ;			
			
			case "-dpr" : case "-dirPrompt" :
			$dir = wizGetDirectory();
			break ;
			
			case "-cd" : case "-currentDirectory" :
			$splice = wizSpliceFilePath($sceneFile, "-dir");
			$dir = $splice[0];
			break ;
			
			case "-cfn" : case "-currentFileName" :
			$splice = wizSpliceFilePath($sceneFile, "-fn");
			$name = $splice[0];
			break ;
			
			case "-ext" : case "-extension" :
			$ext = $tok[($i + 1)];
			break ;
						
		}
	}
	
	if (`size $filename` == 0){
		$filename = $dir + $name + "." + $ext;
	}
	
	wizlog ("file -f -type " + $type + " -options \"v=0;\" -pr -ea " + $filename + ";");
	
	string $exported = `file -f -type $type -options "v=0;" -pr -ea $filename`;

	return {$exported};
	
}

//@ WIZ GET ALTERNATE FILE TYPES
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $files[] = wizGetAlternateFileTypes("-fn C:/someDir/somefile.mb");
	
	</code>
*********************************************************************/
global proc string[] wizGetAlternateFileTypes( string $flags, string $filename )
{
	global string $WIZ_bookmarkWizSupportedFileTypes[];
	global string $WIZ_subFileFolderSuffix;
	
	global string $WIZ_sceneFileIconSuffix;
    global string $WIZ_sceneFileRenderIconSuffix;
	global string $WIZ_sceneFilePosterSuffix;
	string $filename, $dir;
	string $sel[];
	int $edit;
	string $ext;
	int $thumb, $pst;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-filename" : case "-fn" :
			$filename = $tok[($i + 1)];
			break ;
				
			case "-dir" : case "-directory" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-e" : case "-edit" :
			$edit = 1;
			break ;
			
			case "-ext" : case "-extension" :
			$ext = $tok[($i + 1)];
			break ;
			
			case "-thumb" : case "-thumbnail" :
			$thumb = 1;
			break ;
			
			case "-pst" : case "-poster" :
			$pst = 1;
			break ;
		}
	}

	string $altFiles[];
	
	if (`size $filename` == 0){ return {""};}
	
	string $splice[] = wizSpliceFilePath($filename, "-dir -fn -ex");
		
	string $fileDir = $splice[0] + $splice[1] + $WIZ_subFileFolderSuffix + "/";
	wizlog ("	[+] Search File Directory : " + $fileDir);
	
	// Get all the files that match
	string $fileList[] = `getFileList -fld $splice[0] -filespec ("*" + $splice[1] + ".*")`;
	wizlog ("getFileList -fld " + $splice[0] + " -filespec (\"*\"" + $splice[1] + "\"*\");");
	wizlog (niceArrayList("Matching Files", $fileList));
	
	// Combine the full file path with all the filenames
	$fileList = stringArrayAddPrefix($fileList, $splice[0]);
	
	if (`filetest -e $fileDir` == 1){
		string $flist[] = `getFileList -fld $fileDir -filespec ("*" + $splice[1] + "*")`;
		wizlog ("getFileList -fld \"" + $fileDir + "\" -filespec (\"*" + $splice[1] + "*\");");
		wizlog (niceArrayList("Matching Files", $fileList));
		
		// Combine the full file path with all the filenames
		$flist = stringArrayAddPrefix($flist, $fileDir);
		appendStringArray($fileList, $flist, `size $flist`);
		
	}
	
	//_________________________________________
	// Poster or Thumbnails
	if ($thumb){
		string $thumbName = $splice[0] + $splice[1] + $WIZ_sceneFileIconSuffix;
		if (`filetest -e $thumbName` == 1){
			wizlog ("[THUMBNAIL] : " + $thumbName);
			return {$thumbName};
		} else {
			return {""};
		}
	}
	if ($pst){
		string $posterName = $splice[0] + $splice[1] + $WIZ_sceneFilePosterSuffix;
		if (`filetest -e $posterName` == 1){
			wizlog ("[POSTER] : " + $posterName);
			return {$posterName};
		} else {
			return {""};
		}
	}
	
	if ($ext != ""){
		// Keep only filenames that end in the requested extensions
		for ($i=0;$i<`size $fileList`;$i++){
			if ((endsWith($fileList[$i], $ext)) == 1){				
					$altFiles[`size $altFiles`] = $fileList[$i];
			}
		}
	} else {
		// Keep only filenames that end in the supported extensions
		for ($i=0;$i<`size $fileList`;$i++){
			for ($j=0;$j<`size $WIZ_bookmarkWizSupportedFileTypes`;$j++){				
				if ((endsWith($fileList[$i], $WIZ_bookmarkWizSupportedFileTypes[$j])) == 1){				
					$altFiles[`size $altFiles`] = $fileList[$i];
				}
			}
		}
	}
	
	
	$altFiles = stringArrayRemove({$filename}, $altFiles);
	
	wizlog (niceArrayList("[ALT FILES]", $altFiles));
	return $altFiles;
	

}

global proc string wizOutputProductInfo( string $flags )
{
	string $obj, $type;
	string $sel[];
	int $edit;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-obj" : case "-object" :
			$obj = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-e" : case "-edit" :
			$edit = 1;
			break ;
			
		}
	}
	if (`size $sel` == 0){
		$sel = wizFlagObjTrail($flags);
	}
	
	string $infoFile[] = wizCraftGetFileOutputPaths("-type ProductInfo -ext txt");
	
	return "";


}

global proc string[] findAllSceneReferences( string $flags )
{
	string $allReferences[];
	string $topLevelReferences[] = `file -q -r`;
	string $file;
	int $ldr;
	int $al;
	string $com;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-f" : case "-file" :
			$file = $tok[($i + 1)];
			$com = $com + "-f " + $file;
			break ;
	
			case "-ldr" : case "-listDuplicateReferences" :
			$ldr = 1;
			$com = $com + "-ldr ";
			break ;
			
			case "-al" : case "-arrayList" :
			$al = 1;
			break ;
		}
	}
	
	for ($eachReference in $topLevelReferences){

		string $nestedReferencesForEachFile[] = findContainedReferences($eachReference);
		$allReferences = `stringArrayCatenate $allReferences $nestedReferencesForEachFile`;
		
	}
	string $return[];
	if ($ldr == 0){
		for ($i=0;$i<`size $allReferences`;$i++){
			if ((endsWith($allReferences[$i], "}")) == 0){
				$return[`size $return`] = $allReferences[$i];
			}
		}
	} else {
		$return = $allReferences;
	}
	
	if ($al){
		print ("string $allReferences[] = { \n");
		for ($i=0;$i<`size $allReferences`;$i++){
			if ($i == (`size $allReferences` - 1)){
				print ("\"" + $allReferences[$i] + "\" \n");
			} else {
				print ("\"" + $allReferences[$i] + "\", \n");
			}
		}
		print (" };\n");
	}
	
	wizlog (niceArrayList("[References]", $return));
	return $return;

}



global proc string[] findContainedReferences( string $file )
{
	
	// recursive
	string $filesFoundSoFar[]; 
	$filesFoundSoFar[`size $filesFoundSoFar`] = $file; //add file to results	

	string $nestedReferencesFromFile[] = `file -q -r $file`;

	if (`size $nestedReferencesFromFile`){

		for ($eachFile in $nestedReferencesFromFile){
			string $EachFileReferences[] = findContainedReferences($eachFile); 				
			$filesFoundSoFar = `stringArrayCatenate $EachFileReferences $filesFoundSoFar`;		
			
		}

	}
	return $filesFoundSoFar;
	
	
	

	
}

//@ WIZ TRANSLATE IMAGE FILE TYPE
//====================================================================
/*****************************************************************//**
	Use flags to specify what part of a file path you want returned.
	
	<hr>
	<b>Synopsis</b><br>
	procName [-fa string] [-fb linear] <br>
	Returns a string array with the requested parts ordered in which
    they were requested.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-localProjectDirectory(-lpd) : Local Project Directory -lpd ("C:/Users/Someone/Maya/") <br>
	-projectPath(-pp) : Project Path -pp ("/ProjectName/scenes/someScene/") <br>
	-directory(-dir) : Directory -dir ("C:/Users/Someone/Maya/projects/ProjectName/scenes/SomeFolder/") <br>
	-fullFileName(-ffn) : Full File Name/ File Name Extension -ffn, -fne ("SomeFileName1.mb") <br>
	-fileName(-fn) : File Name -fn, -fnne ("SomeFileName1") <br>
	-fileNameNoVersion(-fnnv) : File Name No Version -fnnv ("SomeFileName") <br>
	-fileVersion(-fv) : File Version -fv -v ("1") <br>
	-extension(-ex) : Extension -ex, -ext ("mb") <br>
	-rootDirectory(-rd) : ("C:/Users/Someone/Maya/projects/ProjectName/") <br>
	-sceneFile(-sf) : ("C:/Users/Someone/Maya/projects/ProjectName/scenes/currentlyOpenedFilename.mb") <br>
	
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $filePath = "/Volumes/Shared3/projects/Assets/scenes/Shaders/Terrain/Construction/TerrainShaderConstruction18.mb";
	string $filePathSplice[] = wizSpliceFilePath($filePath, "-lpd -pp -dir -pn -fn -ex -ffn -fnnv -fv");
	
	</code>
*********************************************************************/
global proc string wizTranslateImageFileType( string $flags )
{
	/*
	string $imf = `getAttr -as "defaultRenderGlobals.imageFormat"`;
	string $imfn = `getAttr "defaultRenderGlobals.imageFormat"`;
	print("case \"" + $imf + "\" : case \"" + $imfn + "\" :\n");
	*/
	
	string $type;
	string $ext;
	int $ttex;
	int $extt;
	string $return;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-ttex" : case "-typeToExtension" :
			$type = $tok[($i + 1)];
			$ttex = 1;
			wizlog ("Translate Type : " + $type + " : To Extension");
			break;
			
			case "-extt" : case "-extensionToType" :
			$ext = $tok[($i + 1)];
			$extt = 1;
			wizlog ("Translate Extension : " + $ext + " : To Type");
			break;
			
			
		}
	}
	
	if ($ttex){
		switch($type){
			case "Maya IFF" : case "7" :
			$return = "iff" ;
			break ;
			
			case "Exr" : case "51" :
			$return = "exr";
			break ;
			
			case "PNG" : case "32" :
			$return = "png" ;
			break ;
			
			case "Tiff" : case "3" :
			$return = "tiff" ;
			break ;
			
			case "JPEG" : case "8" :
			$return = "jpg" ;
			break ;
			
		}
		
	} else if ($extt){
		switch($ext){
			case "jpg" : case ".jpg" : case ".jpeg" :
			$return = "JPEG" ;
			break ;
		}
		
	}
		
	return $return;
}

//wizMoveAllFilesInSubfoldersIntoFolder("-dp");
global proc string[] wizMoveAllFilesInSubfoldersIntoFolder( string $flags )
{
	string $dir;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-dp" : case "-directoryPrompt" :
			$dir = wizGetDirectory();
			
			break;

		}
	}
	
	string $allFiles[] = wizGetAllFilesInSubfoldersOfDirectory($dir);
	
	wizlog (niceArrayList("[ALL FILES]", $allFiles));
	
	for ($i=0;$i<`size $allFiles`;$i++){
		string $splice[] = wizSpliceFilePath($allFiles[$i], "-ffn");
		string $dest = $dir + $splice[0];
		wizlog ("[#] Moving : " + $allFiles[$i] + " To : " + $dest + "\n");
		sysFile -move $dest $allFiles[$i];
		
	}
	
	
	string $allSubDir[] = wizGetAllSubFoldersOfDirectory($dir);
	
	for ($i=0;$i<`size $allSubDir`;$i++){
		wizlog ("[-] Removing Empty Directory : " + $allSubDir[$i]);
		sysFile -red $allSubDir[$i];
	}

	return $allFiles;
	
	
}

global proc string[] wizGetAllFilesInSubfoldersOfDirectory( string $dir )
{
	
	wizlog ("[@] wizGetAllFilesInSubfoldersOfDirectory");

	string $allSubDir[] = wizGetAllSubFoldersOfDirectory($dir);
	//wizlog (niceArrayList("[#] All Sub Directories[#]", $allSubDir));
	
	string $all[];
	for ($i=0;$i<`size $allSubDir`;$i++){
		string $file[] = `getFileList -fld $allSubDir[$i] -fs ("*.*")`;
		//wizlog ("[#] Directory : " + $allSubDir[$i]);
		//wizlog (niceArrayList("[#] Files In Directory [#]", $file));
		stringArrayAddPrefix($file, $allSubDir[$i]);
		$all = stringArrayCatenate($all, $file);
	}
	
	return $all;
	
	
}

//@ WIZ COLLECT FILES
//====================================================================
/*****************************************************************//**
	Finds All External Files Referenced In Scene and Copies Them To Another Directory.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] the new file paths.
	
	<b>Flags</b><br>
	-directory(-dir) <br>
	-directoryPrompt(-dp) <br>
	-type(-typ) <br>
	-currentFileDirectory(-cfd) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $newFilePaths[] = wizCollectFiles("-directoryPrompt");
	string $newFilePaths[] = wizCollectFiles("-currentFileDirectory");
	
	</code>
*********************************************************************/
global proc string[] wizCollectFiles( string $flags)
{
	string $dir;
	string $type;

	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-dir" : case "-directory" :
			$dir = $tok[($i + 1)];
			break ;
				
			case "-typ" : case "-type" :
			$type = $tok[($i + 1)];
			break ;
			
			case "-dp" : case "-directoryPrompt" :
			$dir = wizGetDirectory();
			break ;			
			
			case "-cfd" : case "-currentFileDirectory" :
			string $sceneFile = `file -q -sn` ;
			string $splice[] = wizSpliceFilePath($sceneFile, "-dir");
			$dir = $splice[0];
			break ;
			
		}
	}
	
	int $c = 0;
	string $nodes[] = `file -q -list`;
	string $return[];
	if (`size $nodes`) {
		for ($i = 0;$i < `size $nodes`; $i++) {
			$sourceFile = $nodes[$i];
			$testFile = (`fromNativePath $sourceFile`);
			if (`filetest -f $testFile`) {
				system ("xcopy \"" + `toNativePath $sourceFile` + "\" \"" + `toNativePath $dir` + "\"");
				string $splice[] = wizSpliceFilePath($sourceFile, "-ffn");
				string $newFilePath = $dir + $splice[0];
				wizlog (" [#] Copying : " + $sourceFile + " ---- To : " + $newFilePath);
				$return[`size $return`] = $newFilePath; 
				$c++;
			} else {
				wizlog (" [!] File Not Found : " + $testFile);
				//warning ("File not found: " + $testFile);
			}
		}
	}
	return $return;
}

//############################################################################

//	GARBAGE

//############################################################################

//@ WIZ FIND MISSING FILES IN IMAGE SEQUENCE
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	A more detailed description.
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = wizFindMissingFilesInImageSequence("-fp");
	
	</code>
*********************************************************************/
global proc string[] wizFindMissingFilesInImageSequence( string $flags )
{
	string $file;
	string $sel[];
	int $start = 0;
	
	int $edit;
	string $sourceDir;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-fp" : case "-filePrompt" :
			//$file = wizGetAnyFile();
			$sourceDir = wizGetDirectory();
			break ;
				
			case "-s" : case "-start" :
			$start = int($tok[($i + 1)]);
			break ;
			
			case "-e" : case "-end" :
			$end = int($tok[($i + 1)]);
			break ;
			
		}
	}
	
	string $sourceDir = wizGetDirectory();	
	string $files[] = `getFileList -fld $sourceDir -fs ("*.*")`;
	
	//string $splice[] = wizSpliceFilePath($file, "-dir -ex -ffn -sn");
	
	string $seqNums[];
	for ($i=0;$i<`size $files`;$i++){
		string $splice[] = wizSpliceFilePath($files[$i], "-sn");	
		$seqNums[$i] = $splice[0];
	}
	
	sort($seqNums);
	int $lastNum = int($seqNums[0]);
	for ($i=1;$i<`size $seqNums`;$i++){
		int $num = int($seqNums[$i]);
		if (($num - $lastNum) > 1){ 
			wizlog ("[MISSING] : " + ($seqNums[$i] + 1));
			/* NOT FINISHED
			wizlog ("[MISSING] : " + ($num - $seqNum)
			*/
		}
		$lastNum = $num;
	}
	
	
	
	
	//string $allSeqImages[] = 
	
	return {""};
}


global proc compareEmojiImageOutput()
{
	//string $sourceDir = wizGetDirectory();
	string $sourceDir = "C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Source/twemoji-gh-pages/twemoji-gh-pages/png2/";	
	//C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Source/twemoji-gh-pages/twemoji-gh-pages/png2
	
	//string $outputDir = wizGetDirectory();
	string $outputDir = "C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Process/EmojisA/Output/A/";
	//C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Process/EmojisA/Output/A
	
	//string $copyDir = wizGetDirectory();
	//C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Process/EmojisA/MissingSource
	string $copyDir = "C:/Users/Glen/Documents/Projects/DeepLocal/OldNavy/Emoji/Process/EmojisA/MissingSource/";
	
	string $srcFiles[] = `getFileList -fld $sourceDir -fs ("*.*")`;
	string $outFiles[] = `getFileList -fld $outputDir -fs ("*.*")`;
	
	string $inFile[];
	string $outFile[];
	for ($i=0;$i<`size $srcFiles`;$i++){
	
		string $splice[] = wizSpliceFilePath($srcFiles[$i], "-fn");
		$srcFiles[$i] = $sourceDir + $srcFiles[$i];
		$inFile[$i] = $splice[0];
	}
	
	for ($i=0;$i<`size $outFiles`;$i++){
		string $splice[] = wizSpliceFilePath($outFiles[$i], "-fn");
		$outFile[$i] = $splice[0];
	}

	string $ofs[];
	for ($i=0;$i<`size $outFile`;$i++){
		string $tok[] = tokenizeString($outFile[$i], "x");
		$ofs[$i] = $tok[0];
	}
	
	print ("[MISSING FILES]\n");
	int $missingCount;
	string $copyCom[];
	for ($i=0;$i<`size $inFile`;$i++){
		int $ok = stringArrayContains($inFile[$i], $ofs);
		if (!$ok){
			print ($inFile[$i] + "\n");
			$copyCom[`size $copyCom`] = ("xcopy \"" + `toNativePath $srcFiles[$i]` + "\" \"" + `toNativePath $copyDir` + "\"");
			//print ($copyCom + "\n");
			system ("xcopy \"" + `toNativePath $srcFiles[$i]` + "\" \"" + `toNativePath $copyDir` + "\"");
			$missingCount++;
		}
	}
	
	print ("[MISSING COUNT] : " + $missingCount + "\n");
	print (stringArrayToString($copyCom, "\n"));
				
}

//@ WIZ RESAVE FILES
//====================================================================
/*****************************************************************//**
	Just imports files and saves them as same file.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	Use this to resolve old file compatibility problems.
	
	<b>Return value</b><br>
	
	<b>Flags</b><br>
	-filePrompt(-fp) <br>
	-directoryPrompt(-dp) <br>
	-includeSubDirectories(-isd) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	wizResaveFiles("-dp -isd");
	wizResaveFiles("-f " + $allReferences[$i]);
	</code>
*********************************************************************/
global proc wizResaveFiles( string $flags )
{
	int $isd;
	int $useDir;
	string $sourceDir;
	string $sourceFile[];
	string $maFiles[];
	string $mbFiles[];
	
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
					
			case "-fp" : case "-filePrompt" :
			$sourceFile[0] = wizGetAnyFile();
			break ;
								
			case "-dp" : case "-directoryPrompt" :
			$sourceDir = wizGetDirectory();
			$useDir = 1;
			break ;
			
			case "-isd" : case "-includeSubDirectories" :
			$isd = 1;
			break ;			
			
			case "-f" : case "-file" :
			$sourceFile[0] = $tok[($i + 1)];
			break ;
			
		}
	}

	
	
	if ($isd){
		string $allSubDir[] = wizGetAllSubFoldersOfDirectory($sourceDir);
		for ($i=0;$i<`size $allSubDir`;$i++){
			string $dirMaFiles[] = `getFileList -fld $allSubDir[$i] -fs ("*.ma")`;
			stringArrayAddPrefix($dirMaFiles, $allSubDir[$i]);
			$maFiles = stringArrayCatenate($dirMaFiles, $dirMaFiles);
			$sourceFile = stringArrayCatenate($sourceFile, $dirMaFiles);
			
			string $dirMbFiles[] = `getFileList -fld $allSubDir[$i] -fs ("*.mb")`;
			stringArrayAddPrefix($dirMbFiles, $allSubDir[$i]);
			$mbFiles = stringArrayCatenate($dirMbFiles, $dirMbFiles);
			$sourceFile = stringArrayCatenate($sourceFile, $dirMbFiles);
			
		}
	} else if ($useDir) {
		string $dirMaFiles[] = `getFileList -fld $sourceDir -fs ("*.ma")`;
		stringArrayAddPrefix($dirMaFiles, $sourceDir);
		$maFiles = stringArrayCatenate($dirMaFiles, $dirMaFiles);
		$sourceFile = stringArrayCatenate($sourceFile, $dirMaFiles);
		
		string $dirMbFiles[] = `getFileList -fld $sourceDir -fs ("*.mb")`;
		stringArrayAddPrefix($dirMbFiles, $sourceDir);
		$mbFiles = stringArrayCatenate($dirMbFiles, $dirMbFiles);
		$sourceFile = stringArrayCatenate($sourceFile, $dirMbFiles);
		
	}
	
	wizlog (niceArrayList("SOURCE FILES :", $sourceFile));
	
	for ($i=0;$i<`size $sourceFile`;$i++){
		int $ma = endsWith($sourceFile[$i], "ma");
		
		file -f -new;	
		file -f -pr -i $sourceFile[$i];
		
		string $up[] = `unknownPlugin -q -l`;
		for ($p=0;$p<`size $up`;$p++){
			unknownPlugin -r $up[$p];
			wizlog ("[-] Removed Unknown Plugin : " + $up[$p]);
		}
		
		file -rename $sourceFile[$i] ;
		wizlog ("[RE-SAVED FILE] : " + $sourceFile[$i]);
		
		if ($ma){		
			file -f -type "mayaAscii" -options "v=0;" -pr -save ;
		} else {
			file -f -type "mayaBinary" -options "v=0;" -pr -save ;
		}
		
	}
	

	wizlog ("[*] FINISHED PROCESSING FILES [*]");

	

}

global proc wizRemoveUnknownPlugins( string $flags )
{
	string $up[] = `unknownPlugin -q -l`;
	for ($p=0;$p<`size $up`;$p++){
		unknownPlugin -r $up[$p];
		wizlog ("[-] Removed Unknown Plugin : " + $up[$p]);
	}

}

/*
global proc createNoHistoryDuplicate()
{
	duplicate -rr -renameChildren; parent -w treeBrush1Main treeBrush1Leaf treeBrush1Flower;
	file -force -options "v=0;" -typ "mayaAscii" -es "C:/Users/Glen/Documents/maya/projects/Assets/scenes/Models/Foliage/Trees/Deciduous/TreesB/XGen/TreeNoHistoryTest1.ma";

}
*/

global proc wizMaya2016SafeNewFile()
{
	//tearOffPanel "Hypershade" "hyperShadePanel" true;
	
	removeHyperShadePanel hyperShadePanel1;

}

//@  WIZ EXPORT M R RENDER PROXY
//====================================================================
/*****************************************************************//**
	Brief description.
	<hr>
	<b>Synopsis</b><br>
	procName [-obj string] [-typ linear] <br>
	Name Proxy objects objectName_PROXY
	
	<b>Return value</b><br>
	string[] description of return.
	
	<b>Flags</b><br>
	-object(-obj) <br>
	-selected(-sl) <br>
	-type(-typ) <br>
	-edit(-e) <br>
	-query(-q) <br>
		
	<hr>
	<b>Related</b><br>
	someProcedure(),
	
	<b>Examples</b><br>
	<code>
	string $arr[] = wizExportMRRenderProxy("-obj someObject -q -sl");
	
	</code>
*********************************************************************/
global proc wizExportMRRenderProxy( string $flags )
{
	wizlog ("[@] wizExportMRRenderProxy");
	string $obj, $type;
	string $sel[];
	string $oSel[];
	int $reduce;
	int $dh;
	int $osl;
	int $em;
	int $delExportObjects;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-typ" : case "-type" :
			$type = wizFlagString($tok, $i);
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
			case "-r" : case "-reduce" :
			$reduce = 1;
			break ;
			
			case "-dh" : case "-deleteHistory" :
			$dh = 1;
			break ;
			
			case "-osl" : case "-originalSelection" :
			$oSel = wizFlagObjTrail($flags);
			$osl = 1;
			wizlog (niceArrayList("[#] Orginal Selection [#] ", $oSel));
			break ;
			
			case "-deo" : case "-deleteExportObjects" :
			$delExportObjects = 1;
			break ;
			
			case "-em" : case "-exportMaterial" :
			$em = 1;
			break ;
			
		}
	}
		
	select -r $sel;
	wizlog ((niceArrayList("[#] Selected Objects For Exporting : ",$sel)));
	
	string $vis[] = `ls -v $sel`;	
	$sel = $vis;
	
	wizlog ((niceArrayList("[#] Visible Objects : ",$sel)));
	string $exSel[];
	
	//_________________________________________
	// Delete the history and reduce
	
	if ($dh){		
		for ($i=0;$i<`size $sel`;$i++){			
			string $dup[] = `duplicate -rr -renameChildren $sel[$i]`;
			wizlog ("[+] Duplicate : " + $sel[$i]);
			parent -w $dup[0];			
			delete -ch $dup[0];	
			
			if ($reduce){
				wizPolyReduce($dup[0]);
				delete -ch $dup[0];
			}
			$exSel[`size $exSel`] = $dup[0];
		}
	} else {
		$exSel = $sel;
	}
	
	//_________________________________________
	// Look For Proxy Objects
	/*
	
	//string $rawObjNames[] = getRawObjectNames($sel);
	for ($i=0;$i<`size $sel`;$i++){
		string $numbers = `match "[0-9]+" $sel[$i]`;
		$noNums = substituteAllString($sel[$i], $numbers, "");//remove numbers
		
		string $lsProxy[] = `ls ("*" + $noNums + "*")`;
		for ($p=0;$p<`size $lsProxy`;$p++){
			if ((endsWith($lsProxy[$p],"_PROXY")) == 1){	
				wizlog ("[#############] Proxy Object Found : " + $lsProxy[$p]);
				string $proxyDup[] = `duplicate -rr -renameChildren $lsProxy[$p]`;
				parent -w $proxyDup[0];			
				delete -ch $proxyDup[0];	
				$proxy[`size $proxy`] = $proxyDup[0];
			}
		}
		
	}
	*/
	string $proxy[];
	if ($osl){
		for ($i=0;$i<`size $oSel`;$i++){			
			wizlog ("[???????????] Looing For Proxy Object : " + ($oSel[$i] + " PROXY"));
			if (`objExists ($oSel[$i] + "_PROXY")`){
				wizlog ("[#############] Proxy Object Found : " + ($oSel[$i] + "_PROXY"));
				string $proxyDup[] = `duplicate -rr -renameChildren ($oSel[$i] + "_PROXY")`;
				if ((catchQuiet("parent -w " + $proxyDup[0])) == 0){
					parent -w $proxyDup[0];
				}			
				delete -ch $proxyDup[0];	
				$proxy[`size $proxy`] = $proxyDup[0];
				
			}	
		}		
	}
	
	//_________________________________________
	// Group the copies
	string $filePathSplice[] = wizSpliceFilePath(`file -q -sn`, "-fn -dir");
	
	select -r $exSel;
	
	// Clean up
	deleteExtraMeshNodesOnSelectedObjects(`ls -sl`);
	wizFlattenUVSetsOnSelectedObjects(`ls -sl`);
	
	//group -n $filePathSplice[0] ;
	
	//_________________________________________
	// Export the mi file
	string $filename[] = wizCraftGetFileOutputPaths("-ext mi");
	wizlog ("Exporting MR Proxy File : " + $filename[0]);
	select -r $exSel;
	//file -force -options ("binary=1;compression=0;tabstop=8;perframe=0;padframe=0;perlayer=0;pathnames=3313333333;assembly=1;fragment=1;fragsurfmats=1;fragsurfmatsassign=1;fragincshdrs=1;fragchilddag=1;passcontrimaps=1;passusrdata=0;filter=00000011010000001101000;overrideAssemblyRootName=0;assemblyRootName= \" -typ \"mentalRay\" -es \"" + $filename[0] + "\""); // \\"
	string $exMatString;
	string $mrExportCommand = "Mayatomr -mi  -exportFilter 721600 -active -binary -fe ";
	if ($em == 1){
		$mrExportCommand = $mrExportCommand + "-fem  -fma ";
	}	
	$mrExportCommand = $mrExportCommand + "-fis  -fcd  -pcm  -as  -asn " + $filePathSplice[0] + " -xp \"3313333333\" -file \"" + $filename[0] + "\";";
	wizlog ("[MR Export Command] \n" + $mrExportCommand); 
	eval ($mrExportCommand);
	
	//Mayatomr -mi  -exportFilter 721600 -active -binary -fe  -fem  -fma  -fis  -fcd  -pcm  -as  -asn $filePathSplice[0] -xp "3313333333" -file $filename[0];

	/*
	Export without materials
	Mayatomr -mi  -exportFilter 721600 -active -binary -fe  -fis  -fcd  -pcm  -as  -asn "proxyModel1" -xp "3313333333" -file "C:/Users/Glen/Documents/maya/projects/Assets/scenes/Testing/MRProxyTesting/proxyModel1.mi";
	*/
	/*
	Export ASCII
	file -force -options "binary=0;compression=0;tabstop=8;perframe=0;padframe=0;perlayer=0;pathnames=3313333333;assembly=1;fragment=1;fragsurfmats=1;fragsurfmatsassign=1;fragincshdrs=1;fragchilddag=1;passcontrimaps=1;passusrdata=0;filter=00000011010000001101000;overrideAssemblyRootName=0;assemblyRootName=" -typ "mentalRay" -es "C:/Users/Glen/Documents/maya/projects/Assets/scenes/Models/SciFi/Components/Exterior/Structures/mediumStructuresD/mediumStructureD3_files/mediumStructureD3a.mi";
	Mayatomr -mi  -exportFilter 721600 -active -tabstop 8 -fe  -fem  -fma  -fis  -fcd  -pcm  -as  -asn "mediumStructureD3a" -xp "3313333333" -file "C:/Users/Glen/Documents/maya/projects/Assets/scenes/Models/SciFi/Components/Exterior/Structures/mediumStructuresD/mediumStructureD3_files/mediumStructureD3a.mi";
	*/

	//_________________________________________
	// Create a proxy	
	string $exportProxy;
	string $exProxyMesh;
	int $createLowPolyProxy = `checkBox -q -v exportWiz_createLowPolyProxy_checkBox`;
	
	if (`size $proxy` > 0){
		//_________________________________________
		// Create a proxy from objects with suffix PROXY
		if (`size $proxy` > 1){
			wizlog (niceArrayList("[#] Creating Proxy Mesh From Objects  : ", $proxy));
			select -r $proxy;
			string $unitedProxy[] = `polyUnite -ch 1 -mergeUVSets 1 -name ($filePathSplice[0] + "_PROXY")`;
			select -r $unitedProxy[0];
			delete -ch;	
			select -r $unitedProxy[0];
			//assignDefaultShaderToSelected(`ls -sl`);
			string $s[] = `listRelatives -type "mesh" $unitedProxy[0]`;
			setAttr -type "string" ($s[0] + ".miProxyFile") ($filename[0]);
			//setAttr ($s[0] + ".miUpdateProxyBoundingBoxMode") 3;
			$exportProxy = $unitedProxy[0];
			$exProxyMesh = $s[0];
		} else {
			select -r $proxy[0];
			delete -ch;	
			select -r $proxy[0];
			//assignDefaultShaderToSelected(`ls -sl`);
			string $s[] = `listRelatives -type "mesh" $proxy[0]`;			
			setAttr -type "string" ($s[0] + ".miProxyFile") ($filename[0]);
			//setAttr ($s[0] + ".miUpdateProxyBoundingBoxMode") 3;
			$exportProxy = $proxy[0];
			$exProxyMesh = $s[0];
		}
	} else if ($createLowPolyProxy) {
		//_________________________________________
		// Create a low poly duplicate with the render proxy attached
			string $loPolyVer[] = wizPolyResVersions("-sl -lo");
			string $s[] = `listRelatives -type "mesh" $loPolyVer[0]`;			
			setAttr -type "string" ($s[0] + ".miProxyFile") ($filename[0]);
			$exportProxy = $loPolyVer[0]; 
			$exProxyMesh = $s[0];
		
	} else {
		//_________________________________________
		// Create a proxy cube with the render proxy attached
		wizlog ("[#] Creating Proxy Cube Mesh ");
		
		string $cube[] = `polyCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1 -n ($filePathSplice[0] + "_PROXY")`;
		string $s[] = `listRelatives -type "mesh" $cube[0]`;		
		
		setAttr -type "string" ($s[0] + ".miProxyFile") ($filename[0]);
		//setAttr ($s[0] + ".miUpdateProxyBoundingBoxMode") 3;
		$exportProxy = $cube[0]; 
		$exProxyMesh = $s[0];
		
	}
	refreshAE ;
	refresh -f;

	//_________________________________________
	// Refresh Render Proxy
	AEmentalrayRenderProxyUpdate ($exProxyMesh + ".miProxyFile");
	
	//_________________________________________
	// Export the proxy obj
	refreshAE;
	refresh -f;
	
	select -r $exportProxy;
	string $newFilePathSplice[] = wizSpliceFilePath($filename[0], "-dir");
	string $exProFilename = ($newFilePathSplice[0] + $filePathSplice[0] + "_PROXY.ma");
	
	/*
	//_________________________________________
	// Create script node to load mi file
	string $setAttrCom = ("setAttr -type \"string\" \"" + $exProxyObj + ".miProxyFile\" \"" + $filename[0] + "\";");
	string $bs = (
	$setAttrCom +"\n"
	+"print (\"[LOADED PROXY OBJECT]\\n\");"+"\n"
	+"print (\"" + $setAttrCom + "\");"+"\n"
	);
	
	string $snName = "LoadMRRenderProxyObj";
	if (`objExists $snName`){
		scriptNode -e -bs $bs $snName;
	} else {
		scriptNode -st 2 -bs $bs -n $snName;
	}
	select -add $snName;
	*/
	
	//_________________________________________
	// Do the export
	wizlog ("[+] Exporting Proxy Mesh Object : " + $exProFilename);
	file -force -options "v=0;" -typ "mayaAscii" -es $exProFilename;

	if ($delExportObjects){
		delete $exportProxy;
		//evalDeferred ("delete " + $exportProxy + ";");
	}
	refreshAE;
	refresh ;
		
	
}


global proc string wizExportXGenArchive( string $flags )
{
	string $filename;
	string $sel[];
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			case "-f" : case "-filename" :
			$filename = $tok[($i + 1)];
			break ;
			
			case "-sl" : case "-selected" :
			$sel = `ls -sl`;
			break ;			
			
		}
	}
/*
		//string $ns = getFileNameNoPathNoExt($filename);
	if (`size $filename` == 0){
		$filename = `file -q -sn`; 
		$filename = 
		string $newDir = wizMakeDir(($filePathSplice[1] + "xgenArchive" + "/"));
		if ($newDir == ""){ return {""};}
		$exportDir = $newDir;
	}
*/
	string $exported;	
	if (`size $sel` == 0){
		$exported = `file -f -type "mayaAscii" -options "v=0;" -ea $filename`;
	} else {
		$exported = `file -f -type "mayaAscii" -options "v=0;" -es $filename`;
	}
	
	//_________________________________________
	// Eport Thumbnail
	string $filePathSplice[] = wizSpliceFilePath($filename, "-dir -fn");
	string $thumbName = ($filePathSplice[0] + $filePathSplice[1] + ".PNG");
	wizXgenThumbnailImage("-f " + $thumbName);
	

	return $exported;
}


global proc wizRefreshRenderProxyObject()
{
	string $mesh[] = smartSelectObjectsOfType(`ls -sl`, "-typ mesh");
	wizlog (niceArrayList("[MESHES]", $mesh));
	for ($i=0;$i<`size $mesh`;$i++){
		
		AEmentalrayRenderProxyUpdate ($mesh[$i] + ".miProxy");
		wizlog ("AEmentalrayRenderProxyUpdate " + $mesh[$i] + ".miProxy ;");
	}

}


global proc wizAssemblyDefinition( string $flags )
{
	wizlog ("[@] wizAssemblyDefinition");
	string $list;
	string $filename;
	int $cd;
	string $tok[] = tokenizeString($flags, " ");
	for ($i=0;$i<`size $tok`;$i++){
		switch ($tok[$i]){
			
			case "-cd" : case "-createDefinition" :
			$cd = 1;
			break ;
			
			case "-l" : case "-list" :
			$list = $tok[($i + 1)];
			wizlog ("[List] : " + $list);
			break ;
			
		}
	}

	string $newAssDef;
	
	if ($cd){

		if (`size $list` > 0){
			string $bmsi[] = `textScrollList -q -si $list`;
			
			string $siFilename = fromNativePath($bmsi[0]);
			
			$filename = $siFilename;
			wizlog ("[FILENAME] : " + $filename);
		}
		
		string $splice[] = wizSpliceFilePath($filename, "-fn");
		wizlog ("New Assembly Definition : -name : " + $splice[0]);
		$newAssDef = `assembly -name ($splice[0])`;
		
		string $abc[] = wizGetAlternateFileTypes("-ext abc", $filename);
			
		
		//_________________________________________
		// Create Locator
		wizlog ("Create Assembly Locator");
		assembly -edit -createRepresentation "Locator" -repName ($splice[0] + "Locator") -input ($splice[0]) $newAssDef;
		
		//_________________________________________
		// Create Cache Rep
		if (`size $abc` > 0){
			wizlog ("Create Assembly Cache Representation");
			assembly -edit -createRepresentation "Cache" -input $abc[0] $newAssDef;
		} else {
		
o		warning ("No Cache File Found For Assembly Definition : " + $newAssDef + "\n");
		}
		
		//_________________________________________
		// CreateSceneRep
		string $ma[] = wizGetAlternateFileTypes("-ext ma", $filename);
		if (`size $ma` > 0){
			wizlog ("Create Assembly Scene Representation");
			assembly -edit -createRepresentation "Scene" -input $ma[0] $newAssDef;
		} else {
			warning ("No Scene File Found For Assembly Definition : " + $newAssDef + "\n");
		}
		
		/*
		//_________________________________________
		// CreateRenderProxyRep
		string $ma[] = wizGetAlternateFileTypes("-ext ma", $filename);
		if (`size $ma` > 0){
			assembly -edit -createRepresentation "Scene" -input $ma[0] $newAssDef;
		}
		*/
		wizlog ("Splice : " + $abc[0]);
		string $active[] = wizSpliceFilePath($abc[0], "-ffn");
		wizlog ("assembly -edit -active " + $active[0] + " " + $newAssDef + ";");
		assembly -edit -active $active[0] $newAssDef;
		
	}

}

global proc wizLocateInExplorer( string $filepath )
{
	wizlog ("FilePath : " + $filepath);
	print ("explorer \"" + $filepath + "\"");
	system ("explorer \"" + $filepath + "\"");

}


global proc wizRenderMagFieldData()
{
	// On first frame, create array of all data mel files
	// pre render mel
	//------------------
	// On each time step import the next mel file.
	// Use thin line shader and select all the curves imported and apply line shader
	
	// post render mel
	//------------------
	// delete the curves that were imported and the line that were created

	///Shared3/projects/MagneticForces/data/mel/BATSRUS_20061215T001000.mel//
	
	
	// PRE MEL
	//=============

	float $currentTime = `currentTime -q`;
	global string $dataFile[];
	if ($currentTime == 0){

		//$dataFile = wizGetFiles("-dir /Volumes/Shared3/projects/MagneticForces/data/mel/Batsrus/ -type mel");
		string $dataDir = "F:/maya/projects/MagneticForces/data/mel/Batsrus/";
		$dataFile = wizGetFiles("-dir " + $dataDir + " -type mel");
		

	}
	int $i = int($currentTime);
	string $rnn[] = `file -rnn -f -i $dataFile[$i]`;
	print ("Importing Data File : " + $dataFile[$i] + "\n");
	select -r $rnn;
	string $ncurve[] = `ls -type nurbsCurve -sl`;
	select -r $ncurve;
	global string $newCurves[] ;
	$newCurves = `listTransforms -sl`;
	
	string $thinLine = "ThinLineShader1:ThinLineShader";
	select -add $thinLine;
	
	global string $thinLines;
	$thinLines = wizBuildThinLines("-sl");


	// POST MEL
	//=============

	global string $newCurves[] ;
	select -r $newCurves;
	delete;
	
	global string $thinLine;
	delete $thinLine;
	
	
}

/*
global proc convertSTEPFilesToFBX()
{

}
*/
// CONVERT ALL STEP FILES IN DIR TO FBX
//=============================================================
global proc convertAllSTEPFilesInDirToFBX()
{
	string $dir = wizGetDirectory();
	string $stepFiles[] = wizGetAllFilesOfTypeInAllSubfoldersOfDirectory($dir, "STEP");
	string $stpFiles[] = wizGetAllFilesOfTypeInAllSubfoldersOfDirectory($dir, "stp");
	
	string $allFiles[] = stringArrayCatenate($stepFiles, $stpFiles);
	
	if (`size $stepFiles` == 0){
		print ("No STEP Files Found!");
	}
	for ($i=0;$i<`size $allFiles`;$i++){
		//file -f -i $stepFiles[$i];
		print ("Opening STEP FILE : ");
		file -import -type "STEP_ATF"  -ignoreVersion -ra true -mergeNamespacesOnClash false -options "ts=1;en=0;nt=15;st=0;gar=21.5;mel=11.314646" -pr -importFrameRate true -importTimeRange "override" $allFiles[$i];
		print ("\n");
		string $splice[] = wizSpliceFilePath($allFiles[$i], "-dir -fn");
		string $nn = $splice[0] + $splice[1] + ".fbx";
		string $objName = $splice[0] + $splice[1] + ".obj";
		print ("Convert To FBX File : " + $nn + "\n");
		//wizExportFBX($nn);
		
		file -force -options "ts=1;en=0;nt=15;st=0;gar=21.5;mel=11.314646" -type "FBX export" -pr -ea $nn;

		file -force -options "groups=1;ptgroups=1;materials=1;smoothing=1;normals=1" -typ "OBJexport" -pr -es $objName;

		
		saveFileThumbnailImage($allFiles[$i]);
		
		file -f -new;
	}
	
}

// CONVERT ALL STEP FILES IN DIR TO FBX
//=============================================================
global proc convertAllFBXFilesInDirToOBJ()
{
	string $dir = wizGetDirectory();
	string $fbxFiles[] = wizGetAllFilesOfTypeInAllSubfoldersOfDirectory($dir, "fbx");

	//string $allFiles[] = stringArrayCatenate($stepFiles, $stpFiles);
	
	if (`size $fbxFiles` == 0){
		print ("No FBX Files Found!");
	}
	for ($i=0;$i<`size $fbxFiles`;$i++){
		
		print ("Opening FBX FILE : ");
		file -import -type "FBX"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "n1"  -pr  -importFrameRate true  -importTimeRange "override" $fbxFiles[$i];

		print ("\n");
		string $splice[] = wizSpliceFilePath($fbxFiles[$i], "-dir -fn");
		string $nn = $splice[0] + $splice[1] + ".fbx";
		string $objName = $splice[0] + $splice[1] + ".obj";
		print ("Convert To FBX File : " + $nn + "\n");
		
		file -force -options "groups=1;ptgroups=1;materials=1;smoothing=0;normals=1" -type "OBJexport" -pr -ea $objName;

		saveFileThumbnailImage($fbxFiles[$i]);
		
		file -f -new;
		
	}
	
}
