/* NOTES:

createSurfaceFlamesGrid
=========================
After duplicating flames grid fluid...
Take the cache from the source fluid and apply it to all the duplicates.
Then offset the cache in the trax editor by random amounts.

or...

can you instance a fluid without a cache... and then attach a cache? NO probably not.

or...

duplicate like 10 flame fluids... then apply the cache of the first flame fluid to the duplicates. Then offset the cache trax clips.
then instance those 10 flames onto the geodesic sphere.

Other possible options: 
	Get size of geodesic sphere poly and resize fluid to fit better.
	Emit falloff from polyface into each fluid

*/

global proc sunWiz()
{
/*
global string $sunWizWindow;
$sunWizWindow = "sunWiz";
if(`window -exists $sunWizWindow`){
	deleteUI $sunWizWindow;
}

window
	-title "Sun Wiz"
	-widthHeight 400 200
	-menuBar on
	-menuBarVisible on
	-minimizeButton on
	-maximizeButton on
	-sizeable on		
	-resizeToFitChildren on
	-titleBar on
	$sunWizWindow;
	
	sunRiggingLayout($sunWizWindow);
	
showWindow $sunWizWindow;
*/
}

global proc sunRiggingLayout(string $parent)
{
string $sunRiggingLayout = `frameLayout
		-l "Sun Rigging"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
		
		attachToSunSurfaceLayout($sunRiggingLayout);
			
		createSurfaceFlamesGridLayout($sunRiggingLayout);
		
		placeRandomlyOnSunSurfaceLayout($sunRiggingLayout);
		
		randomizeSelectedFluidCacheStartTimesLayout($sunRiggingLayout);
		
		sunAnimationExpressionsLayout($sunRiggingLayout);
		
		cameraAngleRampAlphaExpressionLayout($sunRiggingLayout);
		
		instanceGranuleGridNearCameraLayout($sunRiggingLayout);

}

global proc attachToSunSurfaceLayout(string $parent)
{
string $attachToSunLayout = `frameLayout
		-l "Attach to Sun"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
		
		textFieldButtonGrp
			-ed true
			-label "Sun"
			-text  ""
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignSun"
			//-cc "updateReadyCreateStatus"
			getSun;
	
		text
			-l " Objects to Attach to Sun";
	
		textScrollList
			-w 80
			-h 60
			-ams true
			-dkc "removeSunAttachmentObject"
			//-p $sunAOLayout
			getSunAttachmentObjects;
		
		
		string $sunAOLayout = `rowLayout
			//-nch
			-p $attachToSunLayout
			-numberOfColumns 3			
			//-nch 3
			`;
		
			button
				-label "Assign Sun Attachments Objects"
				-ann ""
				//-w 120
				-command "assignSunAttachmentObjects"
				//-en false
				-p $sunAOLayout
				assignSunAttachmentObjects;
				
			button
				-label "Clear Attachment Object List"
				-ann ""
				//- w 120
				-command "clearAttachmentObjectList"
				//-en false
				-p $sunAOLayout
				clearAttachmentObjectList;
				
			button
				-label "Attach to Surface of Sun"
				-ann ""
				//-w 120
				-command "attachToSurfaceOfSun"
				//-en false
				-bgc 1.0 0.46 0.0
				-p $sunAOLayout
				attachToSurfaceOfSun;
}

global proc sunAnimationExpressionsLayout(string $parent)
{
string $layout = `frameLayout
		-l "Sun Animation Expressions"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
		
	button
		-label "Create Scale Y Proportional to Scale XZ Expression"
		-ann ""
		-command "createScaleYProportionalToScaleXZExpression"
		createScaleYProportionalToScaleXZExpression
		;
		
	setParent..;
}

global proc assignSun()
{
	string $sel[]=`ls -sl`;
	//string $sun = findObjOfType($sel, "fluid", "fluidShape");
	
	if(`size $sel`==0){
		error "Nothing is selected. Select the sun's surface.";
	} else {
		textFieldButtonGrp 
			-e
			-text $sel[0]
			getSun;
	}
	/*
	if($fluid == "null"){
		string $rel[] = `listRelatives -s $sel[0]`;
		print ("Relatives : " + "\n");
		print $rel;
		$fluid = findObjOfType($rel, "fluid", "fluidShape");
		if($fluid == "null"){
			textFieldButtonGrp 
			-e -text $sel[0]
			getFluid;
			updateReadyCreateStatus();
			print("Item selected is not a fluid." + "\n");
		} else {
			textFieldButtonGrp 
			-e -text $fluid
			getFluid;
			
			updateReadyCreateStatus();
			//print("Fluid Checked Out" + "\n");			
			
		}
	}
	*/
}

global proc assignSunAttachmentObjects()
{
	string $sel[]=`ls -sl`;	
	if(`size $sel`==0){
		error "Nothing is selected. Select some objects to place on the sun's surface.";
	} else {
		int $i;
		for($i = 0; $i<`size $sel`; $i++){
		textScrollList
			-e
			-append $sel[$i]
			getSunAttachmentObjects;
		}
		/*
		textFieldButtonGrp 
			-e
			-text $sel
			getSunAttachmentObjects;
			*/
		
	}
}

global proc clearAttachmentObjectList()
{
textScrollList
	-e
	-ra
	getSunAttachmentObjects;
}

global proc attachToSurfaceOfSun()
{
string $sun = `textFieldButtonGrp -q -text getSun`;
string $atObjs[] = `textScrollList -q -ai getSunAttachmentObjects`;
int $i;
for($i = 0; $i<`size $atObjs`;$i++){
	geometryConstraint -weight 1 $sun $atObjs[$i];
	normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $sun $atObjs[$i];
}

}

global proc removeSunAttachmentObject()
{
/*
	textScrollList
		-e
		-append $sel[$i]
		getSunAttachmentObjects;
		*/
}

global proc createSurfaceFlamesGridLayout(string $parent)
{
global string $SUN_sunGridShape;
global string $SUN_sunFlamesFluid;
//global string $SUN_sunFlamesFluids[];
global string $SUN_sunFlamesFluidSource;

	string $createSurfaceFlamesGridLayout = `frameLayout
		-l "Create Surface Flames Grid"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent		
		`;
		
					
		textFieldButtonGrp
			-ed true
			-label "Sun Grid Shape"
			-text $SUN_sunGridShape
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignSunGridShape"
			getSunGridShape;
			
		textFieldButtonGrp
			-ed true
			-label "Flames Fluid Source"
			-text  $SUN_sunFlamesFluidSource
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignFlamesFluidSource"
			getFlamesFluidSource;
		
		string $manualProcessSetupLayout = `frameLayout
			-l "Manual Setup"	
			-ann ""
			-bv true
			-la "center"
			-li 10
			-lv true
			-mw 10
			-mh 10		
			
			-cll true
			-cl true
			-parent $createSurfaceFlamesGridLayout		
			`;
		
			
		text
			-l "Notes: Fluids must have all Contents Methods set to Dynamic Grid."			
			;
			
			//___________________________________
		separator 
			-height 5 
			-style "single"
			-p $manualProcessSetupLayout
			;
			
		text
			-l "Step 1: Make new fluid objects with same attributes as source fluid."
			;
			
		intSliderGrp 
			-l "Number of Duplicate Flame Fluids" 
			-minValue 1		
			-maxValue 100
			-value 10 
			-fieldMinValue 1 
			-fieldMaxValue 10000000
			//-changeCommand "setPlaybackBy"
			-field true	
			-ann ""
			-cw3 300 50 90
			-p $manualProcessSetupLayout
			duplicateFlamesFluidSourceCount			
			;
		
		textFieldGrp
			-ed true
			-label "Duplicate Name"
			-text  "SunSurfaceFlamesFluidGridSourceDuplicate"
			-ann ""
			-p $manualProcessSetupLayout
			flamesFluidSourceDuplicateName
			;
			
		textFieldGrp
			-ed true
			-label "Duplicate Group Name"
			-text  "SunSurfaceFlamesFluidGridSourceDuplicateGroup"
			-ann ""
			-p $manualProcessSetupLayout
			flamesFluidSourceDuplicateGroupName
			;
			
		checkBoxGrp
			-ncb 1
			-l "Auto Connect All Fluid Attributes"
			-l1 "Connect"
			-v1 true			
			-p $manualProcessSetupLayout
			surfaceFlamesAutoConnectAllFluidAttributes			
			;
			
		button 
			-l "Duplicate Flames Fluid Source"
			-c ("sunDuplicateFlamesFluidSource();")
			-p $manualProcessSetupLayout
			;
			
		//___________________________________
		separator 
			-height 5 
			-style "single"
			//-bgc 0 0 0
			-p $manualProcessSetupLayout
			;
			
		text
			-l "Step 2: Attach source fluid's cache to fluid grid copies and randomize time."
			-p $manualProcessSetupLayout
			;
			
					
		button 
			-l "Attach Cache to Fluid Copies"
			-c ("sunAttachCacheToFluidCopies();")
			-p $manualProcessSetupLayout
			;
		
		floatSliderButtonGrp 
			-l "Randomize Cache Trax Clip" 
			-minValue 0.0001		
			-maxValue 1000
			-value 100 
			-fieldMinValue 0.0001 
			-fieldMaxValue 10000000
			-buttonLabel "Randomize"
			-buttonCommand "sunRandomizeCacheTraxClip"
			-field true	
			-ann ""
			-cw4 300 50 60 50
			-p $manualProcessSetupLayout
			sunRandomizeFlamesFluidCacheTraxClip			
			;
			
		//___________________________________
		separator 
			-height 5 
			-style "single"
			//-bgc 0 0 0
			-p $manualProcessSetupLayout
			;
			
		text
			-l "Step 3: Instance the fluids onto the sun's surface."
			-p $manualProcessSetupLayout
			;			
			
			/*	
			textFieldButtonGrp
				-ed true
				-label "Flames Fluid"
				-text  $SUN_sunFlamesFluid
				-ann ""
				-cal 1 "center"
				-buttonLabel "Select"
				-bc "assignFlamesFluid"
				getFlamesFluid;
			*/
		/*	
		textFieldGrp
			-ed true
			-label "Instanced Object Name"
			-text  ""
			-ann ""
			-p $manualProcessSetupLayout
			flamesFluidInstancedObjectName
			;
		*/	
			
		textFieldGrp
			-ed true
			-label "Instanced Object Group Name"
			-text  "SunSurfaceGridObjects"
			-ann ""
			-p $manualProcessSetupLayout
			flamesFluidInstancedObjectGroupName
			;
		
		text
			-l "Flames Fluid Objects."
			-p $manualProcessSetupLayout
			;
		
		textScrollList
			-h 90
			-ams true
			-dkc "removeSunFlamesFluidsObjects"
			-p $manualProcessSetupLayout
			getFlamesFluids			
			;
			
		string $ffoLayout = `rowLayout
			//-nch
			//-p $attachToSunLayout
			-numberOfColumns 2
			-p $manualProcessSetupLayout
			`;
			
			button 
				-l "Assign Flames Fluid Objects"
				-c ("assignFlamesFluids();")
				-p $ffoLayout
				;
				
			button 
				-l "Clear List"
				-c ("clearSunFlamesFluidsObjects();")
				-p $ffoLayout
				;
		
		checkBoxGrp
			-ncb 1
			-l "Duplicate Type"
			-l1 "Instance"
			-v1 true
			-vr
			-p $manualProcessSetupLayout
			surfaceFlamesGridDuplicateType			
			;
		
		/*
		checkBoxGrp
			-ncb 2
			-l "Alignment"
			-l1 "Normal Align"
			-l2 "Face Align"
			-v1 true
			-v2 true
			-vr
			surfaceFlamesGridAlignment
			-p $manualProcessSetupLayout
			;
		*/		
		button 
			-l "Duplicate On Faces"
			-c ("sunDuplicateOnSelectedFaces();")
			-p $manualProcessSetupLayout
			;
			
		button 
			-l "Create Sun Surface Flames"
			-c ("sunCreateSurfaceFlamesGridProcess();")
			-bgc 1.0 0.614 0.0
			-p $createSurfaceFlamesGridLayout
			;
			
		progressBar
			-min 0
			-max 100
			-p $createSurfaceFlamesGridLayout
			//-bgc 1.0 0.614 0.0
			//-vis false
			//-s 1
			duplicateOnFacesProgressBar			
			;
			
		/*	
		button  
			-l "Stop"
			-c ("stopSunDuplicateOnSelectedFaces();")
			;
		*/
}

global proc sunCreateSurfaceFlamesGridProcess()
{
//string $fluidDups[] = `textScrollList -q -ai getFlamesFluids`;
string $sunObj = `textFieldButtonGrp -q -text getSunGridShape`;
string $flame = `textFieldButtonGrp -q -text getFlamesFluidSource`;
if($sunObj == "" || $flame == ""){
	string $result=`confirmDialog -t "Warning!" -ma center
	-m ("You must have a <Flames Fluid Source> and a <Sun Grid Shape> before you can run this process!") 
	-b "OK" -db "OK" -cb "OK"`;
	if ($result=="OK"){
		return;		
	} 
}

print("*****************************************" + "\n");
print("***Creating Surface Flames on Sun Grid***" + "\n");
print("*****************************************" + "\n");
waitCursor -state on;
print(">>>>>Turning of fluid display, so system doesn't bog down...");
showOnlyBoundingBoxFluidDisplay();
print(" DONE!" + "\n");
print(">>>>>Creating fluid copies...");
sunDuplicateFlamesFluidSource();
print(" DONE!" + "\n");
print(">>>>>Attaching cache to fluid copies...");
sunAttachCacheToFluidCopies();
print(" DONE!" + "\n");
print(">>>>>Randomizing cache start times...");
sunRandomizeCacheTraxClip();
print(" DONE!" + "\n");
print(">>>>>Placing fluid instances on sun surface...");
sunDuplicateOnSelectedFaces();
print(" DONE!" + "\n");
waitCursor -state off;
print("*****************************************" + "\n");
print("PROCESS COMPLETE! ENJOY YOUR SUN!" + "\n");

}

global proc assignSunGridShape()
{
	string $sel[] = `ls -sl`;
	
	if(`size $sel` == 0){
		error "Nothing is selected. Select the Sun Surface Grid Shape.";
		return;
	}
	textFieldButtonGrp
		-edit
		-text  $sel[0]
		getSunGridShape;
		
	global string $SUN_sunGridShape;
	$SUN_sunGridShape = $sel[0];
	
}

global proc assignFlamesFluid()
{
	string $sel[] = `ls -sl`;
	
	if(`size $sel` == 0){
		error "Nothing is selected. Select the Flames Fluid Object.";
		return;
	}
	textFieldButtonGrp
		-edit
		-text  $sel[0]
		getFlamesFluid;
	
	
	global string $SUN_sunFlamesFluid;
	$SUN_sunFlamesFluid = $sel[0];

}

global proc assignFlamesFluidSource()
{
	string $sel[] = `ls -sl`;
	
	if(`size $sel` == 0){
		error "Nothing is selected. Select the Flames Fluid Object.";
		return;
	}
	textFieldButtonGrp
		-edit
		-text  $sel[0]
		getFlamesFluidSource;
	
	
	global string $SUN_sunFlamesFluidSource;
	$SUN_sunFlamesFluidSource = $sel[0];

}

global proc assignFlamesFluids()
{
	string $sel[] = `ls -sl`;
	//global string $SUN_sunFlamesFluids[];
	if(`size $sel` == 0){
		error "Nothing is selected. Select the Flames Fluids Objects.";
		return;
	}
	int $i;
	for($i=0;$i<`size $sel`;$i++){
		textScrollList
			-edit
			-append $sel[$i]
			getFlamesFluids;
		//$SUN_sunFlamesFluids[$i] = $sel[$i];
	}

}

global proc sunDuplicateFlamesFluidSource()
{
	string $flame = `textFieldButtonGrp -q -text getFlamesFluidSource`;
	float $scale[] = `xform -q -s $flame`;
	float $flamePivot[] = `xform -q -pivots $flame`;
	string $flameShape[] = `listRelatives -typ "fluidShape" $flame`;
	int $baseRes = `getAttr ($flameShape[0] + ".baseResolution")`;
	float $res[] = `getAttr ($flameShape[0] + ".resolution")`;
	float $dimensions[] = `getAttr ($flameShape[0] + ".dimensions")`;
	int $copyCount = `intSliderGrp -q -v duplicateFlamesFluidSourceCount`;
	string $flameCopies[];
	string $attrPresetName = "Temp";
	string $newAttrPresetName = `saveAttrPreset $flameShape[0] $attrPresetName false`;
	string $grpName = `textFieldGrp -q -text flamesFluidSourceDuplicateGroupName`;
	string $dupName = `textFieldGrp -q -text flamesFluidSourceDuplicateName`;
	string $grpFluids = `group -em -n $grpName`;
	string $newFluids[];
	
	
	int $i;
	for($i=0;$i<$copyCount;$i++){
		//$flameCopies[$i] = `duplicate $flame`;	
		//string $newFlame[] = `duplicate -rr $flame`;
		string $newFlame = `create3DFluid 10 10 10 10 10 10`;	
		//string $fShape = `listRelatives -typ "fluidShape" $newFlame`;
		
		//createTempFluidPresetAndApplyToFluid($flameShape[0], $newFlame);
		applyAttrPreset $newFlame $newAttrPresetName 1;
		setAttr ($newFlame + ".baseResolution") $baseRes;
		//setAttr ($newFlame + ".dimensions") $dimensions[0] $dimensions[1] $dimensions[2];
		//catch(`setAttr ($newFlame + ".resolution") $res[0] $res[1] $res[2]`);
		select -r $newFlame;
		
		rename ($dupName + "Shape" + $i);
		string $sel[] = `ls -sl`;
		string $rels[] = `listRelatives -p -typ "transform" $sel[0]`;
		select -r $rels[0];
		rename ($dupName + $i);	
		select -r ($dupName + $i);
		 
		string $ss[] = `ls -sl`;
		$newFluids[$i] = $ss[0];
		xform -pivots $flamePivot[0] $flamePivot[1] $flamePivot[2] $newFluids[$i];
		xform -a -s $scale[0] $scale[1] $scale[2] $newFluids[$i];
		
		//parent $ss[0] $grpFluids;	
		$newFlame = $sel[0];
		
		textScrollList
			-edit
			-append $newFlame
			getFlamesFluids;
		
	}
	
	int $conAttr = `checkBoxGrp -q -v1 surfaceFlamesAutoConnectAllFluidAttributes`;
	
	select -cl;
	
	if($conAttr == 1){
		select -add $flame;
	}
	for($i=0;$i<`size $newFluids`;$i++){
		if($conAttr == 1){
			select -add $newFluids[$i];
		}
		
	}
	
	if($conAttr == 1){
		connectAllFluidAttributes();	
	}
	
	string $endSelected[] = `ls -sl`;
	for($i=0;$i<`size $endSelected`;$i++){
		//print("Selected: " + $endSelected[$i] + "\n");
	}
	
	for($i=0;$i<`size $newFluids`;$i++){
		parent $newFluids[$i] $grpFluids;	
	}

}

// Face center of gravity info from http://jonhandhisdog.com/forum/index.php?showtopic=560. Thanks! :)

global proc sunDuplicateOnSelectedFaces()
{
	
	progressBar
		-e
		-pr 0
		duplicateOnFacesProgressBar
		;
		
	//$normAlign = `checkBoxGrp -q -v1 surfaceFlamesGridAlignment`;
	//$faceAlign = `checkBoxGrp -q -v2 surfaceFlamesGridAlignment`;
	$normAlign = true;
	$faceAlign = true;
	$dupType = `checkBoxGrp -q -v1 surfaceFlamesGridDuplicateType`;
	
	/*
	// List selected..
	$selected = `ls -sl`; // All selected
	$normSmooth = `ls -hilite`; // Selected Components Objects
	$dup = `ls -sl -tl 1`; // Last selected
	*/
	string $sunObj = `textFieldButtonGrp -q -text getSunGridShape`;
	select -r $sunObj;
	ConvertSelectionToFaces;
	$selected = `ls -sl`;
	//$dup = `textFieldButtonGrp -q -text getFlamesFluid`; //For single duplicate obj
	string $dups[] = `textScrollList -q -ai getFlamesFluids`; //For multiple duplicate objects
	
	$arrayVert = `filterExpand -sm 31 $selected`; // Filter selected verts as an array.
	$arrayEdge = `filterExpand -sm 32 $selected`; // Filter selected edges as an array.
	$arrayFace = `filterExpand -sm 34 $selected`; // Filter selected faces as an array.
	$arrayCVs = `filterExpand -sm 28 $selected`; // Filter selected CV's as an array.
	
	// Get size of arrays.
	int $vertSize = `size($arrayVert)`;
	int $edgeSize = `size($arrayEdge)`;
	int $faceSize = `size($arrayFace)`;
	int $CVsSize = `size($arrayCVs)`;
	
	int $selSize = `size($selected)`;
	
	waitCursor -state on; // Turn waitcursor on for duplication process
	
	// ON:FACE DUPLICATION
	if ($faceSize != 0)
	   {
	   string $grpName = `textFieldGrp -q -text flamesFluidInstancedObjectGroupName`;
	   $grpFace = `group -em -n $grpName`;
	   int $p;
	   for ($faceNum in $arrayFace)
	       {
		       float $ranDup = ceil(rand(0, (`size $dups` -1)));
		       int $ranDupInt = $ranDup;
		       //print("Ran: " + $ranDupInt + "\n");
			string $obj[];
			if($dupType == 1){
				//$obj = `instance $dup`;
				$obj = `instance $dups[$ranDupInt]`;
			} else {
				//$obj = `duplicate $dup`;
				$obj = `duplicate $dups[$ranDupInt]`;
		   }
		 //select $obj[0];
		   //rename ("SunSurfaceFlamesFluidGrid" + $p);
		   //$obj[0] = "SunSurfaceFlamesFluidGrid" + $p;
		   
	       float $avgFacePos[]= `xform -q -t -ws $faceNum`;
	
	       int $avgFacePosListSize = size($avgFacePos)/3;
	
	       float $fcX = 0;
	       float $fcY = 0;
	       float $fcZ = 0;
	
	       for ($i = 0; $i < $avgFacePosListSize; $i++)
		   {
		   $fcX = $fcX + $avgFacePos[$i * 3];
		   $fcY = $fcY + $avgFacePos[$i * 3 + 1];
		   $fcZ = $fcZ + $avgFacePos[$i * 3 + 2];
		   }
	
	       $fcX = $fcX / $avgFacePosListSize;
	       $fcY = $fcY / $avgFacePosListSize;
	       $fcZ = $fcZ / $avgFacePosListSize;
	
	       move -rpr $fcX $fcY $fcZ $obj;
			
		   if($normAlign){
				normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "scene" $faceNum $obj[0];
				delete -constraints $obj[0];
	
	       }
		   
		   if($faceAlign){
		   //string $faceVerts[] = `polyInfo -faceToVertex ($selected[0] + ".f[$faceNum]")`;
	       string $faceVerts[] = `polyInfo -faceToVertex $faceNum`;
		   
			//Tokenize the faceVerts string so we have usefull numbers to work with.
			string $tokens[];
			tokenize $faceVerts[0] " :\n\r" $tokens;
			// Result: 6 //
	
			int $vertexOrder[];
			clear $vertexOrder;
			int $t;
	
			for ( $t = 2; $t < `size $tokens`; $t++ )
			{
			  $vertexOrder[`size $vertexOrder`] = $tokens[$t];
			};
				   
			//Get the dir of each vert to vert, then get the vector of that dir
	       //Get the smallest angle - that the angle we want to point in
	       //Get the direction from the center or the face to the vert that has the smallest angle.         
		   
		   //select -r ($sunObj + ".vtx[" + $vertexOrder[0] + "]");
		   float $vertPos[] = `xform -ws -q -t ($sunObj + ".vtx[" + $vertexOrder[0] + "]")`;
		   string $vertLoc[] = `spaceLocator -a -p $vertPos[0] $vertPos[1] $vertPos[2]`;
		   xform -cp $vertLoc[0];	  
		   
		   string $faceNorm[] = `polyInfo -fn $faceNum`;
		   //float $normDir[] = getFaceNormalDirection($faceNum, $sunObj);
		   //print("NormDir: " + $normDir[0] + ", " + $normDir[1] + ", " + $normDir[2] + ", " + "\n");
		   vector $normVect = translatePolyInfoNormal($faceNorm[0]);
		   float $nv[3] = {$normVect.x,$normVect.y,$normVect.z};
		   //print("NormVect: " + $normVect.x + ", " + $normVect.y + ", " + $normVect.z + ", " + "\n");	   
		   
		   cycleCheck -e off;
		   
		   aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector $nv[0] $nv[1] $nv[2]  $vertLoc[0] $obj[0];
			delete -constraints $obj[0];
			delete $vertLoc[0];
		  
			}		
		   parent $obj[0] $grpFace;
		   select -cl;
		   
		   progressBar
				-e
				-max $faceSize				
				-s 1
				//-vis true
				duplicateOnFacesProgressBar
				;
			$p++;
	       }
		$SUN_stopSunDuplicateProc = 0;   
	   print ("Duplicated " + $faceSize + " objects on faces... ");
	   }
	// OFF:FACE DUPLICATION
	
	waitCursor -state off;
	
	progressBar
		-e
		-pr 0
		duplicateOnFacesProgressBar
		;
		
	select -cl;

}

global proc vector translatePolyInfoNormal( string $pin )
{
	  vector $normal;
	  float $x;
	  float $y;
	  float $z;
	
	  string $tokens[];
	  int $numTokens = `tokenize $pin " " $tokens`;
	
	  // Make sure we're looking at polyInfo data:
	  if ( ( $numTokens > 3 ) && ( $tokens[0] == "FACE_NORMAL" ) )
	  {
	    // Maya performs data-type conversion here.
	    $x = ($tokens[$numTokens-3]);
	    $y = ($tokens[$numTokens-2]);
	    $z = ($tokens[$numTokens-1]);
	
	    $normal = << $x, $y, $z >>;
	
	    // Normalize it.
	    $normal = `unit $normal`;
	  }
	
	  // Return it.
	  return $normal;
}
	
global proc sunRandomizeCacheTraxClip()
{
	string $fluids[] = `textScrollList -q -ai getFlamesFluids`;
	float $ranAmount = `floatSliderButtonGrp -q -v sunRandomizeFlamesFluidCacheTraxClip`;
	
	int $i;
	for($i=0;$i<`size $fluids`;$i++){
		//string $fShape[] = `listRelatives -type "fluidShape" $fluids[$i]`;
		//string $cacheNode[] = `listConnections -t cacheFile $fluids[$i]`;
		string $cacheNode[] = getAllCachesConnectedToObj($fluids[$i]);
		if(`size $cacheNode` == 0){
			return;
		}
		float $startFrame = `getAttr ($cacheNode[0] + ".startFrame")`;
		float $ran = rand(($startFrame - $ranAmount), $startFrame);
		setAttr ($cacheNode[0] + ".startFrame") $ran;
		
	}

}

global proc string[] getAllCachesConnectedToObj(string $obj)
{
	
	string $cacheFileNode[];
	
	string $cacheNode[] = `listConnections -t cacheFile $obj`;
	appendStringArray($cacheFileNode, $cacheNode, 1);	
	if(`size $cacheFileNode` == 0){
		string $cacheBlend[] = `listConnections -t cacheBlend $obj`;
		if(`size $cacheBlend` > 0){
			for($p=0;$p<`size $cacheBlend`;$p++){
				$cacheNode = `listConnections -t cacheFile $cacheBlend[$p]`;
				appendStringArray($cacheFileNode, $cacheNode, `size $cacheNode`);
			}
			return $cacheFileNode;
		} else {
			print("No Cache File Found on " + $obj + ".\n");
		}
	}else {	
		return $cacheFileNode;
	}
}

global proc removeSunFlamesFluidsObjects()
{
	string $sel[] = `textScrollList -q -si getFlamesFluids`;
	int $i;
	for($i=0;$i<`size $sel`;$i++){
		textScrollList
			-edit
			-ri $sel[$i]
			getFlamesFluids
			;
	}

}

global proc clearSunFlamesFluidsObjects()
{
textScrollList
	-e
	-ra
	getFlamesFluids;
}

global proc sunAttachCacheToFluidCopies()
{
	string $fluid = `textFieldButtonGrp -q -text getFlamesFluidSource`;	
	string $fluidShape[] = `listRelatives -typ "fluidShape" $fluid`;
	//string $cacheFile[] = `listConnections -t cacheFile $fluidShape[0]`;
	string $cacheFile[] = getAllCachesConnectedToObj($fluidShape[0]);
	//print("CacheFiles: " + "\n");
	//print $cacheFile;
	
	
	string $fluidDups[] = `textScrollList -q -ai getFlamesFluids`;
	int $i;
	int $p;
	
	for($i=0;$i<`size $fluidDups`;$i++){
		for($p=0;$p<`size $cacheFile`;$p++){
			string $newCacheFile[];
			print("CacheFile: " + $cacheFile[$p] + "\n");
			if(catch(`duplicate $cacheFile[$p]`)){			
				continue;
			} else {
				$newCacheFile = `duplicate $cacheFile[$p]`;
				connectCacheFileToFluidAttributes($newCacheFile[0], $fluidDups[$i]);
			}
		}		
	}
	if(`size $cacheFile` == 0){
		print("There is no cacheFile on the Flames Fluid Source fluid. Skipping cacheFile." + "\n");
		return;
	}
}

global proc connectCacheFileToFluidAttributes(string $sourceCache, string $targetFluid)
{
	//if(attributeExists (inRange, $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".inRange") ($targetFluid + ".playFromCache");
		//}
		//if(attributeExists ("outCacheData.outCacheData[0]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[0]") ($targetFluid + ".inDensity");
		//}
		//if(attributeExists ("outCacheData.outCacheData[1]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[1]") ($targetFluid + ".inVelocity");
		//}
		//if(attributeExists ("outCacheData.outCacheData[2]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[2]") ($targetFluid + ".inTemperature");
		//}
		//if(attributeExists ("outCacheData.outCacheData[3]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[3]") ($targetFluid + ".inReaction");
		//}
		//if(attributeExists ("outCacheData.outCacheData[4]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[4]") ($targetFluid + ".inColor");
		//}
		//if(attributeExists ("outCacheData.outCacheData[5]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[5]") ($targetFluid + ".inFalloff");
		//}
		//if(attributeExists ("outCacheData.outCacheData[6]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[6]") ($targetFluid + ".inResolution");
		//}
		//if(attributeExists ("outCacheData.outCacheData[7]", $newCacheFile[0]) == 1){
			connectAttr -f ($sourceCache + ".outCacheData[7]") ($targetFluid + ".inOffset");
		//}
		connectAttr -f time1.outTime ($sourceCache + ".time");	
}

//__________________________________________________________________________________________
//__________________________________________________________________________________________

global proc placeRandomlyOnSunSurfaceLayout(string $parent)
{
	global string $SUNRAN_surface;
	global string $SUNRAN_obj;
	global string $SUNRAN_refTransform;
	global int $SUNRAN_dupTypeCopy;
	global int $SUNRAN_dupTypeInstance;
	global int $SUNRAN_dupTypeRefDup;
	
	string $placeRandomlyOnSunSurfaceLayout = `frameLayout
		-l "Populator"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent		
		`;		
					
		textFieldButtonGrp
			-ed true
			-label "Object To Place On Sun"
			-text $SUNRAN_obj
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignObjectToPlaceOnSun"
			getObjectToPlaceOnSun
			;
			
		//Multiple Objects
		text
			-l "Objects To Place On Sun"
			;
		
		textScrollList
			-w 80
			-h 90
			-ams true
			-dkc "removeObjectToPlaceOnSun"
			getObjectsToPlaceOnSun
			;
			
		rowLayout
			-numberOfColumns 2
			;	
			button
				-label "Select Object(s)"
				-command "assignObjectsToPlaceOnSun"
				;
			button
				-label "Clear List"
				-command "clearObjectsToPlaceOnSun"
				;
		setParent..;
		
			
		textFieldButtonGrp
			-ed true
			-label "Sun Surface"
			-text  $SUNRAN_surface
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignSunSurfaceObject"
			getSunSurfaceObject
			;
			
		string $manualProcessSetupLayout = `frameLayout
			-l "Process Setup"	
			-ann ""
			-bv true
			-la "center"
			-li 10
			-lv true
			-mw 10
			-mh 10		
			
			-cll true
			-cl true
			-parent $placeRandomlyOnSunSurfaceLayout		
			`;
									
			optionMenuGrp -l "Duplicate Type"
				placeRandomObjectOnSurfaceDuplicteType;
					menuItem -label "copy" -c "setGlobalDupTypeVar";
					menuItem -label "instance" -c "setGlobalDupTypeVar";
					menuItem -label "referenceCopy" -c "setGlobalDupTypeVar";				
							
			checkBox
				-l "Randomize Cache Clips"
				-v true
				randomSurfaceObjectDuplicationDoRandomizeTraxClips
				;
				
			checkBox
				-l "Randomize Animation Clips"
				-v true
				randomSurfaceObjectDuplicationDoRandomizeAnimationClips
				;
				
			checkBox
				-l "Group Duplicates"
				-v true
				randomSurfaceObjectDuplicationGroupingOption
				;			
				
			checkBox
				-l "Move Original To Center"
				-v false
				randomSurfaceObjectDuplicationCenteringOption
				;
				
			checkBox
				-l "Align Objects To Surface Faces"
				-v false
				randomSurfaceObjectAlignToSurfaceFacesOption
				;
				
			string $referenceDuplicationProcessSetupLayout = `frameLayout
				-l "Referenece Duplication Options"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $manualProcessSetupLayout		
				`;
				
				textFieldButtonGrp
					-ed true
					-label "Specify Transform"
					-text  $SUNRAN_refTransform
					-ann ""
					-cal 1 "center"
					-buttonLabel "Select"
					-bc "assignReferenceCopyTransform"
					getReferenceCopyTransform
					;
					
				textFieldButtonGrp
					-ed true
					-label "Reference Object"
					-text  ""
					-ann ""
					-cal 1 "center"
					-buttonLabel "Select"
					-bc "selectReferenceObjectToDuplicate"
					selectReferenceObjectToDuplicate
					;
				
				intSliderGrp
					-l "Duplicate Reference Object" 
					-minValue 1		
					-maxValue 100
					-value 10
					-fieldMinValue 1 
					-fieldMaxValue 10000000	
					-field true
					-ann ""
					sunDuplicateSelectedReferenceObjectCount				
					;
					
				button 
					-l "Duplicate Reference Object"
					-c "sunDuplicateSelectedReferenceObject"
					;
			
			string $fluidDuplicationProcessSetupLayout = `frameLayout
				-l "Fluid Duplication Process"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $manualProcessSetupLayout		
				`;
				
				checkBox
					-l "Do Fluid Instancing Duplication Process"
					-v false
					randomSurfaceObjectDuplicationDoFluidDuplication
					;
					
			string $fluidSourceDuplicationProcessSetupLayout = `frameLayout
				-l "Fluid Source Duplication"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $fluidDuplicationProcessSetupLayout		
				`;
				
				text
					-l "Notes: Fluids must have all Contents Methods set to Dynamic Grid."			
					;
				
				text
					-l "Step 1: Duplicate the Fluid's Source First."
					;							
						
				intSliderGrp 
					-l "Number of Duplicate Source Objects" 
					-minValue 1		
					-maxValue 100
					-value 10 
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-field true	
					-ann ""
					-cw3 300 50 90
					duplicateRandomSurfaceObjectSourceCount			
					;
					
				textFieldGrp
					-ed true
					-label "Duplicate Name"
					-text  "SunSurfaceRandomPlacementSourceDuplicate"
					-ann ""
					-cw2 150 300
					randomSurfaceObjectSourceDuplicateName
					;
				
				textFieldGrp
					-ed true
					-label "Duplicate Group Name"
					-text  "SunSurfaceRandomPlacementSourceDuplicateGroup"
					-ann ""
					-cw2 150 300
					randomSurfaceObjectSourceDuplicateGroupName
					;
					
				checkBoxGrp
					-ncb 1
					-l "Auto Connect All Fluid Attributes"
					-l1 "Connect"
					-v1 true			
					randomSurfaceObjectAutoConnectAllFluidAttributes			
					;
					
				button 
					-l "Duplicate Random Surface Object Source"
					-c ("sunDuplicateRandomSurfaceObjectSource();")
					;
					
				setParent..;
				
			//___________________________________
			string $randomizeTraxClipSetupLayout = `frameLayout
				-l "Randomize Trax Clips"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $fluidDuplicationProcessSetupLayout		
				`;
				
				text
					-l "Step 2: Attach source fluid's cache to fluid grid copies and randomize time."	
					;
																			
				button 
					-l "Attach Cache to Fluid Copies"
					-c ("sunAttachCacheToRandomSurfaceObjectsFluidCopies();") 
					;
				
				floatSliderButtonGrp 
					-l "Randomize Cache Start Times" 
					-minValue 1		
					-maxValue 1000
					-value 100 
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectCacheTraxClip"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					randomSurfaceObjectFluidCacheTraxClip				
					;
					
				setParent..;
				
			//___________________________________
			string $instanceObjectsSetupLayout = `frameLayout
				-l "Instanced Objects Setup"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $fluidDuplicationProcessSetupLayout		
				`;
				
				text
					-l "Step 3: Instance the fluid duplicates onto the sun's surface."
					;
				
				checkBox
					-l "Create Volume Primitive Instances"
					-v true			
					randomSurfaceObjectCreateFluidVolumePrimitives			
					;
					
				textFieldGrp
					-ed true
					-label "Instanced Object Group Name"
					-text  "SunSurfaceObjects"
					-ann ""
					randomPlacementInstancedObjectGroupName
					;
			
				text
					-l "Randomly Placed Objects."
					;
				
				textScrollList
					-h 90
					-ams true
					-dkc "removeRandomlyPlacedFluidsObjects" 
					getRandomlyPlacedFluidObjects			
					;
					
				setParent..;
				
				string $ffoLayout = `rowLayout
					-numberOfColumns 2
					-p $instanceObjectsSetupLayout
					`;
				
					button 
						-l "Assign Randomly Placed Objects"
						-c ("assignRandomlyPlacedFluids();")
						;
						
					button 
						-l "Clear List"
						-c ("clearRandomlyPlacedFluidsObjects();")
						;
						
					setParent..;
					
				checkBoxGrp
					-ncb 1
					-l "Duplicate Type"
					-l1 "Instance"
					-v1 true
					-vr
					-p $instanceObjectsSetupLayout
					randomlyPlaceObjectDuplicateType			
					;
			//_____________________________________			
			
		string $randomazationSettingsLayout = `frameLayout
			-l "Randomazation Settings"	
			-ann ""
			-bv true
			-la "center"
			-li 10
			-lv true
			-mw 10
			-mh 10		
			
			-cll true
			-cl true
			-parent $manualProcessSetupLayout		
			`;
			
			checkBoxGrp
				-ncb 2
				-l "Constraint Options"
				-l1 "Geometry Constraint"
				-l2 "Normal Constraint"
				-v1 true
				-v2 true
				-vr
				-p $randomazationSettingsLayout
				randomlyPlaceObjectConstraintOptions			
				;
				
			floatSliderButtonGrp 
					-l "Randomize All Translate, Rotate, and Scale Settings" 
					-minValue 1		
					-maxValue 500
					-value 100 
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectRandomizeAllSettings"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					-p $randomazationSettingsLayout
					randomSurfaceObjectRandomizeAllSettings				
					;
		
			string $randomTranslationgSettingsLayout = `frameLayout
				-l "Random Translation Settings"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $randomazationSettingsLayout		
				`;
				
				rowLayout -nc 3 -cw3 70 70 70;
					floatField -w 70 -v 50 randomTranslationX;
					floatField -w 70 -v 50 randomTranslationY;
					floatField -w 70 -v 50 randomTranslationZ;
				setParent..;
				
				floatSliderButtonGrp 
					-l "Randomize Settings" 
					-minValue 1		
					-maxValue 100
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-value 100 
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectRandomizeTransformSettings"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					-p $randomTranslationgSettingsLayout
					randomSurfaceObjectRandomizeTransformSettings				
					;
					
				
			
			string $randomRotationSettingsLayout = `frameLayout
				-l "Random Rotation Settings"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $randomazationSettingsLayout		
				`;
				
				checkBox 
					-align left
					-l "Use Vertex Normal as orientation"
					-v false
					orientBox
					;
					
				text -align left -l "      (Override rotation settings)";
	
				text "Min Rotation (0 - 360): ";
				rowLayout -nc 3 -cw3 70 70 70;
					floatField -w 70 -max 360 minRotationX;
					floatField -w 70 -max 360 minRotationY;
					floatField -w 70 -max 360 minRotationZ;
				setParent..;
				text "Max Rotation (0 - 360): ";
				rowLayout -nc 3 -cw3 70 70 70;
					floatField -w 70 -max 360 maxRotationX;
					floatField -w 70 -max 360 -v 360 maxRotationY;
					floatField -w 70 -max 360 maxRotationZ;
				setParent..;
				rowLayout -nc 3 -cw3 70 70 70;
					checkBox -l "Invert X" invertXBox;
					checkBox -l "Invert Y" invertYBox;
					checkBox -l "Invert Z" invertZBox;
				setParent..;	
				floatSliderButtonGrp 
					-l "Randomize Settings" 
					-minValue 1		
					-maxValue 360
					-value 180 
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectRandomizeRotationSettings"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					-p $randomRotationSettingsLayout
					randomSurfaceObjectRandomizeRotationSettings				
					;		
				
			string $randomScaleSettingsLayout = `frameLayout
				-l "Random Scale Settings"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $randomazationSettingsLayout		
				`;
				
				checkBox 
					-align left
					-l "Scale Uniformly"
					-v true
					randomScaleUniformlySetting
					;
				
				text "Min Scale: ";
				rowLayout -nc 3 -cw3 70 70 70;
					floatField -w 70 -v 1 minScaleX;
					floatField -w 70 -v 1 minScaleY;
					floatField -w 70 -v 1 minScaleZ;
				setParent..;
				text "Max Scale: ";
				rowLayout -nc 3 -cw3 70 70 70;
					floatField -w 70 -v 1 maxScaleX;
					floatField -w 70 -v 1 maxScaleY;
					floatField -w 70 -v 1 maxScaleZ;
				setParent..;	
				
				floatSliderButtonGrp 
					-l "Randomize Settings" 
					-minValue 1		
					-maxValue 100
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-value 100 
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectRandomizeScaleSettings"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					-p $randomScaleSettingsLayout
					randomSurfaceObjectRandomizeScaleSettings				
					;
									
			string $randomTraxClipSettingsLayout = `frameLayout
				-l "Random Animation Clips Settings"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl true
				-parent $randomazationSettingsLayout		
				`;
				
			floatSliderButtonGrp 
					-l "Randomize Cache Trax Clip" 
					-minValue 1		
					-maxValue 1000
					-value 100 
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-buttonLabel "Randomize"
					-buttonCommand "sunRandomizeRandomSurfaceObjectCacheTraxClip"
					-field true	
					-ann ""
					-cw4 300 50 60 50
					randomSurfaceObjectCacheTraxClip				
					;
					
				setParent..;
			
			string $numberOfDuplicatesSettingsLayout = `frameLayout
				-l "Number of Duplicate Settings"	
				-ann ""
				-bv true
				-la "center"
				-li 10
				-lv true
				-mw 10
				-mh 10		
				
				-cll true
				-cl false
				-parent $randomazationSettingsLayout		
				`;
	
				intSliderGrp 
					-l "Number of Duplicates" 
					-minValue 1		
					-maxValue 100
					-value 10 
					-fieldMinValue 1 
					-fieldMaxValue 10000000
					-field true	
					-ann ""
					-cw3 300 50 90
					-p $numberOfDuplicatesSettingsLayout
					duplicateObjectsOnSurfaceCount			
					;
				
				textFieldGrp
					-l "Sun Objects Groupt Name"
					-text "SunObjectsGrp"
					-p $numberOfDuplicatesSettingsLayout
					randomlyPlaceSurfaceObjectsGroupName
					;				
				
				button 
					-l "Place Objects Randomly On Sun Surface"
					-c ("placeRandomlyOnSurface();")
					-p $randomazationSettingsLayout
					;					
					
			randomizeAttributesLayout($manualProcessSetupLayout);		
			
				
		//_______________________________________
		
		button 
			-l "Place Objects Randomly On Sun Surface"
			-c ("placeFluidObjectsRandomlyOnSunSurface();")
			-bgc 1.0 0.614 0.0
			-p $placeRandomlyOnSunSurfaceLayout
			;
			
		progressBar
			-min 0
			-max 100
			-p $placeRandomlyOnSunSurfaceLayout
			placeObjectRandomlyOnSunSurfaceProgressBar			
			;
}


global proc randomizeAttributesLayout(string $parent)
{
	string $randomizeObjectAttributesLayout = `frameLayout
		-l "Randomize Attributes"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-parent $parent		
		`;	

	text
		-l "Objects"
		;
		
	textScrollList
		-w 80
		-h 90
		-ams true
		-dkc "removeRandomAttributesObjects"
		getRandomAttributesObjects
		;
		
	rowLayout
		-numberOfColumns 2
		-p $randomizeObjectAttributesLayout
		;	
		button
			-label "Select Object(s)"
			-command ("assignRandomAttributesObjects " + $randomizeObjectAttributesLayout)
			;
		button
			-label "Clear List"
			-command "clearRandomAttributesObjectsList"
			;
		setParent..;
	
	text
		-l "Attributes"
		;
		
	textScrollList
		-w 80
		-h 90
		-ams true
		//-sc "generateAnimationExpressionNames"
		attributesToRandomize
		;
		
	rowLayout
		-numberOfColumns 2
		-p $randomizeObjectAttributesLayout
		;
		
		button
			-label "Sort List"
			-command "sortRandomObjectAttributesList"
			;				
	setParent..;
	
	rowLayout
		-numberOfColumns 2
		-p $randomizeObjectAttributesLayout
		;
		
		floatFieldGrp						
			-nf 2
			-l "Random Range"
			-v1 -1000
			-v2 1000
			randomObjectsAttributesRandomRange
			;
			
		setParent..;
			
	button 
		-l "Randomize Attributes"
		-c "randomizeObjectAttributesInList"
		-p $randomizeObjectAttributesLayout
		;
}

global proc placeFluidObjectsRandomlyOnSunSurface()
{
	string $sunObj = `textFieldButtonGrp -q -text getSunSurfaceObject`;
	string $obj = `textFieldButtonGrp -q -text getObjectToPlaceOnSun`;
	string $copy[];
	$doFluidDuplication = `checkBox -q -v randomSurfaceObjectDuplicationDoFluidDuplication`;
	$doRandomizeTraxClips = `checkBox -q -v randomSurfaceObjectDuplicationDoRandomizeTraxClips`;
	$alignToSurfaceFaces = `checkBox -q -v randomSurfaceObjectAlignToSurfaceFacesOption`;
	$createVolumePrimitives = `checkBox -q -v randomSurfaceObjectCreateFluidVolumePrimitives`;
	
	string $sourceObjs[] = `textScrollList -q -ai getObjectsToPlaceOnSun`;
	
	string $ranObj[] = `textScrollList -q -ai getRandomAttributesObjects`;
	$doRandomizeObjAttr = false;
	if(`size $ranObj` > 0 || $ranObj[0] != ""){
		$doRandomizeObjAttr = true;
	}
	
	if($sunObj == ""){
		string $result=`confirmDialog -t "Warning!" -ma center
		-m ("You must have an <Object To Place On Sun> and a <Sun Surface> before you can run this process!") 
		-b "OK" -db "OK" -cb "OK"`;
		if ($result=="OK"){
			return;		
		} 
	}
	
	print("*********************************************" + "\n");
	print("***Creating Randomly Placed Objects On Sun***" + "\n");
	print("*********************************************" + "\n");
	waitCursor -state on;
	print(">>>>>Turning off fluid display, so system doesn't bog down...");
	cycleCheck -e off;
	hideFluidsInModelEditor();
	print(" DONE!" + "\n");
	
	int $i;
	for($i=0;$i<`size $sourceObjs`;$i++){
		if(`size $sourceObjs` > 0){
			textFieldButtonGrp
				-edit
				-text $sourceObjs[$i]
				getObjectToPlaceOnSun
				;
		}
		
		if($doFluidDuplication){
			print(">>>>>Creating fluid copies...");
			sunDuplicateRandomSurfaceObjectSource();
			if($createVolumePrimitives){
				sunDuplicateRandomSurfaceObjectCreateFluidVolumePrimitives();
			}
			print(" DONE!" + "\n");
		}
		if($doRandomizeTraxClips && $doFluidDuplication){
			print(">>>>>Attaching cache to fluid copies...");
			sunAttachCacheToRandomSurfaceObjectsFluidCopies();
			print(" DONE!" + "\n");
			print(">>>>>Randomizing cache start times...");
			sunRandomizeRandomSurfaceObjectCacheTraxClip($copy);
			print(" DONE!" + "\n");
		}
		print(">>>>>Placing object copies on sun surface...");
		if($alignToSurfaceFaces){
			$copy = sunDuplicateOnSurfaceFaces();
		}else{
			$copy = placeRandomlyOnSurface();
		}
		print(" DONE!" + "\n");
		if($doRandomizeTraxClips && !$doFluidDuplication){
			print(">>>>>Randomizing Cache Start Times...");
			sunRandomizeRandomSurfaceObjectCacheTraxClip($copy);
			getAnimationClipsAndRandomizeStartTimes($copy);
			print(" DONE!" + "\n");
		}
		if($doRandomizeObjAttr){
			print(">>>>>Randomizing Object Attributes...");
			sunRandomizeObjectAttributes($copy);
			print(" DONE!" + "\n");
		}
	}
	
	showOnlyBoundingBoxFluidDisplay();
	showFluidsInModelEditor();
	waitCursor -state off;
	print("*****************************************" + "\n");
	print("PROCESS COMPLETE! ENJOY YOUR SUN!" + "\n");

}


global proc string[] placeRandomlyOnSurface()
{
	
	progressBar -e -pr 0 placeObjectRandomlyOnSunSurfaceProgressBar;
	string $dupType = `optionMenuGrp -q -v placeRandomObjectOnSurfaceDuplicteType`;
	string $refTransf = `textFieldButtonGrp -q -text getReferenceCopyTransform`;
	$doGrouping = `checkBox -q -v randomSurfaceObjectDuplicationGroupingOption`;
	$doCentering = `checkBox -q -v randomSurfaceObjectDuplicationCenteringOption`;
	$createGeometryConstraints = `checkBoxGrp -q -v1 randomlyPlaceObjectConstraintOptions`;
	$createNormalConstraints = `checkBoxGrp -q -v2 randomlyPlaceObjectConstraintOptions`;
	$scaleUniformly = `checkBox -q -v randomScaleUniformlySetting`;
	string $filePath = "";
	string $objs[];
	$objs[0] = `textFieldButtonGrp -q -tx getObjectToPlaceOnSun`;
	string $sourceObjs[] = `textScrollList -q -ai getObjectsToPlaceOnSun`;
	$sourceObj = $objs[0];
	if($dupType == "referenceCopy"){
		$filePath = `referenceQuery -f $objs[0]`;
		print("Referencing File: " + $filePath + "\n");
	}
	float $vertexPos[];
	string $surface = `textFieldButtonGrp -q -tx getSunSurfaceObject`;
	int $vtxCount[] = `polyEvaluate -v $surface`;
	string $objPos[];
	string $objOrient[] = {""};
	string $finalCmd;
	int $random = 0;
	int $duplicate = `intSliderGrp -q -v duplicateObjectsOnSurfaceCount`;
	string $objName[];
	string $groupName = "";
	
	float $displacementX = `floatField -q -v randomTranslationX`;
	float $displacementY = `floatField -q -v randomTranslationY`;
	float $displacementZ = `floatField -q -v randomTranslationZ`;
	
	float $minScaleX = `floatField -q -v minScaleX`;
	float $minScaleY = `floatField -q -v minScaleY`;
	float $minScaleZ = `floatField -q -v minScaleZ`;
	
	float $maxScaleX = `floatField -q -v maxScaleX`;
	float $maxScaleY = `floatField -q -v maxScaleY`;
	float $maxScaleZ = `floatField -q -v maxScaleZ`;
	
	float $pivPos[];
	
	int $orientState = `checkBox -q -v orientBox`;
	
	float $minRotationX = `floatField -q -v minRotationX`;
	float $minRotationY = `floatField -q -v minRotationY`;
	float $minRotationZ = `floatField -q -v minRotationZ`;
	
	float $maxRotationX = `floatField -q -v maxRotationX`;
	float $maxRotationY = `floatField -q -v maxRotationY`;
	float $maxRotationZ = `floatField -q -v maxRotationZ`;
	
	int $invertX = `checkBox -q -v invertXBox`;
	int $invertY = `checkBox -q -v invertYBox`;
	int $invertZ = `checkBox -q -v invertZBox`;
	
	float $rotAngle[] = {};
	float $vertexNormal[] = {};
	
	if ($invertX == 1){
		$invertX = -1;
	}
			
	if ($invertY == 1){
		$invertY = -1;
	}
			
	if ($invertZ == 1){
		$invertZ = -1;
	}
		
	if ($invertX == 0){
		$invertX = 1;
	}
	
	if ($invertY == 0){
		$invertY = 1;
	}
	
	if ($invertZ == 0){
		$invertZ = 1;
	}
		
	if($doCentering){
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 2 -jointOrient $objs[0];
		$pivPos = `xform -q -piv $objs[0]`;
		move -r (0-$pivPos[3]) (0-$pivPos[4]) (0-$pivPos[5]) $objs[0];
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 2 -jointOrient $objs[0];
	}
	
	
	float $progress = ($duplicate + $vtxCount[0] + (`size $objs`));
	string $objList[];
	for ($i = 0; $i < $duplicate; $i++){
		if($dupType == "referenceCopy"){
			string $refSn = `referenceQuery -f -shn $sourceObj`;
			string $buffer[];
			tokenize $refSn "." $buffer;
			string $namespace = $buffer[0];
			//string $namespace = basename( $refSn, ".mb");
			//print ("RefName: " + $refSn + " Namespace: " + $namespace + "\n");
			string $newRefFile = `file -r -gl -loadReferenceDepth "all" -namespace $namespace -options "v=0" $filePath`;
			file -sa $newRefFile;
			if($refTransf == ""){
				$objName = `ls -hd 1 -sl`;
			} else {
				string $topRefObj[] = `ls -hd 1 -sl`;
				$objList[$i] = $topRefObj[0];
				string $sel[] = `ls -sl`;
				int $s;
				for($s=0;$s<`size $sel`;$s++){
					string $matchSel = stripOutNumbersFromString($sel[$s]);
					string $matchRef = stripOutNumbersFromString($refTransf);
					if($matchSel == $matchRef){
						$objName[0] = $sel[$s];					
					}
				}
			}
			$objs[$i] = $objName[0];
			//print("Transforming : " + $objs[$i] + " To Objects Surface: " + $surface + "\n");
		} else if($dupType == "copy"){
			$objName = `duplicate -rr $objs[0]`;
			$objs[$i] = $objName[0];
		} else if($dupType == "instance"){
			$objName = `instance $sourceObj`;
			$objs[$i] = $objName[0];
		}
		progressBar -e -max $progress -s 1 placeObjectRandomlyOnSunSurfaceProgressBar;
	} 
	
	if($createGeometryConstraints || $createNormalConstraints){
		for($i=0;$i<`size $objs`;$i++){
			if($createGeometryConstraints){
				geometryConstraint -weight 1 $surface $objs[$i];
			}
			if($createNormalConstraints){
				normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $surface $objs[$i];
			}
		}
	}
	
	for ($i = 0; $i < $vtxCount[0]; $i++)
	{
		$vertexPos = `xform -q -ws -t ($surface+".vtx["+$i+"]")`;
		$vertexNormal = `polyNormalPerVertex -q -xyz ($surface+".vtx["+$i+"]")`;
		$rotAngle =`angleBetween -euler -v1 0.0 1.0 0.0 -v2 $vertexNormal[0] $vertexNormal[1] $vertexNormal[2]`;
		
		int $rotAngleClearX = $rotAngle[0];
		int $rotAngleClearY = $rotAngle[1];
		int $rotAngleClearZ = $rotAngle[2];
		
		$objOrient[$i] = $rotAngleClearX+" "+$rotAngleClearY+" "+$rotAngleClearZ;
		$objPos[$i] = "("+$vertexPos[0]+") ("+$vertexPos[1]+") ("+$vertexPos[2]+")";
		progressBar -e -max $progress -s 1 placeObjectRandomlyOnSunSurfaceProgressBar;
	}
	
	for ($i = 0; $i < size($objs); $i++){
			
		$random = floor(rand(0,$vtxCount[0]));
		$finalCmd = "move -a -xyz "+$objPos[$random]+" "+$objs[$i];
		float $rotateX = (rand($minRotationX,$maxRotationX) * $invertX);
		float $rotateY = (rand($minRotationY,$maxRotationY) * $invertY);
		float $rotateZ = (rand($minRotationZ,$maxRotationZ) * $invertZ);
		eval($finalCmd);
		if($scaleUniformly){
			float $scaleFactor = rand((($minScaleX + $minScaleY + $minScaleZ) / 3), (($maxScaleX + $maxScaleY + $maxScaleZ) / 3));
			scale -r -xyz $scaleFactor $scaleFactor $scaleFactor $objs[$i];
		} else {
			scale -r -xyz (rand($minScaleX,$maxScaleX)) (rand($minScaleY,$maxScaleY)) (rand($minScaleZ,$maxScaleZ)) $objs[$i];
		}
				
		//xform -os -r -t ($displacementX * (rand(-0.1,0.1))) ($displacementY * (rand(-0.1,0.1))) ($displacementZ * (rand(-0.1,0.1))) $objs[$i];
		xform -r -t ($displacementX * (rand(-0.1,0.1))) ($displacementY * (rand(-0.1,0.1))) ($displacementZ * (rand(-0.1,0.1))) $objs[$i];
		
		
		string $buffer[];
		$numTokens = `tokenize $objOrient[$random] " " $buffer`;
		
		if($orientState == 1){
			string $rotateEval;
			$rotateEval = ("rotate -a -xyz "+$buffer[0]+" "+$buffer[1]+" "+$buffer[2]+" "+$objs[$i]);
			eval($rotateEval);
		}else{
			//rotate -a -xyz $rotateX $rotateY $rotateZ $objs[$i];
			rotate -r -os $rotateX $rotateY $rotateZ $objs[$i];
			//rotate -os -a -xyz $rotateX $rotateY $rotateZ $objs[$i];
		}
		
		progressBar -e -max $progress -s 1 placeObjectRandomlyOnSunSurfaceProgressBar;
	}
	
	/*
	if($createGeometryConstraints || $createNormalConstraints){
		for($i=0;$i<`size $objs`;$i++){
			if($createGeometryConstraints){
				geometryConstraint -weight 1 $surface $objs[$i];
			}
			if($createNormalConstraints){
				normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $surface $objs[$i];
			}
		}
	}
	*/
	if($doGrouping){
		string $newGroupName = `textFieldGrp -q -text randomlyPlaceSurfaceObjectsGroupName`;
		$groupName = `group -em -n $newGroupName`;
		for($i=0;$i<`size $objs`;$i++){	
			if(`size $objList` > 0){
				$objs[$i] = $objList[$i];
			}
			parent $objs[$i] $groupName;
		}
	}
	
	progressBar -e -pr 0 placeObjectRandomlyOnSunSurfaceProgressBar;
	return $objs;

}

global proc assignSunSurfaceObject()
{
	string $sel[] = `ls -sl`;
	textFieldButtonGrp
		-e 
		-tx $sel[0] 
		getSunSurfaceObject
		;
		
	global string $SUNRAN_surface;
	$SUNRAN_surface = $sel[0];
}

global proc assignObjectToPlaceOnSun() 
{
	string $sel[] = `ls -sl`;
	textFieldButtonGrp
		-e 
		-tx $sel[0]
		getObjectToPlaceOnSun
		;

global string $SUNRAN_obj;
$SUNRAN_obj = $sel[0];
}

global proc assignReferenceCopyTransform()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp
	-e 
	-tx $sel[0]
	getReferenceCopyTransform
	;	

global string $SUNRAN_refTransform;
$SUNRAN_refTransform = $sel[0];
}


global proc sunDuplicateRandomSurfaceObjectSource()
{
string $flame = `textFieldButtonGrp -q -text getObjectToPlaceOnSun`;
float $flamePivot[] = `xform -q -pivots $flame`;
string $flameShape[] = `listRelatives -typ "fluidShape" $flame`;
int $baseRes = `getAttr ($flameShape[0] + ".baseResolution")`;
float $res[] = `getAttr ($flameShape[0] + ".resolution")`;
float $dimensions[] = `getAttr ($flameShape[0] + ".dimensions")`;
int $copyCount = `intSliderGrp -q -v duplicateRandomSurfaceObjectSourceCount`;
string $flameCopies[];
string $attrPresetName = "Temp";
string $newAttrPresetName = `saveAttrPreset $flameShape[0] $attrPresetName false`;
string $grpName = `textFieldGrp -q -text randomSurfaceObjectSourceDuplicateGroupName`;
string $dupName = `textFieldGrp -q -text randomSurfaceObjectSourceDuplicateName`;
string $grpFluids = `group -em -n $grpName`;
string $newFluids[];

int $i;
for($i=0;$i<$copyCount;$i++){
	string $newFlame = `create3DFluid 10 10 10 10 10 10`;
	applyAttrPreset $newFlame $newAttrPresetName 1;
	setAttr ($newFlame + ".baseResolution") $baseRes;
	//catch(`setAttr ($newFlame + ".resolution") $res[0] $res[1] $res[2]`);
	setAttr ($newFlame + ".dimensions") $dimensions[0] $dimensions[1] $dimensions[2];
	select -r $newFlame;
	
	rename ($dupName + "Shape" + $i);
	string $sel[] = `ls -sl`;
	string $rels[] = `listRelatives -p -typ "transform" $sel[0]`;
	select -r $rels[0];
	rename ($dupName + $i);
	select -r ($dupName + $i);
	 
	string $ss[] = `ls -sl`;
	$newFluids[$i] = $ss[0];
	xform -pivots $flamePivot[0] $flamePivot[1] $flamePivot[2] $newFluids[$i];	
	$newFlame = $sel[0];	
	textScrollList
		-edit
		-append $newFlame
		getRandomlyPlacedFluidObjects
		;
		
}
int $conAttr = `checkBoxGrp -q -v1 surfaceFlamesAutoConnectAllFluidAttributes`;
select -cl;
if($conAttr == 1){
	select -add $flame;
}
for($i=0;$i<`size $newFluids`;$i++){
	if($conAttr == 1){
		select -add $newFluids[$i];
	}	
}
if($conAttr == 1){
	connectAllFluidAttributes();	
}

string $endSelected[] = `ls -sl`;
for($i=0;$i<`size $endSelected`;$i++){
	//print("Selected: " + $endSelected[$i] + "\n");
}

for($i=0;$i<`size $newFluids`;$i++){
	parent $newFluids[$i] $grpFluids;	
}

}

global proc sunDuplicateRandomSurfaceObjectCreateFluidVolumePrimitives()
{
string $fluid = `textFieldButtonGrp -q -text getObjectToPlaceOnSun`;	
string $fluidShape[] = `listRelatives -typ "fluidShape" $fluid`;
string $fluidDups[] = `textScrollList -q -ai getRandomlyPlacedFluidObjects`;
int $i;
for($i=0;$i<`size $fluidDups`;$i++){
	createImplicitVolumeProc("cube");
	string $box = `ls -sl`;
	
}
}

global proc sunAttachCacheToRandomSurfaceObjectsFluidCopies()
{
string $fluid = `textFieldButtonGrp -q -text getObjectToPlaceOnSun`;	
string $fluidShape[] = `listRelatives -typ "fluidShape" $fluid`;
string $cacheFile[] = `listConnections -t cacheFile $fluidShape[0]`;
if(`size $cacheFile` == 0){
	print("There is no cacheFile on the Randomly Placed Fluid Object Source fluid. Skipping cacheFile." + "\n");
	return;
}

string $fluidDups[] = `textScrollList -q -ai getRandomlyPlacedFluidObjects`;
int $i;
for($i=0;$i<`size $fluidDups`;$i++){
	string $newCacheFile[] = `duplicate $cacheFile[0]`;

		connectAttr -f ($newCacheFile[0] + ".inRange") ($fluidDups[$i] + ".playFromCache");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[0]") ($fluidDups[$i] + ".inDensity");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[1]") ($fluidDups[$i] + ".inVelocity");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[2]") ($fluidDups[$i] + ".inTemperature");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[3]") ($fluidDups[$i] + ".inReaction");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[4]") ($fluidDups[$i] + ".inColor");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[5]") ($fluidDups[$i] + ".inFalloff");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[6]") ($fluidDups[$i] + ".inResolution");

		connectAttr -f ($newCacheFile[0] + ".outCacheData[7]") ($fluidDups[$i] + ".inOffset");

	connectAttr -f time1.outTime ($newCacheFile[0] + ".time");	
}

}

global proc sunRandomizeRandomSurfaceObjectCacheTraxClip(string $obj[])
{
$doFluidDuplication = `checkBox -q -v randomSurfaceObjectDuplicationDoFluidDuplication`;
float $ranAmount;
if($doFluidDuplication){
	$obj = `textScrollList -q -ai getRandomlyPlacedFluidObjects`;
	$ranAmount = `floatSliderButtonGrp -q -v randomSurfaceObjectFluidCacheTraxClip`;	
} else {
	$obj = getAllFluidsInSelected($obj);
	//print("Randomize Trax Clips Found Fluid Objs: \n");
	//print $obj;
	//print("\n");
	$ranAmount = `floatSliderButtonGrp -q -v randomSurfaceObjectCacheTraxClip`;
}

int $i;
string $cacheFileNode[];
for($i=0;$i<`size $obj`;$i++){
	string $cacheNode[] = `listConnections -t cacheFile $obj[$i]`;
	appendStringArray($cacheFileNode, $cacheNode, 1);	
	if(`size $cacheNode` == 0){
		string $cacheBlend[] = `listConnections -t cacheBlend $obj[$i]`;
		if(`size $cacheBlend` > 0){
			for($p=0;$p<`size $cacheBlend`;$p++){
				$cacheNode = `listConnections -t cacheFile $cacheBlend[$p]`;
				appendStringArray($cacheFileNode, $cacheNode, `size $cacheNode`);
			}
		} else {
			//print("No Cache File Found on " + $obj[$i] + ". Cannot Randomize Cache Start Time.\n");
		}
	}	
}
if(`size $cacheFileNode` == 0 || $cacheFileNode[0] == ""){
	print("No Cache Files Found. Cannot Randomize Cache Start Time.\n");
} else {
	for($i=0;$i<`size $cacheFileNode`;$i++){
		float $startFrame = `getAttr ($cacheFileNode[$i] + ".startFrame")`;
		float $ran = floor(rand(($startFrame - $ranAmount), $startFrame));
		setAttr ($cacheFileNode[$i] + ".startFrame") $ran;
		print("Set Cache File: " + $cacheFileNode[$i] + " Start Frame To: " + $ran + "\n");
	}
}
}

global proc getAnimationClipsAndRandomizeStartTimes(string $obj[])
{
float $ranAmount = `floatSliderButtonGrp -q -v randomSurfaceObjectCacheTraxClip`;
int $i;
string $animClipNode[];
$obj = getListOfGroupHierarchy($obj);
for($i=0;$i<`size $obj`;$i++){
	string $animClip[] = `listConnections -t animClip $obj[$i]`;
	appendStringArray($animClipNode, $animClip, 1);	
}
if(`size $animClipNode` == 0 || $animClipNode[0] == ""){
	print("No Animation Clips Found. Cannot Randomize Animation Clips Start Time.\n");
} else {
	for($i=0;$i<`size $animClipNode`;$i++){
		float $startFrame = `getAttr ($animClipNode[$i] + ".startFrame")`;
		float $ran = floor(rand(($startFrame - $ranAmount), $startFrame));
		setAttr ($animClipNode[$i] + ".startFrame") $ran;
		print("Set Animation Clip: " + $animClipNode[$i] + " Start Frame To: " + $ran + "\n");
	}
}
}

global proc string[] searchAllConnectionsForNodeType(string $obj[], string $nodeType)
{
int $i;
string $foundNode[];
string $connections[];
int $searchDepth = 5;
int $searches = 0;
print("Searching For Animation Clip >>>>>" + "\n");
print("Search Stopped Because Function Is Incomplete!, Please Fix!\n");
return $foundNode;

while($searches < $searchDepth){
	for($i=0;$i<`size $obj`;$i++){
		string $node[] = `listConnections -t $nodeType $obj[$i]`;
		if(`size $node` == 0){
			$node = `listConnections -s false $obj[$i]`;
			appendStringArray($connections, $node, `size $node`);
		} else {
			appendStringArray($foundNode, $node, `size $node`);
		}
		print("....." + $obj[$i] + "\n");
	}
	$node = searchDeepConnectionsForNodeType($connections,$nodeType);
	appendStringArray($foundNode, $node, `size $node`);
	clear $obj;
	appendStringArray($obj, $node, `size $node`);
	$searches++;
}
string $confirmNode[];
for($i=0;$i<`size $foundNode`;$i++){
	string $objType = `objectType $foundNode[$i]`;
	if($objType == "animClip"){
		//appendStringArray($confirmNode, $node, `size $node`);
		$confirmNode[`size $confirmNode`] = $foundNode[$i];
	}
}
if(`size $confirmNode` == 0 || $confirmNode[0] == ""){
	print("Could Not Find Any Animation Clips.\n");
} else {
	return $confirmNode;
}
}

global proc string[] searchDeepConnectionsForNodeType(string $obj[], string $nodeType)
{
int $i;
string $foundNode[];
string $connections[];
for($i=0;$i<`size $obj`;$i++){
		string $node[] = `listConnections -t $nodeType $obj[$i]`;
		if(`size $node` == 0){
			$node = `listConnections -s false $obj[$i]`;
			appendStringArray($connections, $node, `size $node`);
		} else {
			appendStringArray($foundNode, $node, `size $node`);
		}
		
	print("....." + $obj[$i] + "\n");
}
if(`size $foundNode` == 0 || $foundNode[0] == ""){
	return $connections;
} else {
	return $foundNode;
}
}

global proc assignObjectsToPlaceOnSun()
{
string $sel[] = `ls -sl`;
int $i;
for($i=0;$i<`size $sel`;$i++){
	textScrollList -edit -append $sel[$i] getObjectsToPlaceOnSun;
}

}

global proc removeObjectToPlaceOnSun()
{
string $sel[] = `textScrollList -q -si getObjectsToPlaceOnSun`;
int $i;
for($i=0;$i<`size $sel`;$i++){
	textScrollList	-edit -ri $sel[$i] getObjectsToPlaceOnSun;
}

}

global proc clearObjectsToPlaceOnSun()
{
textScrollList -e -ra getObjectsToPlaceOnSun;
}

global proc assignRandomlyPlacedFluids()
{
string $sel[] = `ls -sl`;
//global string $SUN_sunFlamesFluids[];
if(`size $sel` == 0){
	error "Nothing is selected. Select the Randomly Placed Source Object.";
	return;
}
int $i;
for($i=0;$i<`size $sel`;$i++){
	textScrollList
		-edit
		-append $sel[$i]
		getRandomlyPlacedFluidObjects;
	//$SUN_sunFlamesFluids[$i] = $sel[$i];
}

}

global proc removeRandomlyPlacedFluidsObjects()
{
string $sel[] = `textScrollList -q -si getRandomlyPlacedFluidObjects`;
int $i;
for($i=0;$i<`size $sel`;$i++){
	textScrollList
		-edit
		-ri $sel[$i]
		getRandomlyPlacedFluidObjects
		;
}
}

global proc clearRandomlyPlacedFluidsObjects()
{
textScrollList
	-e
	-ra
	getRandomlyPlacedFluidObjects;
}

global proc randomizeSelectedFluidCacheStartTimesLayout(string $parent)
{
string $randomizeFluidsCacheLayout = `frameLayout
			-l "Randomize Cache"	
			-ann ""
			-bv true
			-la "center"
			-li 10
			-lv true
			-mw 10
			-mh 10		
			
			-cll true
			-cl true
			-parent $parent		
			`;
		
		floatFieldGrp						
			-nf 2
			-l "Random Range"
			-v1 -1000
			-v2 1000
			cacheStartTimeRandomRange
			;
		/*
		intSliderGrp 
			-l "Random Amount" 
			-minValue 1		
			-maxValue 1000
			-value 100 
			-fieldMinValue 1 
			-fieldMaxValue 10000000
			-field true	
			-ann ""
			-cw3 300 50 90
			setCacheStartTimeRandomAmount			
			;
		*/
		
		button 
			-l "Randomize Selectd Fluid's Cache Start Times"
			-c "randomizeSelectedFluidCacheStartTimes"
			;
			
		button 
			-l "Randomize Selected Cache's Start Times"
			-c "randomizeSelectedCacheStartTimes"
			;	
			
			setParent..;
}

global proc randomizeSelectedFluidCacheStartTimes()
{
string $fluids[] = `ls -dag -s -sl`;
//int $ranAmount = `intSliderGrp -q -v setCacheStartTimeRandomAmount`;
float $ranLow = `floatFieldGrp -q -v1 cacheStartTimeRandomRange`;
float $ranHigh = `floatFieldGrp -q -v2 cacheStartTimeRandomRange`;
 
int $i;
int $p;
for($i=0;$i<`size $fluids`;$i++){
	string $cacheNode[] = `listConnections -t cacheFile $fluids[$i]`;
	string $cacheFileNode[];
	
	if(`size $cacheNode` == 0){
		string $cacheBlend[] = `listConnections -t cacheBlend $fluids[$i]`;
		if(`size $cacheBlend` > 0){
			for($p=0;$p<`size $cacheBlend`;$p++){
				$cacheFileNode = `listConnections -t cacheFile $cacheBlend[$p]`;
				//$cacheNode[0] = `listConnections -t cacheFile $cacheBlend[$p]`;
			}
		} else {
			print("No Cache File Found on " + $fluids[$i] + ". Cannot Randomize Cache Start Time.\n");
			//continue;
		}
	}
	for($p=0;$p<`size $cacheFileNode`;$p++){
		float $startFrame = `getAttr ($cacheFileNode[$p] + ".startFrame")`;
		float $ran = floor(rand(($startFrame + $ranLow), ($startFrame + $ranHigh)));
		setAttr ($cacheFileNode[$p] + ".startFrame") $ran;
	}
	
}

}

global proc randomizeSelectedCacheStartTimes()
{
string $cache[] = `ls -sl`;
//int $ranAmount = `intSliderGrp -q -v setCacheStartTimeRandomAmount`; 
float $ranLow = `floatFieldGrp -q -v1 cacheStartTimeRandomRange`;
float $ranHigh = `floatFieldGrp -q -v2 cacheStartTimeRandomRange`;
int $i;
for($i=0;$i<`size $cache`;$i++){
	float $startFrame = `getAttr ($cache[$i] + ".startFrame")`;
	float $ran = floor(rand(($startFrame + $ranLow), ($startFrame + $ranHigh)));
	setAttr ($cache[$i] + ".startFrame") $ran;	
}
}

global proc string[] getAllFluidsInSelected(string $sel[])
{
int $i;
string $fluids[];
for($i=0;$i<`size $sel`;$i++){
	string $rel[] = `listRelatives -ad -type "fluidShape" $sel[$i]`;
	appendStringArray($fluids, $rel, `size $rel`);		
}
return $fluids;
}

global proc string stripOutNumbersFromString(string $string)
{
int $i;
for($i=0;$i<10;$i++){
	$string = substituteAllString($string, $i, "");
}
return $string;
}

global proc sunRandomizeRandomSurfaceObjectRandomizeTransformSettings()
{
float $ran = `floatSliderButtonGrp -q -v randomSurfaceObjectRandomizeTransformSettings`;
float $newRan;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan randomTranslationX;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan randomTranslationY;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan randomTranslationZ;
}

global proc sunRandomizeRandomSurfaceObjectRandomizeRotationSettings()
{
float $ran = `floatSliderButtonGrp -q -v randomSurfaceObjectRandomizeRotationSettings`;
float $newRan;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minRotationX;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minRotationY;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minRotationZ;

$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxRotationX;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxRotationY;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxRotationZ;

}

global proc sunRandomizeRandomSurfaceObjectRandomizeScaleSettings()
{
float $ran = `floatSliderButtonGrp -q -v randomSurfaceObjectRandomizeScaleSettings`;
float $newRan;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minScaleX;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minScaleY;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan minScaleZ;

$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxScaleX;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxScaleY;
$newRan = rand(0, rand($ran));
floatField -edit -v $newRan maxScaleZ;

}

global proc sunRandomizeRandomSurfaceObjectRandomizeAllSettings()
{
float $ran = `floatSliderButtonGrp -q -v randomSurfaceObjectRandomizeAllSettings`;
float $newRan;

$newRan = rand(0, rand($ran));
floatSliderButtonGrp -edit -v $newRan randomSurfaceObjectRandomizeTransformSettings;
sunRandomizeRandomSurfaceObjectRandomizeTransformSettings();

$newRan = rand(0, rand($ran));
floatSliderButtonGrp -edit -v $newRan randomSurfaceObjectRandomizeRotationSettings;
sunRandomizeRandomSurfaceObjectRandomizeRotationSettings();

$newRan = rand(0, rand($ran));
floatSliderButtonGrp -edit -v $newRan randomSurfaceObjectRandomizeScaleSettings;
sunRandomizeRandomSurfaceObjectRandomizeScaleSettings();

}

global proc string[] getListOfGroupHierarchy(string $obj[])
{
int $i;
string $allRel[];
for($i=0;$i<`size $obj`;$i++){
	string $rel[] = `listRelatives -ad $obj[$i]`;
	appendStringArray($allRel, $rel, `size $rel`);
}
return $allRel;
}


global proc assignRandomAttributesObjects(string $parent)
{
string $sel[]=`ls -sl`;
if(`size $sel`==0){
	error "Nothing is selected.";
	return;
}
int $i;
string $attr[];
string $attrSel[];
for($i=0;$i<`size $sel`;$i++){
	$attrSel = `listAttr -sa -m $sel[$i]`;
	appendStringArray($attr, $attrSel, `size $attrSel`);
}
$attr = stringArrayRemoveDuplicates($attr);

for($i=0;$i<`size $sel`;$i++){
	textScrollList 
		-e
		-a $sel[$i]
		getRandomAttributesObjects;		
}
textScrollList
	-edit
	-ra
	attributesToRandomize
	;

for($i = 0; $i<`size $attr`; $i++){
	textScrollList
		-edit
		-a $attr[$i]
		attributesToRandomize
		;
}
}

global proc clearRandomAttributesObjectsList()
{
textScrollList
	-edit
	-ra
	getRandomAttributesObjects
	;
textScrollList
	-edit
	-ra
	attributesToRandomize
	;
}

global proc removeAnimationExpressionObjects()
{
string $sel[] = `textScrollList -q -si getAnimationExpressionObjects`;
int $i;
for($i=0;$i<`size $sel`;$i++){
	textScrollList
		-edit
		-ri $sel[$i]
		getAnimationExpressionObjects
		;
}
updateRandomObjectsAttributesList();
}

global proc updateRandomObjectsAttributesList()
{
string $sel[] = `textScrollList -q -ai getRandomAttributesObjects`;
int $i;
string $attr[];
string $attrSel[];
for($i=0;$i<`size $sel`;$i++){
	$attrSel = `listAttr -sa -m $sel[$i]`;
	appendStringArray($attr, $attrSel, `size $attrSel`);
}
$attr = stringArrayRemoveDuplicates($attr);

textScrollList
	-edit
	-ra
	attributesToRandomize
	;

for($i = 0; $i<`size $attr`; $i++){
	textScrollList
		-edit
		-a $attr[$i]
		attributesToRandomize
		;
}

}

global proc sortRandomObjectAttributesList()
{
string $attr[] = `textScrollList -q -ai attributesToRandomize`;
string $sortedList[] = `sort $attr`;

textScrollList
	-edit
	-ra
	attributesToRandomize
	;
	
int $i;
for($i = 0; $i<`size $sortedList`; $i++){
	textScrollList
		-edit
		-a $sortedList[$i]
		attributesToRandomize
		;
}

}

global proc randomizeObjectAttributesInList()
{
string $obj[] = `textScrollList -q -ai getRandomAttributesObjects`;
sunRandomizeObjectAttributes($obj);	
}

global proc sunRandomizeObjectAttributes(string $obj[])
{
print("Begin Randomize Process... \n");
print("ObjSize: " + `size $obj` + "\n");
string $dupType = `optionMenuGrp -q -v placeRandomObjectOnSurfaceDuplicteType`;	
string $ranObj[] = `textScrollList -q -ai getRandomAttributesObjects`;
string $ranAttr[] = `textScrollList -q -si attributesToRandomize`;
float $lowRan = `floatFieldGrp -q -v1 randomObjectsAttributesRandomRange`;
float $highRan = `floatFieldGrp -q -v2 randomObjectsAttributesRandomRange`;

if($dupType == "referenceCopy"){	
	int $i;
	int $p;
	int $q;
	for($i=0;$i<`size $obj`;$i++){
		print("Looking For Object Attributes To Randomize In: " + $obj[$i] + "\n");
		string $rel[] = `listRelatives -ad $obj[$i]`;
		print("Relatives: " + "\n");
		print $rel;
		print ("\n");
		for($p=0;$p<`size $rel`;$p++){			
			string $matchRel = stripOutNumbersFromString($rel[$p]);
			for($q=0;$q<`size $ranObj`;$q++){
				string $matchRanObj = stripOutNumbersFromString($ranObj[$q]);
				if($matchRel == $matchRanObj){
					randomizeObjectAttributesUsingRange($rel[$p],$ranAttr, $lowRan, $highRan); 					
				}
			}
			
			
		}
	}
} else {
	print("Finish Writing > Sunny.SunRandomizeObjectAttributes!\n");
	int $i;
	int $p;
	int $q;
	for($i=0;$i<`size $obj`;$i++){
		print("Looking For Object Attributes To Randomize In: " + $obj[$i] + "\n");
		string $rel[] = `listRelatives -ad $obj[$i]`;
		for($p=0;$p<`size $rel`;$p++){			 
			for($q=0;$q<`size $ranObj`;$q++){
				if($rel[$p] == $ranObj[$q]){
					randomizeObjectAttributesUsingRange($rel[$p],$ranAttr, $lowRan, $highRan);
				}

			}			
		}
	}
}

}

global proc randomizeObjectAttributesUsingRange(string $obj, string $attr[],float $lowRan,float $highRan)
{
int $i;
for($i=0;$i<`size $attr`;$i++){
	if(`attributeExists $attr[$i] $obj`){
		float $curVal = `getAttr ($obj + "." + $attr[$i])`;
		float $ranVal = rand(($curVal + $lowRan), ($curVal + $highRan));
		setAttr ($obj + "." + $attr[$i]) $ranVal;
		print("Randomized Obj: " + $obj + " Attr: " + $attr[$i] + " To Val: " + $ranVal + "\n");
	}
	
}

}

global proc setGlobalDupTypeVar()
{
string $dupType = `optionMenuGrp -q -v placeRandomObjectOnSurfaceDuplicteType`;
global int $SUNRAN_dupTypeCopy;
global int $SUNRAN_dupTypeInstance;
global int $SUNRAN_dupTypeRefDup;

if($dupType == "copy"){
	$SUNRAN_dupTypeCopy = true;
	$SUNRAN_dupTypeInstance = false;
	$SUNRAN_dupTypeRefDup = false;
} else if($dupType == "instance"){
	$SUNRAN_dupTypeCopy = false;
	$SUNRAN_dupTypeInstance = true;
	$SUNRAN_dupTypeRefDup = false;
} else if($dupType == "referenceCopy"){
	$SUNRAN_dupTypeCopy = false;
	$SUNRAN_dupTypeInstance = false;
	$SUNRAN_dupTypeRefDup = true;
}

}

global proc string[] sunDuplicateOnSurfaceFaces()
{
progressBar -e -pr 0 placeObjectRandomlyOnSunSurfaceProgressBar;
string $dupType = `optionMenuGrp -q -v placeRandomObjectOnSurfaceDuplicteType`;
string $refTransf = `textFieldButtonGrp -q -text getReferenceCopyTransform`;
$doGrouping = `checkBox -q -v randomSurfaceObjectDuplicationGroupingOption`;
$doCentering = `checkBox -q -v randomSurfaceObjectDuplicationCenteringOption`;
$createGeometryConstraints = `checkBoxGrp -q -v1 randomlyPlaceObjectConstraintOptions`;
$createNormalConstraints = `checkBoxGrp -q -v2 randomlyPlaceObjectConstraintOptions`;
$scaleUniformly = `checkBox -q -v randomScaleUniformlySetting`;
string $filePath = "";
string $sourceObj = `textFieldButtonGrp -q -tx getObjectToPlaceOnSun`;
if($dupType == "referenceCopy"){
	$filePath = `referenceQuery -f $sourceObj`;
	print("Referencing File: " + $filePath + "\n");
}
float $vertexPos[];
string $surface = `textFieldButtonGrp -q -tx getSunSurfaceObject`;
int $vtxCount[] = `polyEvaluate -v $surface`;
string $objPos[];
string $objOrient[] = {""};
string $finalCmd;
int $random = 0;
string $objName[];
string $groupName = "";

$normAlign = true;
$faceAlign = true;

select -r $surface;
ConvertSelectionToFaces;
$selected = `ls -sl`;
//$dup = `textFieldButtonGrp -q -text getFlamesFluid`; //For single duplicate obj
//string $dups[] = `textScrollList -q -ai getObjectToPlaceOnSun`; //For multiple duplicate objects

$arrayVert = `filterExpand -sm 31 $selected`; // Filter selected verts as an array.
$arrayEdge = `filterExpand -sm 32 $selected`; // Filter selected edges as an array.
$arrayFace = `filterExpand -sm 34 $selected`; // Filter selected faces as an array.
$arrayCVs = `filterExpand -sm 28 $selected`; // Filter selected CV's as an array.

// Get size of arrays.
int $vertSize = `size($arrayVert)`;
int $edgeSize = `size($arrayEdge)`;
int $faceSize = `size($arrayFace)`;
int $CVsSize = `size($arrayCVs)`;

int $selSize = `size($selected)`;
string $newRefObj[];

waitCursor -state on; // Turn waitcursor on for duplication process
if ($faceSize != 0){
	string $grpName = `textFieldGrp -q -text randomlyPlaceSurfaceObjectsGroupName`;
	$grpFace = `group -em -n $grpName`;
	int $p;
	for($faceNum in $arrayFace){
		string $obj[];
		if($dupType == "referenceCopy"){
			$obj = duplicateReferenceObjectGetNewObjAndTransform($sourceObj, $refTransf);			
		} else if($dupType == "copy"){
			$obj[0] = `duplicate $sourceObj`;
		} else if($dupType == "instance"){
			$obj[0] = `instance $sourceObj`;
		}	
	   
		float $avgFacePos[]= `xform -q -t -ws $faceNum`;
		
		int $avgFacePosListSize = size($avgFacePos)/3;
		
		float $fcX = 0;
		float $fcY = 0;
		float $fcZ = 0;
		
		for($i=0;$i<$avgFacePosListSize;$i++){
			$fcX = $fcX + $avgFacePos[$i * 3];
			$fcY = $fcY + $avgFacePos[$i * 3 + 1];
			$fcZ = $fcZ + $avgFacePos[$i * 3 + 2];
		}
		
		$fcX = $fcX / $avgFacePosListSize;
		$fcY = $fcY / $avgFacePosListSize;
		$fcZ = $fcZ / $avgFacePosListSize;
		
		move -rpr $fcX $fcY $fcZ $obj;
		if($normAlign){
			normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "scene" $faceNum $obj[0];
			delete -constraints $obj[0];
		
		}
		   
		if($faceAlign){
			//string $faceVerts[] = `polyInfo -faceToVertex ($selected[0] + ".f[$faceNum]")`;
			string $faceVerts[] = `polyInfo -faceToVertex $faceNum`;
			
			//Tokenize the faceVerts string so we have usefull numbers to work with.
			string $tokens[];
			tokenize $faceVerts[0] " :\n\r" $tokens;
			// Result: 6 //
			
			int $vertexOrder[];
			clear $vertexOrder;
			int $t;
			
			for($t=2;$t<`size $tokens`;$t++){
				$vertexOrder[`size $vertexOrder`] = $tokens[$t];
			}
				   
			//Get the dir of each vert to vert, then get the vector of that dir
			//Get the smallest angle - that the angle we want to point in
			//Get the direction from the center or the face to the vert that has the smallest angle.         
			
			//select -r ($sunObj + ".vtx[" + $vertexOrder[0] + "]");
			float $vertPos[] = `xform -ws -q -t ($surface + ".vtx[" + $vertexOrder[0] + "]")`;
			string $vertLoc[] = `spaceLocator -a -p $vertPos[0] $vertPos[1] $vertPos[2]`;
			xform -cp $vertLoc[0];	  
			
			string $faceNorm[] = `polyInfo -fn $faceNum`;
			vector $normVect = translatePolyInfoNormal($faceNorm[0]);
			float $nv[3] = {$normVect.x,$normVect.y,$normVect.z};		
			cycleCheck -e off;
			
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector $nv[0] $nv[1] $nv[2]  $vertLoc[0] $obj[0];
			delete -constraints $obj[0];
			delete $vertLoc[0];
		
		}		
		parent $obj[0] $grpFace;
		select -cl;
		$newRefObj[`size $newRefObj`] = $obj[1];
		progressBar -e	-max $faceSize	-s 1 placeObjectRandomlyOnSunSurfaceProgressBar;
		$p++;
	}
}
print ("Duplicated " + $faceSize + " objects on faces... ");
waitCursor -state off;
progressBar -e -pr 0 placeObjectRandomlyOnSunSurfaceProgressBar;	
select -cl;
return $newRefObj;

}

global proc string[] duplicateReferenceObjectGetNewObjAndTransform(string $obj, string $refTransf)
{
string $filePath = `referenceQuery -f $obj`;
string $refSn = `referenceQuery -f -shn $obj`;
string $buffer[];
tokenize $refSn "." $buffer;
string $namespace = $buffer[0];
string $newRefFile = `file -r -gl -loadReferenceDepth "all" -namespace $namespace -options "v=0" $filePath`;
file -sa $newRefFile;
string $newRefObj;
string $newRefTransform;
if($refTransf == ""){
	$newRefTransform = `ls -hd 1 -sl`;
	$newRefObj = $newRefTransform;
} else {
	string $topRefObj[] = `ls -hd 1 -sl`;
	$newRefObj = $topRefObj[0];
	string $sel[] = `ls -sl`;
	int $i;
	for($i=0;$i<`size $sel`;$i++){
		string $matchSel = stripOutNumbersFromString($sel[$i]);
		string $matchRef = stripOutNumbersFromString($refTransf);
		if($matchSel == $matchRef){
			$newRefTransform = $sel[$i];					
		}
	}
}
string $returnObjs[2] = { $newRefTransform, $newRefObj};
return $returnObjs;

}

global proc selectReferenceObjectToDuplicate()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp -e -tx $sel[0] selectReferenceObjectToDuplicate;	
}

global proc sunDuplicateSelectedReferenceObject()
{
//string $sel[] = `ls -sl`;
//string $refObj = $sel[0];
string $refObj = `textFieldButtonGrp -q -text selectReferenceObjectToDuplicate`;
float $count = `intSliderGrp -q -v sunDuplicateSelectedReferenceObjectCount`;

int $i;
for($i=0;$i<$count;$i++){
	string $filePath = `referenceQuery -f $refObj`;
	string $refSn = `referenceQuery -f -shn $refObj`;
	string $buffer[];
	tokenize $refSn "." $buffer;
	string $namespace = $buffer[0];
	string $newRefFile = `file -r -gl -loadReferenceDepth "all" -namespace $namespace -options "v=0" $filePath`;
	//file -sa $newRefFile;
}

}

global proc createScaleYProportionalToScaleXZExpression()
{
string $objs[] = `ls -sl`;
string $obj = $objs[0];

if (attributeExists ("yScaleMultiplier", $obj)==0){
	addAttr -ln yScaleMultiplier -at double -k 1 -smx 10 -dv 2 $obj;
}

expression -s (
"float $yMult = yScaleMultiplier;\n"
+"scaleYProportionalToScaleXZ(\"" + $obj + "\", $yMult);\n"
+"global proc scaleYProportionalToScaleXZ(string $obj, float $amount)\n"
+"{\n"
+"float $scale[] = `getAttr ($obj + \".scale\")`;\n"
+"$scale[1] = pow($scale[0], $amount);\n"
+"setAttr ($obj + \".scale\") $scale[0] $scale[1] $scale[2];\n"
+"}\n"
) -o $obj -n ($obj + "ScaleYProportionalToScaleXZ");

}

global proc cameraAngleRampAlphaExpressionLayout(string $parent)
{
string $layout = `frameLayout
		-l "Camera Angle Ramp Alpha Expression"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
		
		textFieldButtonGrp
			-ed true
			-label "Sun Ramp Shader"
			-text  ""
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignSunRampShader"
			getSunRampShader
			;
		
		textFieldButtonGrp
			-ed true
			-label "Ramp Light"
			-text  ""
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignRampLight"
			getRampLight
			;
				
		button
			-label "Create Camera Angle Ramp Alpha Expression"
			-ann ""
			-command "createCameraAngleRampAlphaExpression"
			createCameraAngleRampAlphaExpression
			;
			
		setParent..;
		
}

global proc assignSunRampShader()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp -edit -text $sel[0] getSunRampShader;	
}

global proc assignRampLight()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp -edit -text $sel[0] getRampLight;	
}


global proc createCameraAngleRampAlphaExpression()
{
string $rampShader = `textFieldButtonGrp -q -text getSunRampShader`;
string $rampLight = `textFieldButtonGrp -q -text getRampLight`;
string $scriptName = "CameraAngleRampAlpha";

select -r $rampShader;

if (attributeExists ("cameraDistanceBias", $rampShader)==0){
	addAttr -ln cameraDistanceBias -at double -k 1 -smn 0 -smx 100 -dv 10 $rampShader;
}

if (attributeExists ("falloffFactor", $rampShader)==0){
	addAttr -ln falloffFactor -at double -k 1 -smn 0 -smx 10 -dv 2 $rampShader;
}

if (attributeExists ("alphaTransparentColor", $rampShader)==0){
	addAttr -ln alphaTransparentColor -uac -at float3;
    addAttr -ln rTrans -at "float" -p alphaTransparentColor;
    addAttr -ln gTrans -at "float" -p alphaTransparentColor;
    addAttr -ln bTrans -at "float" -p alphaTransparentColor;
}

if (attributeExists ("incandescenceTexturePosition", $rampShader)==0){
	addAttr -ln incandescenceTexturePosition -at double -k 1 -min 0 -max 1.02 $rampShader;
}

string $script = (
"cameraAngleRampAlpha();\n"
+"global proc cameraAngleRampAlpha()\n"
+"{\n"
+"string $rampShader = " + "\"" + $rampShader + "\"" + ";\n"
+"string $rampLight = " + "\"" + $rampLight + "\"" + ";\n"
+"string $cam = getWizCurrentCamera();\n"
+"string $nodeType = `nodeType $cam`;\n"
+"string $camTransform[];\n"
+"if($nodeType != \"transform\"){\n"
+"	$camTransform = `listTransforms $cam`;\n"
+"} else {\n"
+"	$camTransform[0] = $cam;\n"
+"}\n"
+"float $camPos[] = `xform -q -t $camTransform[0]`;\n"
+"float $camRot[] = `xform -q -ro $camTransform[0]`;\n"
+"xform -t $camPos[0] $camPos[1] $camPos[2] $rampLight;\n"
+"xform -ro $camRot[0] $camRot[1] $camRot[2] $rampLight;\n"
+"float $camDis = getDistanceFromObjToCenter($camTransform[0]);\n"
+"float $camDisBias = `getAttr ($rampShader + \".cameraDistanceBias\")`;\n"
+"float $falloffFactor = `getAttr ($rampShader + \".falloffFactor\")`;\n"
+"float $alphaColor = clamp(0, 1, ($camDisBias / $camDis));\n" 
+"$alphaColor = clamp(0, 1, (pow($alphaColor, $falloffFactor)));\n"
+"setAttr ($rampShader + \".alphaTransparentColor\") -type double3 $alphaColor $alphaColor $alphaColor ;\n"
+"//float $incPosMult = ($camDis / $camDisBias) * ($falloffFactor * 0.1);\n"
+"//float $incPos = clamp(0.2, 1, (((1 / $camDisBias) * $camDis)* $incPosMult));\n"

+"$incPos = clamp(0, 1, (1 - $alphaColor));\n"
+"$incPos = clamp(0, 1, ($incPos + ($falloffFactor * 0.01)));\n"
+"setAttr ($rampShader + \".incandescenceTexturePosition\") $incPos;\n"
+"}\n"
+"\n"
+"global proc float getDistanceFromObjToCenter(string $obj)\n"
+"{\n"
+"float $objPos[] = `xform -q -ws -t $obj`;\n"
+"float $dis = sqrt( (($objPos[0] - 0) * ($objPos[0] - 0)) + (($objPos[1] - 0) * ($objPos[1] - 0))+(($objPos[2] - 0) * ($objPos[2] - 0)));\n"
+"return $dis;\n"
+"}\n"
);
catchQuiet(`delete $scriptName`);
expression -s ($script) -n ($scriptName);	
//string $nodeName = `scriptNode -st 7 -bs $script -n $scriptName`;
addGetWizCurrentCameraToExpressions();
}

global proc float getDistanceFromObjToObj(string $obj1, string $obj2)
{
float $obj1Pos[] = `xform -q -ws -t $obj1`;
float $obj2Pos[] = `xform -q -ws -t $obj2`;
float $dis = sqrt( (($obj1Pos[0] - $obj2Pos[0]) * ($obj1Pos[0] - $obj2Pos[0])) + (($obj1Pos[1] - $obj2Pos[1]) * ($obj1Pos[1] - $obj2Pos[1]))+(($obj1Pos[2] - $obj2Pos[2]) * ($obj1Pos[2] - $obj2Pos[2])));
return $dis;
}

global proc instanceGranuleGridNearCameraLayout(string $parent)
{
string $layout = `frameLayout
		-l "Instance Granules Near Camera"	
		-ann ""
		-bv true
		-la "center"
		-li 10
		-lv true
		-mw 10
		-mh 10		
		
		-cll true
		-cl true
		-p $parent
		`;
		
		textFieldButtonGrp
			-ed true
			-label "Granule Grid"
			-text  ""
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignGranuleGrid"
			getGranuleGrid
			;
		
		floatSliderGrp 
			-l "Sun Size" 
			-minValue 0.01		
			-maxValue 1000
			-value 96 
			-fieldMinValue 0.0001 
			-fieldMaxValue 10000000
			-field true	
			-ann ""
			granuleGridSunSize			
			;
			
		floatSliderGrp 
			-l "Granule Grid Size" 
			-minValue 0.01		
			-maxValue 1000
			-value 30 
			-fieldMinValue 0.0001 
			-fieldMaxValue 10000000
			-field true	
			-ann ""
			granuleGridSize			
			;
		/*
		checkBox 
			-l "Use Current Camera"
			-v true
			granuleInstanceUseCurrentCameraOption
			;
		*/
		textFieldButtonGrp
			-ed true
			-label "Camera To Use"
			-text  ""
			-ann ""
			-cal 1 "center"
			-buttonLabel "Select"
			-bc "assignGranuleGridCamera"
			getGranuleGridCamera
			;
			
					
		button
			-label "Create Instance Granule Grid Near Camera Expression"
			-ann ""
			-command "createInstanceGranuleGridNearCameraExpression"
			createInstanceGranuleGridNearCameraExpression
			;
			
		//setParent..;
			
}

global proc createInstanceGranuleGridNearCameraExpression()
{
//minAngle should be a little less than the size of the granule
//maxAngle should be a little more to twice as much as size of granule
float $surfaceOffset = 96;
string $granules = `textFieldButtonGrp -q -text getGranuleGrid`;
//string $sun = `textFieldButtonGrp -q -text getGranuleGridSunSurface`;
float $granuleGridSize = `floatSliderGrp -q -v granuleGridSize`;
float $sunSize = `floatSliderGrp -q -v granuleGridSunSize`;
string $gc[] = `spaceLocator -p 0 0 0 -n "GranuleController"`;
string $granuleController = $gc[0];
float $minAngle = $granuleGridSize * 0.9;
float $maxAngle = $granuleGridSize * 1.1;
string $cam = `textFieldButtonGrp -q -text getGranuleGridCamera`;
string $camVar = ("string $cam = getWizCurrentCamera();\n");

if($cam != ""){
	$camVar = ("string $cam = " + "\"" + $cam + "\"" + ";\n");
	
}

if (attributeExists ("cameraMinDistance", $granuleController)==0){
	addAttr -ln "cameraMinDistance" -at double -k 1 -smn 0 -smx 1000 -dv 110 $granuleController;
}
if (attributeExists ("instanceMinAngle", $granuleController)==0){
	addAttr -ln "instanceMinAngle" -at double -k 1 -smn 0 -smx 60 -dv $minAngle $granuleController;
}
if (attributeExists ("instanceMaxAngle", $granuleController)==0){
	addAttr -ln "instanceMaxAngle" -at double -k 1 -smn 0 -smx 120 -dv $maxAngle $granuleController;
}
if (attributeExists ("granuleSize", $granuleController)==0){
	addAttr -ln "granuleSize" -at double -k 1 -smn 0 -smx 100 -dv $granuleGridSize $granuleController;
}

//Create a locator to help with the placement of the granules
string $gpl[] = `spaceLocator -p 0 0 0 -n "GranulePlacementLocator"`;
xform -t 0 $surfaceOffset 0 $gpl[0];
string $gplConstraint[] = `spaceLocator -p 0 0 0 -n "GranuleRotationLocator"`;
parentConstraint -mo -weight 1 $gplConstraint[0] $gpl[0];
string $granulePlacementLocator = $gpl[0];
string $granuleRotationLocator = $gplConstraint[0];
string $granuleDirectionLocator[] = createGranuleDirectionLocators($granuleRotationLocator);
string $granDirLocString = createStringFormatedStringArray($granuleDirectionLocator);

string $cpl[] = `spaceLocator -p 0 0 0 -n "CameraPlacementLocator"`;
xform -t 0 $surfaceOffset 0 $cpl[0];
string $crl[] = `spaceLocator -p 0 0 0 -n "CameraRotationLocator"`;
parentConstraint -mo -weight 1 $crl[0] $cpl[0];
string $cameraPlacementLocator = $cpl[0];
string $cameraRotationLocator = $crl[0];

group -n "GranulePlacementLocatorGroup" $granulePlacementLocator $granuleRotationLocator;
group -n "CameraPlacementLocatorGroup" $cameraPlacementLocator $cameraRotationLocator;

string $gplg = "GranulePlacementLocatorGroup";
string $cplg = "CameraPlacementLocatorGroup";
group -n "GranuleControllerGroup" $granuleController $gplg $cplg ;

//Initialize the granInstCamPos
global float $granInstCamPos[];
$granInstCamPos = { 0,0,0 };
global string $granuleInstance[];
clear $granuleInstance;

string $scriptName = "InstanceGranuleGridNearCamera";
string $script = (
"float $curTime = `currentTime -q`;\n"
+"float $startTime = `playbackOptions -q -min`;\n"
+"int $isPlaying = `play -q -state`;\n"
+"if($curTime == $startTime){\n"
+"	clearGranuleInstances();\n"
+"} else { \n"
+"	instanceGranuleGridNearCamera();\n"
+"}\n"
+"global proc instanceGranuleGridNearCamera()\n"
+"{\n"
+"string $granulePlacementLocator = " + "\"" + $granulePlacementLocator + "\"" + ";\n"
+"string $granuleRotationLocator = " + "\"" + $granuleRotationLocator + "\"" + ";\n"
+"string $granuleDirectionLocator[8] = " + $granDirLocString + ";\n"
+"string $cameraPlacementLocator = " + "\"" + $cameraPlacementLocator + "\"" + ";\n"
+"string $cameraRotationLocator = " + "\"" + $cameraRotationLocator + "\"" + ";\n"
+"string $granules = " + "\"" + $granules + "\"" + ";\n"
+"global string $granuleInstance[];\n"
+"global float $granInstCamPos[];\n"
+"float $disThreshold = cameraMinDistance;\n"
+"float $angleThreshold = instanceMinAngle;\n"
+"float $granuleSize = granuleSize;\n"
+"float $maxAngle = instanceMaxAngle;\n"
+"float $curTime = `currentTime -q`;\n"
+$camVar
+"string $nodeType = `nodeType $cam`;\n"
+"string $camTransform[];\n"
+"int $i;\n"
+"if($nodeType != \"transform\"){\n"
+"	$camTransform = `listTransforms $cam`;\n"
+"} else {\n"
+"	$camTransform[0] = $cam;\n"
+"}\n"
+"float $camPos[] = `xform -q -a -ws -t $camTransform[0]`;\n"
+"float $camDis = getDistanceFromObjToCenter($camTransform[0]);\n"
+"float $disFactor = $disThreshold - $camDis;\n"

+"string $camConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType \"vector\" -worldUpVector 0 1 0 $cam $cameraRotationLocator`;\n"
+"if($camDis <= $disThreshold){\n"
+"	float $granPlacLocPos[] = `xform -q -a -ws -t $granulePlacementLocator`;\n"
+"	float $camPlacLocPos[] = `xform -q -a -ws -t $cameraPlacementLocator`;\n"
+"	float $angleDiff = getAngleBetweenPositions($granPlacLocPos, $camPlacLocPos);\n"
+"	//print (\"AngleDiff: \" + $angleDiff + \"\\n\");\n"
+"	// Remove any Granules out of range before we make any more granules \n"
+"	cleanUpGranuleInstancesOutOfRange($camPlacLocPos);\n"
+"	if($angleDiff > $maxAngle || `size $granuleInstance` == 0){ // If camera is out of range of original granule \n"
+"		string $aimConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType \"vector\" -worldUpVector 0 1 0 $cam $granuleRotationLocator`;\n"
+"		float $granPos[] = `xform -q -a -ws -t $granulePlacementLocator`;\n"
+"		float $granRot[] = `xform -q -ro $granuleRotationLocator`;\n"
+"		delete $aimConstraint[0];\n"
+"		print(\"<<<Re-Align Grid>>>\" + \" - Time: \" + $curTime + \"\\n\");\n"
+"	} else {\n"
+"		string $closest = getClosestGranuleDirectionLocator($camPlacLocPos, $granuleDirectionLocator);\n"
+"		float $newRot[] = `xform -q -a -ws -ro $closest`;\n"
+"		xform -a -ws -ro $newRot[0] $newRot[1] $newRot[2] $granuleRotationLocator;\n"
+"		//print(\">>>Re-Position Grid<<<\" + \" - Time: \" + $curTime + \"\\n\");\n"
+"	}\n"
+"	// Instantiate Granules within Range \n"
+"	if(`size $granuleInstance` < 8){\n"
+"		float $range = $angleThreshold;\n"
+"		createGranuleInstancesWithinRange($camPlacLocPos,$granuleDirectionLocator,$range);\n"
+"	}\n"
+"} else {\n"
+"	clearGranuleInstances();\n"
+"}\n"
+"delete $camConstraint[0];\n"
+"}\n"
+"\n"

+"global proc string createGranuleInstance(float $pos[], float $rot[])\n"
+"{\n"
+"string $granules = " + "\"" + $granules + "\"" + ";\n"
+"global string $granuleInstance[];\n"
+"//string $name = $granules + \"Instance\" + `size $granuleInstance`;\n"
+"string $newGranule[] = `instance $granules`;\n"
+"//string $newGranule[] = `duplicate -rc -ilf $granules`;\n"
+"parent -w $newGranule[0];\n"
+"xform -a -ws -t $pos[0] $pos[1] $pos[2] $newGranule[0];\n"
+"xform -a -ws -ro $rot[0] $rot[1] $rot[2] $newGranule[0];\n"
+"$granuleInstance[`size $granuleInstance`] = $newGranule[0];\n"
+"return $newGranule[0];\n"
+"}\n"
+"\n"

+"global proc createGranuleInstancesWithinRange(float $camPlacLocPos[], string $granuleDirectionLocator[], float $range)\n"
+"{\n"
+"global string $granuleInstance[];\n"
+"string $granulePlacementLocator = " + "\"" + $granulePlacementLocator + "\"" + ";\n"
+"string $allLoc[] = { $granulePlacementLocator };\n"
+"appendStringArray($allLoc, $granuleDirectionLocator, `size $granuleDirectionLocator`);\n"
+"string $inRange[] = getGranuleDirectionLocatorsWithinRange($camPlacLocPos, $allLoc, $range);\n"
+"int $i;\n"
+"int $p;\n"
+"for($i=0;$i<`size $inRange`;$i++){\n"
+"	float $locRot[] = `xform -q -a -ws -ro $inRange[$i]`;\n"
+"	float $locPos[] = `xform -q -a -ws -t $inRange[$i]`;\n"
+"	int $freeSpace = 1;\n"
+"	for($p=0;$p<`size $granuleInstance`;$p++){\n"
+"		float $gpos[] = `xform -q -a -ws -t $granuleInstance[$p]`;\n"
+"		float $angle = getAngleBetweenPositions($locPos,$gpos);\n"
+"		if($angle < 5){\n"
+"			$freeSpace = 0;\n"
+"		}\n"
+"	}\n"
+"	if($freeSpace == 1){\n"
+"		string $newGranule = createGranuleInstance($locPos, $locRot);\n"
+"	}\n"
+"}\n"
+"}\n"
+"\n"

+"global proc clearGranuleInstances()\n"
+"{\n"
+"global string $granuleInstance[];\n"
+"int $i;\n"
+"for($i=0;$i<`size $granuleInstance`;$i++){\n"
+"	delete $granuleInstance[$i];\n"
+"}\n"
+"clear $granuleInstance;\n"
+"}\n"
+"\n"

+"global proc cleanUpGranuleInstancesOutOfRange(float $camPlacLocPos[])\n"
+"{\n"
+"global string $granuleInstance[];\n"
+"string $removeGranules[];\n"
+"float $granuleSize = granuleSize;\n"
+"float $maxAngle = instanceMaxAngle;\n"
+"//float $range = $granuleSize * 1.5;\n"
+"float $range = $maxAngle;\n"
+"int $i;\n"
+"for($i=0;$i<`size $granuleInstance`;$i++){\n"
+"	float $granPos[] = `xform -q -a -ws -t $granuleInstance[$i]`;\n"
+"	float $granAngleDiff = getAngleBetweenPositions($granPos, $camPlacLocPos);\n"
+"	//print(\"GranAngleDiff: \" + $granAngleDiff + \"\\n\");\n"
+"	if($granAngleDiff > $range){\n"
+"		delete $granuleInstance[$i];\n"
+"		$removeGranules[`size $removeGranules`] = $granuleInstance[$i];\n"
+"	}\n"
+"}\n"
+"string $allGranules[] = stringArrayRemove($removeGranules, $granuleInstance);\n"
+"clear $granuleInstance;\n"
+"appendStringArray($granuleInstance, $allGranules, `size $allGranules`);\n"
+"//$granuleInstance = stringArrayRemove($removeGranules, $granuleInstance);\n"
+"}\n"
+"\n"

+"global proc float getDistanceFromObjToCenter(string $obj)\n"
+"{\n"
+"float $objPos[] = `xform -q -ws -t $obj`;\n"
+"float $dis = sqrt( (($objPos[0] - 0) * ($objPos[0] - 0)) + (($objPos[1] - 0) * ($objPos[1] - 0))+(($objPos[2] - 0) * ($objPos[2] - 0)));\n"
+"return $dis;\n"
+"}\n"
+"\n"

+"global proc float getDistanceFromObjAToObjB(string $objA, string $objB)\n"
+"{\n"
+"float $objPosA[] = `xform -q -ws -t $objA`;\n"
+"float $objPosB[] = `xform -q -ws -t $objB`;\n"
+"float $dis = sqrt( (($objPosA[0] - $objPosB[0]) * ($objPosA[0] - $objPosB[0])) + (($objPosA[1] - $objPosB[1]) * ($objPosA[1] - $objPosB[1]))+(($objPosA[2] - $objPosB[2]) * ($objPosA[2] - $objPosB[2])));\n"
+"return $dis;\n"
+"}\n"
+"\n"

+"global proc float getCameraAngleDifference(float $camPos[])\n"
+"{\n"
+"vector $camVector = <<$camPos[0],$camPos[1],$camPos[2]>>;\n"
+"global float $granInstCamPos[];\n"
+"vector $granInstCamVector = <<$granInstCamPos[0],$granInstCamPos[1],$granInstCamPos[2]>>;\n"
+"float $rad = `angle $camVector $granInstCamVector`;\n"
+"float $angle = `rad_to_deg $rad`;\n"
+"//print(\"CameraAngleDifference: \" + $angle + \"\\n\");\n"
+"return $angle;\n"
+"}\n"
+"\n"

+"global proc float getAngleBetweenPositions(float $pos1[], float $pos2[])\n"
+"{\n"
+"vector $v1 = <<$pos1[0],$pos1[1],$pos1[2]>>;\n"
+"vector $v2 = <<$pos2[0],$pos2[1],$pos2[2]>>;\n"
+"float $rad = `angle $v1 $v2`;\n"
+"float $angle = `rad_to_deg $rad`;\n"
+"return $angle;\n"
+"}\n"
+"\n"

+"global proc string getClosestGranuleDirectionLocator(float $refPos[], string $granuleDirectionLocator[])\n"
+"{\n"
+"string $granulePlacementLocator = " + "\"" + $granulePlacementLocator + "\"" + ";\n"
+"string $allLoc[] = { $granulePlacementLocator };\n"
+"appendStringArray($allLoc, $granuleDirectionLocator, `size $granuleDirectionLocator`);\n"
+"int $i;\n"
+"string $closest;\n"
+"float $closestDis = 999999999999;\n"
+"//print (\"Reference Pos X: \" + $refPos[0] +  \" Y: \" + $refPos[1] +  \" Z: \" + $refPos[2] + \"\\n\");\n"
+"for($i=0;$i<`size $allLoc`;$i++){\n"
+"	//print($allLoc[$i] + \" || \");\n"
+"	float $granPos[] = `xform -q -ws -t $allLoc[$i]`;\n"
+"	//print (\" X: \" + $granPos[0] +  \" Y: \" + $granPos[1] +  \" Z: \" + $granPos[2] + \"\\n\");\n"
+"	//float $curDis = sqrt( (($granPos[0] - $refPos[0]) * ($granPos[0] - $refPos[0])) + (($granPos[1] - $refPos[1]) * ($granPos[1] - $refPos[1]))+(($granPos[2] - $refPos[2]) * ($granPos[2] - $refPos[2])));\n"
+"	float $curAngle = getAngleBetweenPositions($granPos,$refPos);\n"
+"	//print(\"CurAngle: \" + $curAngle + \" ClosestAngle: \" + $closestDis + \"\\n\");\n"
+"	if($curAngle < $closestDis){\n"
+"		$closestDis = $curAngle;\n"
+"		$closest = $allLoc[$i];\n"
+"	}\n"
+"	//print(\"============================================================\" + \"\\n\");\n"
+"}\n"
+"//print(\">>>CLOSEST: \" + $closest + \"\\n\");\n"
+"//print(\"============================================================\" + \"\\n\");\n"
+"//print(\"============================================================\" + \"\\n\");\n"
+"//select -r $closest;\n"
+"return $closest;\n"
+"}\n"
+"\n"

+"global proc string[] getGranuleDirectionLocatorsWithinRange(float $camPos[], string $granuleDirectionLocator[], float $range)\n"
+"{\n"
+"float $granuleSize = granuleSize;\n"
+"string $inRange[];\n"
+"int $i;\n"
+"for($i=0;$i<`size $granuleDirectionLocator`;$i++){\n"
+"	float $granPos[] = `xform -q -ws -t $granuleDirectionLocator[$i]`;\n"
+"	float $angle = getAngleBetweenPositions($granPos,$camPos);\n"
+"	//print($granuleDirectionLocator[$i] + \" X: \" + $granPos[0] + \" Y: \" + $granPos[1] + \" Z: \" + $granPos[2] + \" Angle: \" + $angle + \"\\n\");\n"
+"	if($angle <= $range){\n"
+"		//print(\"<<InRange>> \" + \"\\n\");\n"
+"		$inRange[`size $inRange`] = $granuleDirectionLocator[$i];\n"
+"	}\n"
+"}\n"
+"return $inRange;\n"
+"}\n"
);
catchQuiet(`delete $scriptName`);
expression -s ($script) -o $granuleController -n $scriptName;
addGetWizCurrentCameraToExpressions();

}

global proc float getAngleBetweenTwoTransforms()
{
string $sel[] = `ls -sl`;
float $pos1[] = `xform -q -ws -t $sel[0]`;
float $pos2[] = `xform -q -ws -t $sel[1]`;
vector $v1 = <<$pos1[0],$pos1[1],$pos1[2]>>;
vector $v2 = <<$pos2[0],$pos2[1],$pos2[2]>>;
float $rad = `angle $v1 $v2`;
float $angle = `rad_to_deg $rad`;
//print("CameraGranuleAngleDifference: " + $angle + "\n");
return $angle;
}

global proc vector getDirectionVectorFromTwoPositions(float $posA[], float $posB[])
{
vector $dirVector;
$dirVector = <<($posA[0] - $posB[0]),($posA[1] - $posB[1]),($posA[2] - $posB[2])>>;
//$dirVector = <<ceil ($dirVector.x * 0.0001), ceil ($dirVector.y * 0.0001), ceil ($dirVector.z * 0.0001)>>;
return $dirVector;
}

global proc float[] getDirectionFromTwoPositions(float $posA[], float $posB[])
{
vector $dirVector;
$dirVector = <<($posA[0] - $posB[0]),($posA[1] - $posB[1]),($posA[2] - $posB[2])>>;
//$dirVector = <<ceil ($dirVector.x * 0.0001), ceil ($dirVector.y * 0.0001), ceil ($dirVector.z * 0.0001)>>;
float $direction[3];
$direction[0] = $dirVector.x;
$direction[1] = $dirVector.y;
$direction[2] = $dirVector.z;
return $direction;
}

global proc assignGranuleGrid()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp -e -tx $sel[0] getGranuleGrid;
}

global proc assignGranuleGridCamera()
{
string $sel[] = `ls -sl`;
textFieldButtonGrp -e -tx $sel[0] getGranuleGridCamera;	
}

global proc string[] createGranuleDirectionLocators(string $granulePlacementLocator)
{
float $size = `floatSliderGrp -q -v granuleGridSize`;
float $sunSize = `floatSliderGrp -q -v granuleGridSunSize`;
float $negSize = 0 - $size;
string $granuleDirectionLocator[];
string $granuleRotationLocator[];
int $i;
for($i=0;$i<8;$i++){
	string $grl[] = `spaceLocator -p 0 0 0 -n "GranuleRotationLocator"`;
	string $gpl[] = `spaceLocator -p 0 0 0 -n "GranulePlacementLocator"`;
	xform -t 0 $sunSize 0 $gpl[0];
	$granuleDirectionLocator[$i] = $gpl[0];
	$granuleRotationLocator[$i] = $grl[0];
	parent $gpl[0] $grl[0];
	parent $grl[0] $granulePlacementLocator;
}
xform -ro $negSize 0 $negSize $granuleRotationLocator[0];
xform -ro 0 0 $negSize $granuleRotationLocator[1];
xform -ro $size 0 $negSize $granuleRotationLocator[2];
xform -ro $size 0 0 $granuleRotationLocator[3];
xform -ro $size 0 $size $granuleRotationLocator[4];
xform -ro 0 0 $size $granuleRotationLocator[5];
xform -ro $negSize 0 $size $granuleRotationLocator[6];
xform -ro $negSize 0 0 $granuleRotationLocator[7];

return $granuleDirectionLocator;

}

global proc string[] createGranuleGridLocators()
{
string $gridLocators[];
int $gridSpacing = 20;
//float $gridCount = 360 / $gridSpacing;
//$gridCount = $gridCount * $gridCount * $gridCount;
//int $i;
int $p = 0;
int $xi;
int $yi;
int $zi;
for($xi=0;$xi<360;$xi){	
	for($yi=0;$yi<360;$yi){
		for($zi=0;$zi<360;$zi){				
			string $locName = ("GranuleGridLocator" + $p);
			print("P: " + $p + "\n");
			spaceLocator -p 0 100 0 -n $locName;
			string $groupName = ("GranuleGrid" + $p);
			group -n $groupName $locName;
			xform -ro $xi $yi $zi $groupName;
			$gridLocators[$p] = $locName;
			$p++;
			$zi = $zi + $gridSpacing;
		}
		$yi = $yi + $gridSpacing;
	}
	$xi = $xi + $gridSpacing;
}

return $gridLocators;
}

global proc string[] createCameraDirectionLocators(string $surface)
{
string $aim = "CameraAimDirection";
spaceLocator -p 0 0 0 -n $aim;
string $center = "WorldCenter";
spaceLocator -p 0 0 0 -n $center;

group -n "CameraDirectionGroup" $aim $center -p "CAMERAS";
geometryConstraint -weight 1 $surface $aim;
normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $surface $aim;

aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0  $aim $center;

string $loc[] = {$aim, $center};
return $loc;

}

global proc createRewindBeforeSavingScriptJob()
{

//int $jobNum = `scriptJob -e "SceneSaved" "rewindToFrameOne"`;
int $jobNum = `scriptJob -cc "writingFile" "rewindToFrameOne"`;

}

global proc rewindToFrameOne()
{
float $startTime = `playbackOptions -q -min`;
currentTime -edit $startTime;	
print ("Rewind to Frame 1 \n");
}

global proc createScriptJobToUpdateCameraWorldXRotation()
{
int $jobNum = `scriptJob -ac FullDomeCamera1.rotateX updateCameraWorldXRotation`;
}

global proc updateCameraWorldXRotation()
{
string $fullDomeCamera = "FullDomeCamera1";
//float $localRot[] = `xform -q -os -ro $fullDomeCamera`;
//setAttr ($fullDomeCamera + ".localX") $localRot[0];
//print ("Poop\n");
float $camPos[] = `xform -q -t $fullDomeCamera`;
float $camForward[] = `xform -q -t "CameraForwardLocator1"`;
float $worldPos[] = `xform -q -t "WorldCenterLocator1"`;
float $worldForward[] = `xform -q -t "WorldForwardLocator1"`;

print ("CamPos: " + $camPos[0] + " " + $camPos[1] + " " + $camPos[2] + "\n");
print ("CamForward: " + $camForward[0] + " " + $camForward[1] + " " + $camForward[2] + "\n");
print ("WorldPos: " + $worldPos[0] + " " + $worldPos[1] + " " + $worldPos[2] + "\n");
print ("WorldForward: " + $worldForward[0] + " " + $worldForward[1] + " " + $worldForward[2] + "\n");

float $camDir[] = getDirectionFromTwoPositions($camPos,$camForward);
vector $camVector = getDirectionVectorFromTwoPositions($camPos,$camForward);
float $worldDir[] = getDirectionFromTwoPositions($worldPos,$worldForward);
print ("CamDir: " + $camDir[0] + " " + $camDir[1] + " " + $camDir[2] + " " + "\n");
print ("CamVector: " + $camVector.x + " " + $camVector.y + " " + $camVector.z + " " + "\n");
//vector $camVector = getDirectionVectorFromTwoPositions($camPos,$camForward);
//vector $worldVector = getDirectionVectorFromTwoPositions($worldPos,$worldForward);
setAttr ($fullDomeCamera + ".cameraForwardX") $camDir[0];
setAttr ($fullDomeCamera + ".cameraForwardY") $camDir[1];
setAttr ($fullDomeCamera + ".cameraForwardZ") $camDir[2];
setAttr ($fullDomeCamera + ".worldForwardX") $worldDir[0];
setAttr ($fullDomeCamera + ".worldForwardY") $worldDir[1];
setAttr ($fullDomeCamera + ".worldForwardZ") $worldDir[2];
}